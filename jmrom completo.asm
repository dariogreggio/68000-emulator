

******** (file reassembled by G.Dar 4/1/23 #no23 #idiotseverywhere ) ********
OCCHIO NON è JS !!!!









                               QDOS VERSION 1.03


                                      AND


                            SuperBASIC VERSION "JM"



                        PARTIALLY COMMENTED DISASSEMBLY




                                      OR




   "Everything you ever wanted to know about the QL ROM but were afraid to ask -
                            A Technical Blockbuster."


                                   CONTENTS



    1. INTRODUCTION

       1.1 Some notes on style and presentation.
       1.2 Sources and references.
       1.3 Why I wrote this book.
       1.4 How to print out this disassembly.
       1.5 Variable names and other details.
       1.6 The hardware memory map.
       1.7 The QDOS software memory map.
       1.8 The SuperBASIC software memory map.
       1.9 The QL hardware.

           1.9.1 The structure of QDOS.

    2. The Disassembly

       2.1 Initialisation and Exception Handlers.

           2.1.1 Switch-on Or Reset Values.
           2.1.2 System Exception Vectors.

                 XHANDLER Initial Exception handler.

           2.1.3 Interrupt Vectors.
           2.1.4 Trap Vectors.
           2.1.5 QDOS System Vectors.
           2.1.6 Check For Ram Exception Table.

                 CHKRAMEX Check for RAM exception table.

           2.1.7 Dynamic Stop On Memory Test Failure.

                 BADRAM   Dynamic stop on memory test failure.

           2.1.8 Comprehensive main RAM and expansion RAM memory test.

                 MEMTEST  Comprehensive main RAM and expansion RAM memory test.

           2.1.9 Trap handlers for TRAP's #0,#1,#2,#3 and #4.

                 ENTER_SM Enter CPU supervisor mode.
                 MT_TRAP1 Memory management, job control and system housekeeping.
                 IO_TRAP2 I/O device allocation.
                 IO_TRAP3 Actual I/O, file handling and graphics.
                 SB_TRAP4 Use absolute instead of relative values in next trap.

           2.1.10 The interrupt handlers.

                 SYSINT   System interrupt handler.
                 EXTNLINT External interrupt handler.
                 CLEANUP  Clean up routine for all the trap handlers.
                 CHKSBIT  Check if supervisor mode bit set before trap.
                 EXITTRAP General exit to restore SuperBASIC's registers.

           2.1.11 Job ID handlers.

                 CHKJBID  Check job id.
                 GETJBID  Get current job's id & header address.

           2.1.12 I/O timers.

                 TIMER1   Timer for serial and microdrive I/O.
                 CLRTMODE Entry point when microdrive operations finished.

       2.2 Job control TRAP handlers.

           2.2.1 Handle TRAP #1 functions.

                 CHKTRP1  Handle trap #1 functions.

           2.2.2 Job details.

                 MT_INF   Get system information.
                 MT_JINF  Get job information.

           2.2.3 Job creation and deletion.

                 MT_CJOB  Create a job.
                 MT_RJOB  Remove a job.
                 MT_FRJOB Force remove a job.
                 FINDSUBS Find subsiduary in job tree.
                 MT_TRAPV Set up RAM exception table.

       2.3 Memory management TRAP handlers.

           2.3.1 Common heap.

                 MT_ALLOC Allocate heap space.
                 MT_LNKFR Release heap space.
                 MT_ALCHP Allocate common heap space.
                 MT_RECHP Release common heap space.

           2.3.2 Resident Procedure area.

                 MT_ALRES Allocate resident procedure space.
                 MT_RERES Release resident procedure area.

           2.3.3 SuperBASIC area.

                 MT_ALBAS Allocate basic area.
                 MT_REBAS Release basic area.

           2.3.4 Device modes.

                 MT_DMODE Set or read display mode.
                 MT_IPCOM Send IPC command.
                 MT_BAUD  Set serial port BAUD rate.

           2.3.5 Linked lists.

                 MT_LINK  Link item into list.
                 MT_UNLNK Unlink item from list.

       2.4 Multi-tasking.

           2.4.1 Frame interrupts.

                 FRAMEINT Handle frame interrupts.

           2.4.2 Scheduler.

                 SCHEDULE Re-arrange jobs to implement multi-tasking.

           2.4.3 Job status.

                 MT_SUSJB Suspend a job.
                 MT_RELJB Release a suspended job.
                 MT_PRIOR Change job priority.
                 MT_ACTIV Activate a job.

           2.4.4 Scheduling mechanism.

                 SHUTDOWN Copy a job's details to job header's storage area.
                 DECIDE   Find out which job is to be the next one.
                 STARTUP  Copy a job's details from job header's storage area.
                 EXECLIST Execute linked list of tasks.

       2.5 Simple device drivers.

           2.5.1 Serial device driver.

                 SEROPEN  Open a serial channel.
                 SERCLOSE Close a serial channel.
                 SER_IPC  Send IPC command to open or close a serial port.
                 SER_IO   General serial I/O.
                 SE_PEND  Test for pending input.
                 SE_SBYTE Send a byte.
                 SE_FBYTE Fetch a byte.

           2.5.2 Pipe device driver.

                 PIPEOPEN Open a pipe channel.
                 PIPECLOS Close a pipe channel.

           2.5.3 Console and Screen device driver.

                 CONOPEN  Open a console channel.
                 TRY_SCR  Check if a screen channel was specified instead.
                 SCRNMOK  Open a screen channel.
                 SCROPEN  Open a screen or console channel.
                 CONCLOSE Close a con or scr channel.
                 CON_IO   General console or screen channel I/O.
                 SC_PEND  Test pending I/P.
                 SC_FBYTE Fetch a byte.
                 SC_FSTRG Fetch a string of bytes.
                 SC_SSTRG Send a string of bytes.
                 SC_SBYTE Send a byte.
                 SC_FLINE Fetch a line.
                 SC_EDLIN Edit a line.

           2.5.4 Network device driver.

                 NETOPEN  Open a network channel.
                 NETCLOSE Close a network channel.
                 NET_IO   General network I/O.
                 NT_PEND  Test for pending I/P.
                 NT_FBYTE Fetch a byte.
                 NT_SBYTE Send a byte.

           2.5.5 Start of scheduler linked list.

                 FLASHCUR Flash the cursor.

       2.6 Directory device drivers.

           2.6.1 Microdrive device driver.

                 REPEATIO Do microdrive I/O operation until complete.
                 MDV_IO   General microdrive file I/O.

           2.6.2 File system TRAP handlers.

                 FS_CHECK Check pending operations.
                 FS_FLUSH Flush all buffers.
                 FS_POSAB Position absolute pointer.
                 FS_POSRE Position relative pointer.
                 FS_MDINF Get medium information.
                 FS_LOAD  Load a file.
                 FS_SAVE  Save a file.
                 FS_HEADS Set file header.
                 FS_HEADR Read file header.
                 MD_OPEN  Open a microdrive channel.
                 MD_CLOSE Close a microdrive channel.
                 FILE_ABS Position file pointer using absolute offset.
                 FILE_REL Position file pointer using relative offset.

       2.7 Real time clock.

                 MT_CLOCK Do clock funstion.

       2.8 Screen TRAP handlers.

                 WIN_CMND Check for window trap #3 commands.

           2.8.1 Character information.

                 SD_CHAR  Print a character.
                 SD_PXENQ Get window pixel data.
                 SD_CHENQ Get window character data.

           2.8.2 Window definition.

                 SD_WDEF  Redefine window.
                 SD_BORDR Set border width and colour.
                 SD_BORDE Set border width only.
                 SD_REDEF Redefine window with new size.
                 CHK_BORD Form overall window size from parameters.
                 CHK_SIZE Form new window size inside border.

           2.8.3 Cursor functions.

                 SD_CURE  Enable cursor.
                 SD_CURS  Disable cursor.
                 PRNT_CUR Print the cursor if enabled.
                 DISP_CUR Reprint the cursor.
                 CHK_CURS Check cursor co-ordinates.
                 SD_DONL  Do pending newline
                 SD_NEWL  Do forced newline.
                 SD_HOME  Reset cursor position to 0,0.
                 SD_POS   Set cursor position.
                 SD_TAB   Set horizontal position.
                 SD_NL    Do newline.
                 SD_PCOL  Set to previous column.
                 SD_NCOL  Set to next column.
                 SD_PROW  Set to previous row.
                 SD_NROW  Set to next row.
                 SD_PIXP  Set pixel position.

           2.8.4 Colouring.

                 SD_RECOL Recolour a window.
                 SD_CLEAR Clear whole window
                 SD_CLR   Clear a window
                 SD_SCRLL Scroll a window
                 SD_PANW  Pan a window.
                 SD_FILL  Fill a block.
                 SD_FOUNT Set character fonts.
                 SD_SETCL Set colours.
                 SD_SETFL Set flash mode.
                 SD_SETMD Set write mode
                 SD_SETUL Set underline mode.
                 SD_SETSZ Set character size.

           2.8.5 Graphics.

                 SD_GCUR  Set cursor at graphic pos.
                 SD_SCALE Set graphics scale/origin.
                 SD_FLOOD Set fill mode/user vectors.
                 SD_POINT Plot point.
                 SD_LINE  Draw line.
                 SD_ARC   Plot arc.
                 SD_ELIPS Draw circle/ellipse.
                 DO_TABLE Do table of maths offsets.

           2.8.6 Screen manipulation utilities.

                 UT_SCRLL Scroll a window.
                 UT_PAN   Pan a window.
                 COLRMASK Redo colour masks.
                 PRINT_CH Print a character.

       2.9 Microdrive slaving routines.

                 MD_SLAVE Microdrive forced slaving.
                 CLR_SBLK Clear the slave blocks used by a drive.
                 BAD_MEDI Check if medium bad or unformatted.
                 GAPINT   Gap interrupt handler.
                 MD_DESEL Switch all microdrive motors off.
                 MD_SELCT Switch a microdrive motor on.

       2.10 IPC routines.

                 IPC_CMND Do IPC Command.
                 ACK_INTR Acknowledge peripheral interrupt or command.
                 INTRFINT Interface interrupt handler.
                 TRNSMINT Transmit interrupt handler.
                 POLLTASK Start of polled tasks linked list.
                 SECTASK  Second task in scheduler linked list.
                 CHK_IPC  Check IPC input status.
                 SER_TXRX Do transmit interrupt action for serial ports.
                 CHK_KEY  Scan the keyboard and decode key press.
                 CTRL_F5  Switch screen status.
                 CTRL_C   Change current keyboard queue.
                 IPC_SET  Set up IPC command.
                 IPC_SEND Send command to IPC.
                 IPC_RETN Get IPC return parameter nibble.
                 IPC_RETB Get IPC return parameter byte.

       2.11 General memory management utilities.

                 MM_ALCHP Allocate common heap.
                 MM_ALTPA Expand transient program area.
                 MM_RECHP Release comman heap space.
                 MM_RETPA Relase transient program area.
                 MM_FREE  Find amount of free space.
                 MM_ALLOC Allocate heap space.
                 MM_SRCH  Search through a free space linked list.
                 MM_LNKFR Link free space into heap.
                 MM_ALBAS Allocate basic area.
                 MM_REBAS Release basic area.

       2.12 I/O sub-system TRAP #2 handler.

                 CHKTRP2  Handle trap #2 functions.
                 IO_OPEN  Open a channel.
                 IO_CLOSE Close a channel.

       2.13 I/O sub-system TRAP #3 handler.

                 CHKTRP3  Handle trap #3 functions.
                 CHKTRP4  Convert to absolute values.
                 CHKCHID  Check channel id.
                 DOWAITIO Do waiting I/O.
                 IO_DELET Delete a file.
                 IO_OPEN2 Check open type.
                 IO_FORMT Format a medium.
                 CHK_DD   Check directory device drivers linked list.
                 IO_NAME  Decode device name.

       2.14 Queue handling.

                 IO_SERQ  Direct queue handling.
                 IO_QSET  Set up a queue header.
                 IO_QTEST Test queue status.
                 IO_QIN   Put byte into queue.
                 IO_QOUT  Get byte from queue.
                 IO_QEOF  Put EOF marker in queue.
                 IO_SERIO General I/O handling.
                 IO_FLINE Fetch a line.
                 IO_SSTRG Send a string of bytes.
                 IO_LOAD  Load a file.
                 IO_FSTRG Fetch a string of bytes.
                 IO_PEND  Test pending input.
                 IO_FBYTE Fetch a byte.
                 IO_SBYTE Send a byte.
                 IO_HEADS Set file header.
                 IO_HEADR Read file header.

       2.15 System utilities.

                 UT_ERR0  Send error message to channel 0.
                 UT_ERR   Send error message to channel.
                 UT_MINT  Print decimal number on channel.
                 UT_MTEXT Send message to channel.
                 UT_LINK  Link item into list.
                 UT_UNLNK Unlink item from list.
                 UT_WINDW Create window channel.
                 UT_CON   Create console channel.
                 UT_SCR   Create screen channel.
                 UT_CSTR  String comparison.

       2.16 Conversion routines.

                 CN_DTOF  Convert ascii to floating point.
                 CN_DTOI  Convert ascii to integer.
                 CN_HTOIB Convert ascii to hex byte.
                 CN_HTOIW Convert ascii to hex word.
                 CN_HTOIL Convert ascii to hex long.
                 CN_BTOIB Convert ascii to binary byte.
                 CN_BTOIW Convert ascii to binary word.
                 CN_BTOIL Convert ascii to binary long.
                 CN_ITOD  Convert integer to ascii.
                 CN_ITOHL Convert hex long to ascii.
                 CN_ITOHW Convert hex word to ascii.
                 CN_ITOHB Convert hex byte to ascii.
                 CN_ITOBL Convert binary long to ascii.
                 CN_ITOBW Convert binary word to ascii.
                 CN_ITOBB Convert binary byte to ascii.
                 CN_FTOD  Convert floating point to ascii.
                 CN_DATE  Get date string.
                 CN_DAY   Get day string.

       2.17 The floating point maths package.

                 RI_SINGL Do single maths operation preserving A6.
                 RI_LIST  Do list of maths operations preserving A6.
                 RI_EXEC  Do a maths operation.
                 RI_EXECB Do a list of maths operations.
                 RI_SIN   Sin of TOS.
                 RI_COS   Cosine of TOS.
                 RI_TAN   Tangent of TOS.
                 RI_COT   Cotangent of TOS.
                 RI_ACOS  Arccosine of TOS.
                 RI_ASIN  Arcsine of TOS.
                 RI_ACOT  Arccotangent of TOS.
                 RI_ATAN  Arctangent of TOS.
                 RI_POWFP TOS raised to power of NOS.
                 RI_LOG10 Common logarithm of TOS.
                 RI_LN    Natural logarithm of TOS.
                 RI_EXP   Exponential of TOS.
                 RI_SQRT  Square root of TOS.
                 RI_TRUNC Truncate floating point form into long word integer.
                 RI_NORND As above with no rounding prior to truncation.
                 RI_NINT  Integer flaoting point form into word integer.
                 RI_INT   Truncate floating point form into word integer.
                 RI_NLINT Integer floating point form into long integer.
                 RI_LINT  Convert integer word into floating point form.
                 RI_SUB   Subtract TOS from NOS.
                 RI_ADD   Add TOS to NOS.
                 RI_MULT  Multiply NOS by TOS.
                 RI_DIV   Divide NOS by TOS.
                 RI_ABS   Take absolute value of TOS.
                 RI_NEG   Negate TOS.
                 RI_DUP   Duplicate TOS.

       2.18 Peripheral and SuperBASIC initialisation.

                 CHKPROMS  Check for peripheral ROMs.

       2.19 SuperBASIC stack management.

                 CA_ALRIP Reserve space on maths stack 2.
                 BV_CHRIX Reserve space on maths stack.
                 BV_ALBTP Allocate space on backtrack stack.
                 BV_ALTGP Allocate space on temporary graph stack.
                 CA_ALNTP Allocate space in name table.
                 CA_ALRTP Allocate space in return stack.
                 CA_ALBFP Allocate space in buffer.
                 CA_ALTKP Allocate space in token table.
                 CA_ALNLP Allocate space in name list.
                 CA_ALVVP Allocate space in variable values.
                 CA_ALCHB Reserve space in SuperBASIC channel table.
                 CA_ALLNP Allocate space in line number table.
                 CA_ALPFP Allocate space in program file.
                 CA_ALSBT Allocate space in SuperBASIC table.
                 CA_ALSBS Allocate SuperBASIC stack.
                 CA_GTSTR Get strings.
                 CA_GTINT Get integers.
                 CA_GTFP  Get floating points.
                 CA_GTLIN Get long integers.

       2.20 SuperBASIC procedures.

                 BP_BAUD  Set baud rate for serial channels.
                 BP_BEEP  Switch sound on or off.
                 BP_CALL  Call machine code routine.
                 GETCHID  Get SuperBASIC chanel information from id.
                 BP_CSIZE Set new character size.
                 BP_CURSO Position cursor with graphic co-ords.
                 BP_AT    Position cursor at character co-ords.
                 BP_ADATE Adjust system clock.
                 BP_SDATE Reset system clock.
                 BP_READ  Assign data to list of variables.
                 BP_EXEC  Load a machine code program and return.
                 BP_EXECW Load a machine code routine and wait.
                 BP_LBYTE Load data file into memory.
                 BP_SEXEC Save an executable program file.
                 BP_SBYTE Save an area of memory to a device.
                 BP_DLETE Remove a file from device directory.
                 BP_DIR   Display device directory.
                 BP_FORMT Format device medium.
                 BP_COPY  Copy file.
                 BP_COPYN Copy file minus header.
                 BP_CLOSE Close a channel.
                 BP_OPEN  Link channel with physical device.
                 BP_OPENI Open existing microdrive file for I/P.
                 BP_OPENN Open new microdrive file for O/P.
                 BP_SAVE  Save SuperBASIC program on device.
                 BP_FILL  Turn graphics fill on or off.
                 BP_UNDER Turn underline state on or off.
                 BP_FLASH Turn flash state on or off.
                 BP_OVER  Select over printing type.
                 BP_SCALE Alter graphics scale factor and origin.
                 BP_POINT Draw point relative tp graphics origin.
                 BP_RPOIN Draw point relative to graphics cursor.
                 BP_LINE  Draw kine relative to graphics origin.
                 BP_LINER Draw line relative to graphics cursor.
                 BP_ELLIP Draw ellipse relative to graphics origin.
                 BP_ELPSR Draw ellipse relative to graphics cursor.
                 BP_ARC   Draw arc relative to graphics origin.
                 BP_ARC_R Draw arc relative to graphics cursor.
                 BP_INIT  Add SuperBASIC procedures.

       2.21 Procedures and functions list.

                 BP_LET   Return parameter values.

       2.22 SuperBASIC procedures continued.

                 BP_DLINE Remove SuperBASIC program lines.
                 BP_LIST  List part of program on channel.
                 SB_CCBTA Convert pre-compiled basic to ascii.
                 BP_MODE  Set resolution of screen.
                 BP_NET   Set network station number.
                 BP_INK   Set current ink colour.
                 BP_STRIP Set current strip colour.
                 BP_PAPER Set current paper colour.
                 BP_CLS   Clear part or all of window.
                 BP_PAN   Pan part or all of screen.
                 BP_SCROL Scroll part or all of screen.
                 BP_PAUSE Delay executing a SuperBASIC program.
                 BP_POKE  Place byte in memory.
                 BP_POKEW Place word in memory.
                 BP_POKEL Place long word in memory.
                 BP_INPUT Read character(s) from a channel. 
                 BP_PRINT Print character(s) to a channel.
                 BP_RNDMZ Reseed random number generator.
                 BP_RECOL Recolour individual pixels in window.
                 BP_EDIT  Edit list of SuperBASIC lines.
                 BP_AUTO  Generate line numbers automatically.
                 BP_RENUM Renumber SuperBASIC program lines.
                 BP_CLEAR Clear SuperBASIC variables.
                 BP_RUN   Start program execution.
                 BP_MERGE Load and merge a SuperBASIC program.
                 BP_MRUN  Load, merge and run a SuperBASIC program.
                 BP_LOAD  Load a SuperBASIC program.
                 BP_LRUN  Load and run a SuperBASIC program.
                 BP_NEW   Clear SuperBASIC program and variables.
                 BP_STOP  Terminate program execution.
                 BP_RETRY Re-execute SuperBASIC statement.
                 BP_CONTI Continue halted SuperBASIC program.
                 BP_TURNT Turn turtle to specified angle.
                 BP_TURN  Turn turtle by specified angle.
                 BP_PENUP Switch turtle graphics pen off
                 BP_PENDO Switch turtle graphics pen on.
                 BP_MOVE  Move turtle in current direction.
                 BP_WIDTH Set default width on device.
                 BP_WINDO Redefine channel's window.
                 BP_BLOCK Fill a block with colour.
                 BP_BORDE Add a border to a window.

       2.23 SuperBASIC functions.

                 BF_ACOS  Return arc cosine.
                 BF_ACOT  Return arc cotangent.
                 BF_ASIN  Return arc sine.
                 BF_ATAN  Return arc tangent.
                 BF_COS   Return cosine.
                 BF_COS   Return cotangent.
                 BF_EXP   Return exponential.
                 BF_LN    Return natural logarithm.
                 BF_LOG10 Return logarithm to base 10.
                 BF_SIN   Return sine.
                 BF_SQRT  Return square root.
                 BF_TAN   Return tangent.
                 BF_DEG   Return angle in degrees.
                 BF_RAD   Return angle in radians.
                 BF_ABS   Return absolute value of number.
                 BF_RND   Return random number within limits.
                 BF_PI    Return the value 3.141593.
                 BF_INT   Return integer part of number.
                 BF_PEEK  Return value of byte in memory.
                 BF_PEEKW Return signed value of word in memory.
                 BF_PEEKL Return signed value of long word in memory.
                 BF_RESPR Reserve resident procedure space.
                 BF_BEEPI Return sound status.
                 BF_EOF   Return file or data statement status.
                 BF_VER   Return SuperBASIC version number.
                 BF_INKEY Return character from channel.
                 BF_CHR   Return ascii character.
                 BF_FILL  Return filled string.
                 BF_LEN   Return length of string.
                 BF_CODE  Return ascii value of character.
                 BF_DIMN  Return maximum size of dimension.
                 BF_DATE  Return current date in seconds.
                 BF_KEYRW Return state of row of keyboard.
                 BF_DATES Return current date and time.
                 BF_DAY   Return current day of the week.

       2.24 Interpreter.

                 SB_SNTX  Basic syntax analyser.
                 SB_CMPER Error when compiling.
                 SB_FPCBL Format pre-compiled basic line.
                 SB_SPFBL Store pre-formatted basic line.
                 SB_GQLCI Get QDOS list channel id.
                 SB_ELNOT Expand line number token.
                 SB_ENMTE Expand name table entry.
                 SB_ENAMT Expand name token.
                 SB_ESTRT Expand string token.
                 SB_ETXTT Expand Text token.
                 SB_ESPCT Expand space token.
                 SB_ESEPT Expand seperator token.
                 SB_EOPST Expand operation symbol token.
                 SB_EKEYT Expand keyword token.
                 SB_EMONT Expand mono-operation symbol token.
                 SB_ESYMT Expand symbol token.

       2.25 Fonts.
       2.26 Low level device routines.

           2.26.1 Microdrive low level routines.

                 MD_FORMT Format a microdrive medium.
                 MD_WRITE Write a microdrive sector.
                 MD_SECTR Read a microdrive sector header.
                 MD_READ  Read a microdrive sector.
                 MD_VERIN Verify a microdrive sector.

           2.26.2 Keyboard low level routines.
           2.26.3 Network low level routines.

                 NT_RPCKT Receive a network packet.
                 NT_SPCKT Send a network packet.

    3. TRAP #1 calls.
    4. TRAP #2 calls.
    5. TRAP #3 calls.
    6. Channel definition blocks.

       Channel definition block for the serial device driver.
       Channel definition block for the pipe device driver.
       Channel definition block for the console/screen device driver.
       Channel definition block for the network device driver.
       Channel definition block for the microdrive device driver.

    7. Other data blocks.

       Physical definition block for the microdrive device driver.
       Queue header.
       File header.
       Microdrive sector header.
       Slave block table entry.
       User heap or free space block.
       SuperBASIC channel table block.
       Device driver linkage block.
       Job control block.

    8. QDOS system variables.
    9. SuperBASIC system variables.
    10. Error codes.
    11. Arithmetic package operation codes.
    12. SuperBASIC tokens.

       Token types.
       Keyword tokens.
       Symbol tokens.
       Operation symbol tokens.
       Mono-operation symbol tokens.
       Seperator tokens.
       SuperBASIC variable types.
       Name table entry.
       The variable values area entry for an array.
       The variable values area entry for a REPeat loop.
       The variable values area entry for a FOR loop.
       SuperBASIC return stack entry.
       Rom header.

    13. Peripheral I/O devices.
    14. IPC commands.
    15. Numerical list of labels.
    16. Alphabetical list of labels.
    17. ROM dump.

1. INTRODUCTION

      This book constitutes a partially commented listing of QDOS version 1.03
   and SuperBASIC version JM. It is available free from the Quanta library as I
   have seen other disassemblies both commented and un-commented and have been
   very dis-satisfied with all of them. It is not based on the origonal source
   code as I did not have access to this and many of the names are of my own
   devising as a result. The JS and MG ROM's are also largely similar so this
   document could also be applied to them with some care.

      It is not intended for the faint hearted as it is basically a commented
   dis-assembly listing of the contents of the QL ROM and as such it represents
   what I think the origonal source code would have looked like if I had been
   the lucky individual chosen to design QDOS and SuperBASIC.

1.1 Some notes on style and presentation.

   Unless the reader is or was a softare engineer in a company which lays down
   strict rules for documentation standards, they probably approach the topic
   of documentation as a necessary evil or a chore which is really only for
   "professionals" and such like.

   Some companies prefer to employ special people known as technical authors.
   They are employed to produce the bulk of the above mentioned documentation
   and they usually have all the standard typographical resources they need
   at their disposal to produce a QUALITY product. Other companies make the
   designers write the documentation. This usually results in a considerably
   lower quality product than that produced by the technical authors. There
   are several reasons for this.

   The first reason is that Software designers are talented people as far as
   programming is concerned but they probably have had no training whatsoever
   in writing and will have had no opportunity to acquire writing skills.

   The second reason is that not enough time is allocated to the documentation
   process itself because of ignorance on the part of managers or of team
   leaders.

   It can also vary greatly in both quality and quantity and in almost every
   case some important detail, which will make life easier later on, will have
   been ommitted. You can also be prettly sure that there are plenty of plain
   old fashioned mistakes in there somewhere!

   After several years of experience as a so called "professional", I take a
   somewhat strange and different view towards documentation.

   I have found that writing documentation for a software system tends to give
   free rein to the creative side of my personality. The same appears to have
   been the case of my colleages over the years except for those with little
   or no talent at writing.

   The point of all this potted diatribe is that I am trying to justify why this
   book is so large and looks the way it does and why it is possibly difficult
   to understand.

   Documenting 48K of code was no easy task and required a considerable amount
   of patience and a desire to see the finished result. If you wish to have a
   go at documenting the other versions of the ROM's then I wish you luck.

   As the intended audience for this dis-assembly is somebody who obviously
   understands the assembly language of the Motorola MC68000 in detail and who
   is intriged by and interested in how QDOS and SuperBASIC "do their stuff",
   the documentation pulls no punches and no description of the CPU instruction
   set will be given. It is also highly technical and is full of "Buzz" words
   and other computer jargon because that is the way documentation of this sort
   is normally written.

   The style adopted will therefore be similar to that produced for any normal
   software system for a software companies internal use. As a result it will
   be substantial and will be as detailed as I can possibly make it.
   
   Some readers may therefore find the style rather strange and difficult to
   follow and apologies are given to those individuals if so. The style used
   obviously reflects my personal and professional preferences as regards
   documentation.

1.2 Sources and references.

   The information which was available to me and on which this dis-assembly is
   based, was gleaned from a number of standard texts on the QL, in particular:-



                  "The Sinclair QDOS Companion" by Andrew Pennell.

                    "QL Advanced User Guide" by Adrian Dickens.

                 "QL Technical Manual" by Sinclair Research Limited.

                "QL SuperBASIC The Definitive Handbook" by Jan Jones.

                    "Advanced QL Machine Code" by Adam Denning.

                 "QL Assembly Language Programming" by Colin Opie.



   Other sources of information included snippets of conversation at SWINDON
   computer weekends and user group meetings as well as books about operating
   systems in general and multitasking operating systems in particular.

   The above books have however been the major source of information as regards
   the QL and its operating system.

   The first of these has been of invaluable help and many thanks are given to
   Andrew Pennell for bothering to write it. Without it, I would not have even
   considered tackling disassembling the ROM at all as it contains descriptions
   which he freely admits were gained by dis-assembling the ROM for himself!

   The first QL's were very bug ridden and this unfortunatly has given the QL an
   undeserved bad reputation in the eyes of computer snobs.

   The above bugs luckily were mainly in the Superbasic Interpreter and not in
   QDOS itself, which has remained largely unchanged throughout all the various
   versions of the ROMS. This book describes the first of the two "working"
   versions of QDOS and SuperBASIC in considerable detail and is intended to be
   roughly equivalent to the similar disassemblies available of the Sinclair
   Spectrum Basic ROM and the interface two shadow ROM.

   I have distilled the essences of all the above works and combined them in a
   large pot along with some special seasoning of my own to produce what I hope
   is a digestable comestible ( or even a midnight snack if like me you work
   programmer's hours, which is to say odd ones).

   You should find this book fairly easy to read despite its size and scope even
   though it is highly technical in bits. I have included a number of "asides"
   where I have thought that a design point needed clarifying or where some
   theory was required in order for the reader to understand what followed.


                                  Happy reading!


   C.A.M.

   Havant, Hampshire June 1988

1.3 Why I wrote this book.

      Like most people who are into computers and programming, I still posses a
   child like interest in how things work and so when I bought my QL, I decided
   to find out how the operating system worked. When you consider that the QL is
   still the only multitasking low cost home computer available at this time, it
   seemed to me to present a wonderful opportunity to find out how a real time,
   multitasking, operating system containing an advanced version of a structured
   Basic works.

      I therefore started out on what would later turn out to be a very long job
   indeed. A year passed with only the main parts of the ROM commented in a very
   sketchy form and it has taken another two years, at odd momemts, to complete
   it. I did not really appreciate at the time that it probably took very many
   people, working full time for a year or more, to write, code and test it, and
   that their's was undoubtedly the much greater labour of love.

   I also wished to produce a decent disassembly of the ROM having seen and read
   a large number of other disassemblies, particularly the origonal Library one.
   I was thoroughly dis-satisfied with all of them as they seemed to have been
   put together without much thought or skill, for the purposes of producing an
   assemblable or ROMable code version.

      As the disassembly has not been proof read by either the author of QDOS or
   the author of SuperBASIC, I have probably mis-interpreted many parts of the
   ROM and so humble and heart felt apologies are honestly given to both Tony
   Tebby, Jan Jones et al respectively if I have.

1.4 How to print out this disassembly.

      Although I have used the word "book" here it is of course supplied in the
   form of a set of disc or microdrive cartridge files. In producing it, I have
   had to take many decisions about the format of the main listing, and because
   of this I have decided to use the full range of typesetting facilities which
   are normally available on most dot matrix printers these days to improve the
   presentation and hopefully the perceived quality of the book.

   This set of files should therefore be printed out on a printer which supports
   a condensed printing mode allowing upto at least 132 characters per line or
   greater. The listing is interspersed throughout with formatting commands for
   the EPSON LX800 printer and users who possess some other model of printer
   should use an editor to change these globally to suit whatever printer they
   have. The commands used are those for producing formfeeds, turning on and off
   Bold or Emphasised text, turning on and off Double width printing and those
   for underlining. One over-riding requirement however is that your printer
   supports the IBM character set as the extended characters ( those with codes
   above 128 ) have been used throughout the dis-assembly for routine headers,
   memory maps and other graphics to improve the presentation. A SuperBASIC
   program, PRINT_IT, will be included in the library at some point, which will
   allow these characters to be translated to some other user defined character.

      The owner can expect to wait a considerable number of hours, even at draft
   quality speeds, for the print-outs to complete as the full set of listings
   cover around about 1000 pages of standard A4 paper.

   The four discs provided should contain the following files:-

    Qdostexts1      Qdostexts2      Qdostexts3      Qdostexts4

    intro           part9           part19          definitions
    part1           part13          part50          labels_alpha
    part3           part14          part51          labels_num
    part5           part15          part99          ramdump
    part6           part16

   The best results of all can be obtained by using a Laser printer and if you
   do, a pretty nifty printout results!

1.5 Variable names and other details.

      Most of the variable names used in the listings are denoted by one of two
   forms, a two character prefix followed by an underscore, "_", and the rest of
   the variable name meaning that the variable denotes an absolute value. Or it
   may be a two character prefix followed by a full stop, ".", and the rest of
   the variable name meaning that it is an offset from some base value.

      As QDOS and SuperBASIC are both written to a highly modular design, I have
   tried wherever possible to adopt a correspondingly consistant style of
   documentation similar in manner to that used in the "SUBSET" series currently
   running in the "Personal Computer World" magazine.

      There is a complete list of the channel definition block offsets, for the
   job control blocks and various other variables in the appendices including
   both a numerical and an alphabetical listing of the labels used and their
   values in hexadecimal.

   The data field has been excluded from the listing itself to allow longer and
   hopefully more meaningful comments in the comment field.

      Finally for the two letter prefix used in most of the label names, I have
   used the following conventions which include as a subset, the official ones:-

    BF = SuperBASIC function
    BP = SuperBASIC procedure
    BT = slave block table entry
    BV = SuperBASIC system variable
    CA = SuperBASIC parameter passing
    CH = channel definition block entry
    CN = general conversion routine
    FH = file header entry
    FL = FOR loop entry in VV area
    FS = File system
    IO = I/O handler
    JB = job control block entry
    MC = master chip controller
    MD = Microdrive function
    MM = memory management
    MT = manager TRAP
    NT = network device driver
    PC = peripheral chip
    PP = pipe device driver
    RA = array entry in VV area
    RI = floating point maths package
    RL = REPEAT loop entry in VV area
    RS = SuperBASIC return stack entry
    SC = general screen or console I/O
    SD = Screen device I/O driver
    SE = serial device driver
    SH = sector header entry
    SV = QDOS system variable
    UH = user heap or free space block entry
    UT = utility routine
    VT = SuperBASIC variable type
 
   Some three letter prefix's are also used as follows:-

    CON = console device driver
    DEV = general device driver
    ERR = error number
    IPC = Intelligent peripheral controller
    KEY = keyword token
    MDV = microdrive device driver
    MON = mono-operation symbol token
    NET = network device driver
    NTB = name table entry
    OPS = operation symbol token
    ROM = external or peripheral rom header
    SCR = screen device driver
    SEP = separator token
    SER = serial device driver
    SYM = symbol token

1.6 The hardware memory map.

      All personal computers consist of a processor, a few other bits and some
   memory. This block of memory is normally contiguous put is often broken into
   individual segments with each segment serving a particular purpose.

   A microprocessor must also have some means of accessing peripherals and the
   MC68000 has the property that it accesses peripherals as individual locations
   in the memory map. There are several of these peripherals (or ports as they
   are called) and they are accessed by addresses within the lower part of the
   memory map. The complete hardware memory map for the QL is shown below:-


   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿- 100000
   ³                ³
   ³ EXPANSION  I/O ³       256 kbytes
   ³                ³ 
   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´- C0000
   ³                ³
   ³ EXPANSION  RAM ³       512 kbytes
   ³                ³ 
   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´- 40000
   ³                ³
   ³   NORMAL RAM   ³       96 kbytes
   ³                ³
   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´- 28000
   ³                ³
   ³   SCREEN RAM   ³       32 kbytes
   ³                ³
   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´- 20000
   ³                ³
   ³ EXPANSION  I/O ³       16 kbytes
   ³                ³
   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´- 1C000
   ³                ³
   ³ PERIPHERAL I/O ³       16 kbytes
   ³                ³
   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´- 18000
   ³                ³
   ³ EXPANSION  I/O ³       32 kbytes
   ³                ³
   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´- 10000
   ³                ³
   ³  PLUG IN ROM   ³       16 kbytes
   ³                ³
   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´- 0C000
   ³                ³
   ³   SYSTEM ROM   ³       48 kbytes
   ³                ³
   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ- 00000

1.7 The QDOS software memory map.

                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿- SV.RAMT
                   ³                ³
                   ³    RESIDENT    ³
                   ³ PROCEDURE AREA ³
                   ³                ³ 
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´- SV.RESPR
                   ³                ³
                   ³    TRANSIENT   ³
         SV.TRNFR -³  PROGRAM AREA  ³
                   ³                ³ 
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´- SV.TRNSP
                   ³                ³
                   ³   SUPERBASIC   ³
                   ³      AREA      ³
                   ³                ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´- SV.BASIC
                   ³                ³
                   ³     SLAVE      ³
                   ³     BLOCKS     ³
                   ³                ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´- SV.FREE
                   ³                ³
                   ³     COMMON     ³
         SV.CHPFR -³      HEAP      ³
                   ³                ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´- SV.CHEAP (SV.CHTOP)
                   ³                ³
                   ³     CHANNEL    ³
         SV.CHPNT -³      TABLE     ³
                   ³                ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´- SV.CHBAS (SV.JBTOP)
                   ³                ³
                   ³       JOB      ³
         SV.JBPNT -³      TABLE     ³
                   ³                ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´- SV.JBBAS (SV.BTTOP)
                   ³                ³
                   ³   SLAVE BLOCK  ³
         SV.BTPNT -³      TABLE     ³
                   ³                ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´- SV.BTBAS {SV.STACT}
                   ³                ³
                   ³   SUPERVISOR   ³
              A7' -³      STACK     ³
                   ³                ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´- {SV.STACB}
                   ³                ³
                   ³  QDOS SYSTEM   ³
                   ³   VARIABLES    ³
                   ³                ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ- {SV_IDENT} (28000)

1.8 The SuperBASIC software memory map.

                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿_ BV.SSBAS
                   ³     USER       ³
           BV.SSP -³     STACK      ³ 
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´_ BV.RIBAS
                   ³   ARITHMETIC   ³ 
           BV.RIP -³     STACK      ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´_ BV.TGBAS
                   ³     GRAPH      ³
           BV.TGP -³     STACK      ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´_ BV.BTBAS
                   ³   BACKTRACK    ³
           BV.BTP -³     STACK      ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³     SPARE      ³
                   ³     SPACE      ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´ 
                   ³  LINE NUMBER   ³
           BV.LNP -³     TABLE      ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´- BV.LNBAS 
                   ³     RETURN     ³
           BV.RTP -³     STACK      ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´- BV.RTBAS
                   ³    CHANNEL     ³
           BV.CHP -³     TABLE      ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´- BV.CHBAS
                   ³    VARIABLE    ³
           BV.VVP -³     VALUES     ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´- BV.VVBAS
                   ³      NAME      ³
           BV.NLP -³      LIST      ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´- BV.NLBAS
                   ³     NAME       ³
           BV.NTP -³     TABLE      ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´- BV.NTBAS
                   ³    PROGRAM     ³
           BV.PFP -³      FILE      ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´- BV.PFBAS
                   ³     TOKEN      ³
           BV.TKP -³      LIST      ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´- BV.TKBAS
                   ³     BUFFER     ³
           BV.BFP -³                ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´- BV.BFBAS
                   ³     SYSTEM     ³
                   ³   VARIABLES    ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´- A6
                   ³      JOB       ³
                   ³     HEADER     ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ- SV.BASIC

1.9 The QL hardware.

      The QL hardware consists of an MC68000 CPU, an 8049 second processor,
   several ULA's (Uncommitted Logic Array) and two ROM's plus various other
   discrete components. The software splits up into two major components,
   QDOS and the SuperBASIC interpreter.

1.9.1 The structure of QDOS.

      QDOS is a multitasking operating system which is interrupt driven and
   poll controlled. This means that the operating system is perpetually
   working unlike non-multitasking operating systems.

   In a multitasking operating system, the CPU is always running some process
   or job. In a non-multitasking operating system, the CPU may be executing
   instructions from a loop a great deal of the time. This characteristic of
   multitasking operating system means that one cannot be certain which one
   of the many possible processes is "running" at any given instant except by
   closely monitoring the memory accesses etc which the CPU is making. It also
   makes de-bugging very much more difficult.

   Multitasking operating systems as a species are very complex pieces of
   software and tend to come in the form of a kernel or nucleus of routines
   which are available to a process or job or application to use when it needs
   to do something system specific. QDOS is no exception in this regard and
   approximately 30K is devoted, out of the actual 44K used of the 48K ROM, to
   the routines which make up QDOS.




DEFINITIONS 


*********************************************************
* Trap #1 definitions : memory management & job control *
*********************************************************

MT.INF   EQU $00           get system information
MT.CJOB  EQU $01           create job
MT.JINF  EQU $02           get job information
MT.RJOB  EQU $04           remove a job
MT.FRJOB EQU $05           force remove a job
MT.FREE  EQU $06           find omount of free space
MT.TRAPV EQU $07           set RAM exception table
MT.SUSJB EQU $08           suspend job
MT.RELJB EQU $09           release a suspended job
MT.ACTIV EQU $0A           activate a job
MT.PRIOR EQU $0B           change job priority
MT.ALLOC EQU $0C           allocate heap space
MT.LNKFR EQU $0D           release heap space
MT.ALRES EQU $0E           allocate resident procedure space
MT.RERES EQU $0F           release resident procedure area
MT.DMODE EQU $10           set or read display mode
MT.IPCOM EQU $11           send IPC command
MT.BAUD  EQU $12           set serial port baud rate
MT.RCLCK EQU $13           read clock
MT.SCLCK EQU $14           set clock
MT.ACLCK EQU $15           adjust clock
MT.ALBAS EQU $16           allocate SUPERBASIC area
MT.REBAS EQU $17           release SUPERBASIC area
MT.ALCHP EQU $18           allocate common heap space
MT.RECHP EQU $19           release common heap space
MT.LXINT EQU $1A           link in external interrupt handler
MT.RXINT EQU $1B           unlink external interrupt handler
MT.LPOLL EQU $1C           link in polled task
MT.RPOLL EQU $1D           unlink polled task
MT.LSCHD EQU $1E           link in scheduler task
MT.RSCDH EQU $1F           unlink scheduler task
MT.LIOD  EQU $20           link in I/O driver
MT.RIOD  EQU $21           unlink I/O driver
MT.LDD   EQU $22           link in directory driver
MT.RDD   EQU $23           unlink directory driver

****************************************
* Trap #2 definitions : I/O allocation *
****************************************

IO.OPEN  EQU $01           open a channel
IO.CLOSE EQU $02           close a channel
IO.FORMT EQU $03           format a medium
IO.DELET EQU $04           delete a file

***********************************************
* Trap #3 definitions : actual I/O & graphics *
***********************************************

IO.PEND  EQU $00           test pending input
IO.FBYTE EQU $01           fetch a byte
IO.FLINE EQU $02           fetch a line
IO.FSTRG EQU $03           fetch a string of bytes
IO.EDLIN EQU $04           edit a line
IO.SBYTE EQU $05           send a byte
IO.SSTRG EQU $07           send a string of bytes
SD.EXTOP EQU $09           external operation
SD.PXENQ EQU $0A           read window size/cursor position (pixel)
SD.CHENQ EQU $0B           read window size/cursor position (character)
SD.BORDR EQU $0C           set window border
SD.WDEF  EQU $0D           re-define window
SD.CURE  EQU $0E           enable cursor
SD.CURS  EQU $0F           disable cursor
SD.POS   EQU $10           set cursor position
SD.TAB   EQU $11           set horizontal position
SD.NL    EQU $12           do newline
SD.PCOL  EQU $13           set to previous column
SD.NCOL  EQU $14           set to next colomn
SD.PROW  EQU $15           set to previous row
SD.NROW  EQU $16           set to next row
SD.PIXP  EQU $17           set pixel position
SD.SCROL EQU $18           scroll entire window
SD.SCRTP EQU $19           scroll top of window
SD.SCRBT EQU $1A           scroll bottom of window
SD.PAN   EQU $1B           pan whole window
SD.PANLN EQU $1E           pan cursor line
SD.PANRT EQU $1F           pan righthand side of cursor line
SD.CLEAR EQU $20           clear whole window
SD.CLRTP EQU $21           clear top of window
SD.CLRBT EQU $22           clear bottom of window
SD.CLRLN EQU $23           clear cursor line
SD.CLRRT EQU $24           clear to right of cursor
SD.FOUNT EQU $25           set character fonts
SD.RECOL EQU $26           recolour a window
SD.SETPA EQU $27           set paper colour
SD.SETST EQU $28           set strip colour
SD.SETIN EQU $29           set ink colour
SD.SETFL EQU $2A           set flash mode
SD.SETUL EQU $2B           set underline mode
SD.SETMD EQU $2C           set write mode
SD.SETSZ EQU $2D           set character size
SD.FILL  EQU $2E           fill a block
SD.DONL  EQU $2F           do pending newline
SD.POINT EQU $30           plot point
SD.LINE  EQU $31           draw line
SD.ARC   EQU $32           plot arc
SD.ELIPS EQU $33           draw circle/ellipse
SD.SCALE EQU $34           set graphic scale and origin
SD.FLOOD EQU $35           set fill mode/user vectors
SD.GCUR  EQU $36           set text cursor with graphic co-ordinates
FS.CHECK EQU $40           check pending operations
FS.FLUSH EQU $41           flush all buffers
FS.POSAB EQU $42           position absolute file pointer
FS.POSRE EQU $43           position relative file pointer
FS.MDINF EQU $45           get information about medium
FS.HEADS EQU $46           set file header
FS.HEADR EQU $47           read file header
FS.LOAD  EQU $48           load a file
FS.SAVE  EQU $49           save a file

*********************************************************
* Channel definition block for the serial device driver *
*********************************************************

CH.LEN   EQU $00  long     length of this definition block
CH.DRIVR EQU $04  long     pointer to linkage block of device driver
CH.OWNER EQU $08  long     ID of owner job
CH.RFLAG EQU $0C  long     location to be set when space released
CH.TAG   EQU $10  word     channel tag
CH.STAT  EQU $12  byte     status:

*                          0   = ok
*                          -1  = A1 passed absolute
*                          $80 = A1 passed relative to A6
*                          -ve = waiting

CH.ACTN  EQU $13  byte     action required for waiting job (value of D0)
CH.JOBWT EQU $14  long     ID of job waiting for I/O
CH.END   EQU $18           end of standard definition block

SER.CHNO EQU $18  byte     port number: 1 or 2
SER.PAR  EQU $1A  byte     parity:

*                          0   = none
*                          1   = odd
*                          2   = even
*                          3   = mark
*                          4   = space

SER.TXHS EQU $1C  word     transmit handshake flag:

*                          -1  = ignore
*                          0   = handshake

SER.PROT EQU $1E  word     protocol flag:

*                          -1  = raw
*                          0   = CTRL Z
*                          1   = convert

SER.RXQ  EQU $20           receive queue header followed by queue
SER.TXQ  EQU $82           transmit queue header followed by queue
SER.END  EQU $E4           end of serial device definition block

*******************************************************
* Channel definition block for the pipe device driver *
*******************************************************

CH.LEN   EQU $00  long     length of this definition block
CH.DRIVR EQU $04  long     pointer to linkage block of device driver
CH.OWNER EQU $08  long     ID of owner job
CH.RFLAG EQU $0C  long     location to be set when space released
CH.TAG   EQU $10  word     channel tag
CH.STAT  EQU $12  byte     status:

*                          0   = ok
*                          -1  = A1 passed absolute
*                          $80 = A1 passed relative to A6
*                          -ve = waiting

CH.ACTN  EQU $13  byte     action required for waiting job (value of D0)
CH.JOBWT EQU $14  long     ID of job waiting for I/O
CH.END   EQU $18           end of standard definition block

CH.QIN   EQU $18  long     pointer to I/P queue (0 if O/P pipe)
CH.QOUT  EQU $1C  long     pointer to O/P queue (0 if I/P pipe)
CH.QEND  EQU $20           end of pipe device definition block or queue
*                          header followed by queue if O/P pipe

*****************************************************************
* Channel definition block for the console/screen device driver *
*****************************************************************

CH.LEN   EQU $00  long     length of this definition block
CH.DRIVR EQU $04  long     pointer to linkage block of device driver
CH.OWNER EQU $08  long     ID of owner job
CH.RFLAG EQU $0C  long     location to be set when space released
CH.TAG   EQU $10  word     channel tag
CH.STAT  EQU $12  byte     status:

*                          0   = ok
*                          -1  = A1 passed absolute
*                          $80 = A1 passed relative to A6
*                          -ve = waiting

CH.ACTN  EQU $13  byte     action required for waiting job (value of D0)
CH.JOBWT EQU $14  long     ID of job waiting for I/O
CH.END   EQU $18           end of standard definition block

SD.XMIN  EQU $18  word     top left hand position of window
SD.YMIN  EQU $1A  word
SD.XSIZE EQU $1C  word     window size
SD.YSIZE EQU $1E  word
SD.BORWD EQU $20  word     border width
SD.XPOS  EQU $22  word     current cursor position within window
SD.YPOS  EQU $24  word
SD.XINC  EQU $26  word     cursor & character size
SD.YINC  EQU $28  word
SD.FOUNT EQU $2A  2 long   address of character fonts
SD.SCRB  EQU $32  long     start of screen memory
SD.PMASK EQU $36  long     paper colour mask
SD.SMASK EQU $3A  long     strip colour mask
SD.IMASK EQU $3E  long     ink colour mask
SD.CATTR EQU $42  byte     character attributes:

*                          bit 0 = underline
*                          bit 1 = flash
*                          bit 2 = transparent background
*                          bit 3 = XOR printing
*                          bit 4 = double height
*                          bit 5 = extended width
*                          bit 6 = double width
*                          bit 7 = graphics positioned characters

SD.CURF  EQU $43  byte     cursor status: 0 = suppressed , +ve = visible
SD.PCOLR EQU $44  byte     paper colour byte
SD.SCOLR EQU $45  byte     strip colour byte
SD.ICOLR EQU $46  byte     ink colour byte
SD.BCOLR EQU $47  byte     border colour byte
SD.NLSTA EQU $48  byte     newline status: 0 = none pending , 1 = pending 
SD.FMOD  EQU $49  byte     fill mode: 0 = off , 1 = on
SD.YORG  EQU $4A  f.p.     graphics window origin
SD.XORG  EQU $50  f.p.
SD.SCAL  EQU $56  f.p.     scale factor for graphics
SD.FBUF  EQU $5C  long     location of fill buffer
SD.FUSE  EQU $60  long     pointer to user defined fill vectors (0 if none)
SD.KBD   EQU $64  long     start of keyboard queue header if console
*                          channel or 0 if screen channel
SD.END   EQU $68           end of screen device definition block

******************************************************
* Channel definition block for network device driver *
******************************************************

CH.LEN   EQU $00  long     length of this definition block
CH.DRIVR EQU $04  long     pointer to linkage block of device driver
CH.OWNER EQU $08  long     ID of owner job
CH.RFLAG EQU $0C  long     location to be set when space released
CH.TAG   EQU $10  word     channel tag
CH.STAT  EQU $12  byte     status:

*                          0   = ok
*                          -1  = A1 passed absolute
*                          $80 = A1 passed relative to A6
*                          -ve = waiting

CH.ACTN  EQU $13  byte     action required for waiting job (value of D0)
CH.JOBWT EQU $14  long     ID of job waiting for I/O
CH.END   EQU $18           end of standard definition block

NET.HEDR EQU $18  byte     destination station no
NET.SELF EQU $19  byte     this station no
NET.BLKL EQU $1A  byte     least significant byte of data block no
NET.BLKH EQU $1B  byte     most significant byte of data block no
NET.TYPE EQU $1C  byte     packet type:

*                          0   = data packet
*                          1   = EOF packet
*                          -ve = O/P
*                          +ve = I/P

NET.NBYT EQU $1D  byte     number of bytes in data block
NET.DCHK EQU $1E  byte     data checksum
NET.HCHK EQU $1F  byte     header checksum
NET.DATA EQU $20  255      data block
NET.RPNT EQU $11F byte     pointer to current position in data block
NET.END  EQU $120          end of network device definition block

*********************************************************
* Channel definition block for microdrive device driver *
*********************************************************

CH.LEN   EQU $00  long     length of this definition block
CH.DRIVR EQU $04  long     pointer to linkage block of device driver
CH.OWNER EQU $08  long     ID of owner job
CH.RFLAG EQU $0C  long     location to be set when space released
CH.TAG   EQU $10  word     channel tag
CH.STAT  EQU $12  byte     status:

*                          0   = ok
*                          -1  = A1 passed absolute
*                          $80 = A1 passed relative to A6
*                          -ve = waiting

CH.ACTN  EQU $13  byte     action required for waiting job (value of D0)
CH.JOBWT EQU $14  long     ID of job waiting for I/O
CH.END   EQU $18           end of standard definition block

FS.NEXT  EQU $18  long     link to next channel for this file system
FS.ACCES EQU $1C  byte     access mode defined when opened:

*                          0   = old exclusive device
*                          1   = old shared device
*                          3   = new overwrite file
*                          4   = open directory
*                          -ve = delete

FS.DRIVE EQU $1D  byte     drive ID (index to table of pointers to the
*                          physical definition blocks)
FS.FILNR EQU $1E  word     file number on drive
FS.NBLOK EQU $20  word     block number containing next byte
FS.NBYTE EQU $22  word     next byte number from block
FS.EBLOK EQU $24  word     block number containing byte after EOF
FS.EBYTE EQU $26  word     byte number after EOF
FS.CBLOK EQU $28  long     pointer to slave block table for current slave
*                          block which may hold current/next byte
FS.UPDT  EQU $2C  byte     set when file is updated
FS.FNAME EQU $32  38 bytes length of name followed by filename
FS.SPARE EQU $58  72 bytes spare workspace used by OS
FS.END   EQU $A0           end of microdrive device definition block

**********************************************************
* Physical definition block for microdrive device driver *
**********************************************************

CH.LEN   EQU $00  long     length of this definition block
CH.DRIVR EQU $04  long     pointer to linkage block of device driver
CH.OWNER EQU $08  long     ID of owner job
CH.RFLAG EQU $0C  long     location to be set when space released

FS.DRIVR EQU $10  long     pointer to access layer link for driver
FS.DRIVN EQU $14  byte     drive no
FS.MNAME EQU $16  12 bytes length followed by medium name
FS.FILES EQU $22  byte     number of files open
FS.BADM  EQU $23  byte     unofficial: 0 = medium ok , -1 = medium bad 
MD.FAIL  EQU $24  byte     failure count:

*                          4   = write/verify operations
*                          8   = read

MD.MAP   EQU $28  510      microdrive map in pairs for each sector:

*                          even byte:        -1 = bad
*                                            -2 = unused
*                                            -3 = deletion pending

*                          odd byte:         block no

MD.LSECT EQU $226 word     last sector allocated
MD.PENDG EQU $228 512      map of pending operations, one word/sector
MD.END   EQU $428          end of physical definition block

****************
* Queue header *
****************

Q.NEXTQ  EQU $00  long     link to next queue (bit 31 used to mark EOF)
Q.END    EQU $04  long     pointer to physical end of queue
Q.NEXTIN EQU $08  long     pointer to location to insert next character
Q.NXTOUT EQU $0C  long     pointer to location to remove next character
Q.QUEUE  EQU $10           physical start of queue

***************
* File header *
***************

* Non-directory device file header.

FH.LEN   EQU $00  long     file length
FH.ACCES EQU $04  byte     file access key (0 in QDOS 1.03)
FH.TYPE  EQU $05  byte     file type:

*                          0   = basic program or ordinary data file
*                          1   = executable program

FH.DATA  EQU $06  long     default data space for executable files

* Extended definition for directory device drivers.

FH.NAME  EQU $0E  38 bytes length followed by file name
FH.UPDT  EQU $34  long     date of last update
FH.CREA  EQU $38  long     date of creation
FH.BACK  EQU $3A  long     date of last backup

****************************
* Microdrive Sector Header *
****************************

SH.INV   EQU $00  byte     invisible $FF byte
SH.SECT  EQU $01  word     sector number
SH.NAME  EQU $03  10 bytes file name (no length)
SH.RAND  EQU $0D  word     random number as set when medium formatted

***************************
* Slave block table entry *
***************************

BT.STAT  EQU $00  byte     status byte:

*                          0   = unavailable to OS
*                          1   = empty block
*                          $X3 = block is true representation of file
*                          $X7 = block is updated (awaiting write)
*                          $X9 = block is awaiting read
*                          $XB = block is awaiting verify

*                          X is drive ID for this file

BT.PRIOR EQU $01  byte     available for fancy slaving algorithm
BT.SECTR EQU $02  word     physical sector on medium
BT.FILNR EQU $04  word     file no
BT.BLOCK EQU $06  word     block number of contents of this slave block

*********************************
* User heap or free space block *
*********************************

UH.LEN   EQU $00  long     length of this block
UH.NEXT  EQU $04  long     relative pointer to next block or 0 if end of
*                          linked list

**********************************
* SUPERBASIC channel table block *
**********************************

CH.ID    EQU $00  long     QDOS channel ID (-1 if closed)
CH.CCPY  EQU $04  f.p.     current graphics y co-ordinate
CH.CCPX  EQU $0A  f.p.     current graphics x co-ordinate
CH.ANGLE EQU $10  f.p.     turtle angle
CH.PEN   EQU $16  byte     pen position: 0 = up , 1 = down
CH.CHPOS EQU $20  word     cursor position across line on printer
CH.WIDTH EQU $22  word     number of characters per line on printer
CH.SPARE EQU $24  long     currently unused
CH.LENCH EQU $28           end of channel block

*******************************
* Device driver linkage block *
*******************************

* Definition for simple device drivers.

DEV.LINK EQU $00  long     link to next entry
DEV.IO   EQU $04  long     I/O routine address
DEV.OPEN EQU $08  long     open routine address
DEV.CLOS EQU $0C  long     close routine address

* Extended definition for directory device drivers.

DEV.SLAV EQU $10  long     forced slaving routine address
DEV.RENA EQU $14  long     rename routine address
DEV.TRUN EQU $18  long     truncate routine address
DEV.FORM EQU $1C  long     format routine address
DEV.PDLE EQU $20  long     length of physical definition block
DEV.NAME EQU $24  long     name length followed by device name 

*********************
* Job control block *
*********************

JB.LEN   EQU $00  long     total length of job control block + job area
JB.START EQU $04  long     start address of actual job on activation
JB.OWNER EQU $08  long     job ID of this job's owner (0 if independent)
JB.HOLD  EQU $0C  long     location to be cleared when job released
*                          (from suspension if SUPERBASIC)
JB.TAG   EQU $10  word     tag for job as allocated by MT.CJOB
JB.PRIOR EQU $12  byte     current accumulated priority. This increments
*                          when a job is active but not executing.
*                          It is set to zero when the job is executing.
*                          The scheduler allows the job with the highest
*                          accumulated priority to execute.
JB.PRINC EQU $13  byte     initial priority of job (0 if inactive)
JB.STAT  EQU $14  word     job status:

*                          0   = not suspended & is possibly active
*                          +ve = number of scheduler frames before release
*                                from suspension 
*                          -1  = suspended
*                          -2  = waiting for another job to finish

JB.RELA6 EQU $16  byte     set if next TRAP has relative addressing
JB.WFLAG EQU $17  byte     set if a job is waiting for this one to finish
JB.WJOB  EQU $18  long     ID of above job waiting for this one
JB.TRAPV EQU $1C  long     pointer to RAM exception vector table
JB.D0    EQU $20  long     saved value of D0
JB.D1    EQU $24  long     saved value of D1
JB.D2    EQU $28  long     saved value of D2
JB.D3    EQU $2C  long     saved value of D3
JB.D4    EQU $30  long     saved value of D4
JB.D5    EQU $34  long     saved value of D5
JB.D6    EQU $38  long     saved value of D6
JB.D7    EQU $3C  long     saved value of D7
JB.A0    EQU $40  long     saved value of A0
JB.A1    EQU $44  long     saved value of A1
JB.A2    EQU $48  long     saved value of A2
JB.A3    EQU $4C  long     saved value of A3
JB.A4    EQU $50  long     saved value of A4
JB.A5    EQU $54  long     saved value of A5
JB.A6    EQU $58  long     saved value of A6
JB.A7    EQU $5C  long     saved value of A7 (USP)
JB.SR    EQU $60  word     saved value of status register
JB.PC    EQU $62  long     saved value of program counter
JB.END   EQU $68           end of job control block

JB.BRNCH EQU $68  6        branch instruction for code start
JB.IDENT EQU $6E  word     $4AFB identification word
JB.NAME  EQU $70           length of name followed by job name

*************************
* QDOS system variables *
*************************

SV_BASE  EQU $28000        base of system variables

SV.IDENT EQU $00  long     identification word $D254
SV.CHEAP EQU $04  long     start of common heap area
SV.CHPFR EQU $08  long     relative pointer to first free space in common
*                          heap area
SV.FREE  EQU $0C  long     start of free area (slave blocks)
SV.BASIC EQU $10  long     start of SUPERBASIC job header
SV.TRNSP EQU $14  long     start of transient program area (TRNSP)
SV.TRNFR EQU $18  long     relative pointer to first free space in TRNSP
SV.RESPR EQU $1C  long     start of resident procedure area (RESPR)
SV.RAMT  EQU $20  long     end of RAM + 1
SV.RAND  EQU $2E  word     pseudo random number
SV.POLLM EQU $30  word     number of poll interrupts missed
SV.TVMOD EQU $32  byte     display mode: 0 = monitor , 1 = TV
SV.SCRST EQU $33  byte     screen status: 0 = active , -1 = inactive
*                          toggled by pressing CTRL F5
SV.MCSTA EQU $34  byte     copy of master chip status register:

*                          bit 1 : 0 = display on , 1 = display off
*                          bit 3 : 0 = mode 4 , 1 = mode 8
*                          bit 7 : 0 = screen #0 , 1 = screen #1

SV.PCINT EQU $35  byte     copy of interrupt register:

*                          bit 0 = gap interrupt
*                          bit 1 = interface interrupt
*                          bit 2 = transmit interrupt
*                          bit 3 = frame interrupt
*                          bit 4 = external interrupt

SV.NETNR EQU $37  byte     self network station number
SV.I2LST EQU $38  long     start of external interrupt linked list
SV.PLIST EQU $3C  long     start of polled tasks linked list
SV.SHLST EQU $40  long     start of scheduler tasks linked list
SV.DRLST EQU $44  long     start of simple device driver's linked list
SV.DDLST EQU $48  long     start of directory device driver's linked list
SV.KEYQ  EQU $4C  long     pointer to current keyboard queue (0 if none)
SV.TRAPV EQU $50  long     current RAM exception vector table

* Pointers to resource management tables.

SV.BTPNT EQU $54  long     current entry in slave block table
SV.BTBAS EQU $58  long     start of slave block table
SV.BTTOP EQU $5C  long     end of slave block table + 1
SV.JBTAG EQU $60  word     current value of job tag
SV.JBMAX EQU $62  word     maximum job number to date
SV.JBPNT EQU $64  long     current entry in job table
SV.JBBAS EQU $68  long     start of job table
SV.JBTOP EQU $6C  long     end of job table + 1
SV.CHTAG EQU $70  word     current value of channel tag
SV.CHMAX EQU $72  word     maximum channel number to date
SV.CHPNT EQU $74  long     current entry in channel table (last entry used
*                          by the "do waiting I/O" scheduler routine)
SV.CHBAS EQU $78  long     start of channel table
SV.CHTOP EQU $7C  long     end of channel table + 1
SV.CAPS  EQU $88  byte     capslock status: 0 = off , -1 = on
SV.ARBUF EQU $8A  word     auto key repeat buffer (last key pressed)
SV.ARDEL EQU $8C  word     auto key repeat delay  (normally 30)
SV.ARFRQ EQU $8E  word     auto key repeat 1/frequency (normally 4)
SV.ARCNT EQU $90  word     auto key repeat counter
SV.CQCH  EQU $92  word     change keyboard queue code (normally CTRL C)
SV.WP    EQU $94  byte     write protect status: 0 = no : -1 = yes
SV.SOUND EQU $96  byte     sound status: 0 = off , -1 = on
SV.SER1C EQU $98  long     start of serial port 1 input queue
SV.SER2C EQU $9C  long     start of serial port 2 input queue
SV.TMODE EQU $A0  byte     transmit control register ULA mode:

*                          bit 0 to 2 : baud rate no
*                          bit 3 : 0 = port 1 , 1 = port 2
*                          bit 4 = microdrive turning

SV.CSUB  EQU $A2  long     address of capslock subroutine (0 if none)
SV.TIMO  EQU $A6  word     serial output timeout counter (switching mode)
SV.TIMOV EQU $A8  word     timeout for above counter (1200/baud rate + 1)
SV.FSTAT EQU $AA  word     cursor flash counter
SV.MDRUN EQU $EE  byte     currently turning microdrive number (0 if none)
SV.MDCNT EQU $EF  byte     microdrive run-up/run-down counter
SV.MDDID EQU $F0  8 byte   drive ID for each drive ( = drive number * 4)
SV.MDSTA EQU $F8  8 byte   pending operation status for each drives:

*                          0   = no pending operations
*                          -1  = pending operations

SV.FSDEF EQU $100 16 long  pointer to physical definition block for each of
*                          the above drives
SV.FSLST EQU $140 16 long  pointer to the linked list of file channel
*                          definitions for each drive
SV.STACB EQU $180 192 long lowest position for SSP
SV.STACT EQU $480          highest position for SSP

*******************************
* SUPERBASIC system variables *
*******************************

BV.START EQU $00           start of pointers

BV.BFBAS EQU $00  long     buffer base
BV.BFP   EQU $04  long     buffer running pointer
BV.TKBAS EQU $08  long     token list base
BV.TKP   EQU $0C  long     token list running pointer
BV.PFBAS EQU $10  long     program file base
BV.PFP   EQU $14  long     program file running pointer
BV.NTBAS EQU $18  long     name table base
BV.NTP   EQU $1C  long     name table running pointer
BV.NLBAS EQU $20  long     name list base
BV.NLP   EQU $24  long     name list running pointer
BV.VVBAS EQU $28  long     variable value area base
BV.VVP   EQU $2C  long     variable values  running pointer
BV.CHBAS EQU $30  long     start of SUPERBASIC channel table 
BV.CHP   EQU $34  long     channel table running pointer
BV.RTBAS EQU $38  long     return stack base
BV.RTP   EQU $3C  long     return stack running pointer
BV.LNBAS EQU $40  long     line number table base
BV.LNP   EQU $44  long     line number table running pointer
BV.BTP   EQU $48  long     top of backtrack stack used during parsing

BV.CHANG EQU $48           change of direction marker

BV.BTBAS EQU $4C  long     back track stack base
BV.TGP   EQU $50  long     top of temporary graph stack used during parsing
BV.TGBAS EQU $54  long     temporary graph stack base
BV.RIP   EQU $58  long     top of maths stack ( running pointer )
BV.RIBAS EQU $5C  long     base of maths stack
BV.SSP   EQU $60  long     top of system stack ( running pointer )
BV.SSBAS EQU $64  long     system stack base

BV.ENDPT EQU $64           end of pointers

BV.LINUM EQU $68  word     current line number
BV.LNGTH EQU $6A  word     current length
BV.STMNT EQU $6C  byte     current statement on line
BV.CONT  EQU $6D  byte     process status: 0 = stop , $80 = continue
BV.INLIN EQU $6E  byte     clause status: 0 = no , 1 = loop , -1 = other
BV.SING  EQU $6F  byte     single line (immediate) mode: 0 = off , -1 = on
BV.INDEX EQU $70  word     name table row of last inline loop index read
BV.VVFRE EQU $72  long     first free space in variable value table
BV.SSSAV EQU $76  long     SP value to go to if out of memory error occurs
BV.RAND  EQU $80  long     random number
BV.COMCH EQU $84  long     command (input) channel ID
BV.NXLIN EQU $88  word     which line number to start after
BV.NXSTM EQU $8A  byte     which statement to start after
BV.COMLN EQU $8B  byte     command line status: 0 = not saved , -1 = saved
BV.STOPN EQU $8C  word     which STOP number set
BV.EDIT  EQU $8E  byte     edit marker: 0 = not edited , -1 = edited
BV.BRK   EQU $8F  byte     break status: 0 = yes , $80 = no
BV.UNRVL EQU $90  byte     unravel status: 0 = no need , -1 = yes need to
BV.CNSTM EQU $91  byte     statement to CONTINUE after
BV.CNLNO EQU $92  word     line number to CONTINUE after
BV.DALNO EQU $94  word     current DATA line number
BV.DASTM EQU $96  byte     current DATA statement number
BV.DAITM EQU $97  byte     next DATA item to read
BV.CNIND EQU $98  word     inline loop index to CONTINUE with
BV.CNINL EQU $9A  byte     inline loop flag for CONTINUE
BV.LSANY EQU $9B  byte     checking list staus: 0 = no , -1 = yes
BV.LSBEF EQU $9C  word     invisible top line number
BV.LSBAS EQU $9E  word     bottom line number in window
BV.LSAFT EQU $A0  word     invisible bottom line number
BV.LENLN EQU $A2  word     length of window line
BV.MAXLN EQU $A4  word     maximum number of lines in window
BV.TOTLN EQU $A6  word     number of window lines so far
BV.AUTO  EQU $AA  byte     EDIT/AUTO mode: 0 = off , -1 = on
BV.PRINT EQU $AB  byte     token status: 0 = leave in buffer , -1 = print
BV.EDLIN EQU $AC  word     next editable line number
BV.EDINC EQU $AE  word     AUTO line number increment
BV.TKPOS EQU $B0  long     location of A4 in token list when starting PROC
BV.PTEMP EQU $B4  long     temporary pointer for GO_PROC
BV.UNDO  EQU $B8  byte     undo return stack then redo procedure or not
BV.ARROW EQU $B9  byte     arrow status: 0 = enter or none , 1 = up , -1 = down
BV.LSFIL EQU $BA  word     line number to fill window to when relisting
BV.END   EQU $100          end of SUPERBASIC system variables

***************
* Error codes *
***************

ERR.NC   EQU -1            not complete
ERR.NJ   EQU -2            invalid job
ERR.OM   EQU -3            out of memory
ERR.OR   EQU -4            out of range
ERR.BO   EQU -5            buffer full
ERR.NO   EQU -6            channel not open
ERR.NF   EQU -7            not found
ERR.EX   EQU -8            already exists
ERR.IU   EQU -9            in use
ERR.EF   EQU -10           end of file
ERR.DF   EQU -11           drive full
ERR.BN   EQU -12           bad name
ERR.TE   EQU -13           Xmit error
ERR.FF   EQU -14           format failed
ERR.BP   EQU -15           bad parameter
ERR.FE   EQU -16           bad or changed medium
ERR.XP   EQU -17           error in expression
ERR.OV   EQU -18           overflow
ERR.NI   EQU -19           not implemented (yet)
ERR.RO   EQU -20           read only
ERR.BL   EQU -21           bad line

**************************************
* Arithmetic package operation codes *
**************************************

RI.TERM  EQU $00           terminate execution
RI.LOAD  EQU $00           load operand key if even   (bit 0 clear)
RI.STORE EQU $01           load operand key if odd    (bit 0 set)
RI.NINT  EQU $02           find nearest word integer to TOS
RI.INT   EQU $04           truncate TOS to word integer
RI.NLINT EQU $06           find nearest long integer to TOS
RI.FLOAT EQU $08           convert TOS word integer to floating point
RI.ADD   EQU $0A           add TOS to NOS
RI.SUB   EQU $0C           subtract TOS from NOS
RI.MULT  EQU $0E           multiply TOS by NOS
RI.DIV   EQU $10           divide TOS into NOS
RI.ABS   EQU $12           take positive value of TOS
RI.NEG   EQU $14           negate TOS
RI.DUP   EQU $16           duplicate TOS
RI.COS   EQU $18           take cosine of TOS
RI.SIN   EQU $1A           take sine of TOS
RI.TAN   EQU $1C           take tangent of TOS
RI.COT   EQU $1E           take cotangent of TOS
RI.ASIN  EQU $20           take arcsine of TOS
RI.ACOS  EQU $22           take arccosine of TOS
RI.ATAN  EQU $24           take arctangent of TOS
RI.ACOT  EQU $26           take arccotangent of TOS
RI.SQRT  EQU $28           take square root of TOS
RI.LN    EQU $2A           take natural logarithm (base e) of TOS
RI.LOG10 EQU $2C           take common logarithm (base 10) of TOS
RI.EXP   EQU $2E           take exponential of TOS
RI.POWFP EQU $30           take NOS to the power of TOS

***************
* Token types *
***************

SPC.B    EQU $80           space (followed by number of spaces) {1 byte}
KEY.B    EQU $81           keyword
BIP.B    EQU $82           built in procedure
BIF.B    EQU $83           built in function
SYM.B    EQU $84           symbol
OPS.B    EQU $85           operation symbol
MON.B    EQU $86           mono-operation symbol
SYV.B    EQU $87           system variable
NAM.W    EQU $8800         name (followed by word offset into name table)
SHI.B    EQU $89           short integer
LGI.B    EQU $8A           long integer
STR.B    EQU $8B           string (followed by code of quote used)
TXT.W    EQU $8C00         text (followed by text length word)
LNO.W    EQU $8D00         line number (followed by line number word)
SEP.B    EQU $8E           seperator
FP.B     EQU $F0           floating point number (only top nibble relevant)

******************
* Keyword tokens *
******************

KEY.END  EQU $8101         End
KEY.FOR  EQU $8102         For
KEY.IF   EQU $8103         If
KEY.REP  EQU $8104         Repeat
KEY.SEL  EQU $8105         Select
KEY.WHEN EQU $8106         When
KEY.DEF  EQU $8107         Define
KEY.PROC EQU $8108         Procedure
KEY.FUNC EQU $8109         Function
KEY.GO   EQU $810A         Go
KEY.TO   EQU $810B         To
KEY.SUB  EQU $810C         Sub
KEY.ERR  EQU $810E         Error
KEY.EOF  EQU $810F         Eof      (not normally used)
KEY.INP  EQU $8110         Input    (not normally used)
KEY.REST EQU $8111         Restore
KEY.NEXT EQU $8112         Next
KEY.EXIT EQU $8113         exit
KEY.ELSE EQU $8114         Else
KEY.ON   EQU $8115         On
KEY.RET  EQU $8116         Return
KEY.RMND EQU $8117         Remainder
KEY.DATA EQU $8118         Data
KEY.DIM  EQU $8119         Dim
KEY.LOCL EQU $811A         Local
KEY.LET  EQU $811B         Let
KEY.THEN EQU $811C         Then
KEY.STEP EQU $811D         Step
KEY.RMRK EQU $811E         Remark
KEY.MIST EQU $811F         Mistake

*****************
* Symbol tokens *
*****************

SYM.EQ   EQU $8401         =
SYM.COL  EQU $8402         :        colon
SYM.HASH EQU $8403         #        channel
SYM.COM  EQU $8404         ,        comma
SYM.LBKT EQU $8405         (        left bracket
SYM.RBKT EQU $8406         )        right bracket
SYM.LCRL EQU $8407         {        left curly bracket
SYM.RCRL EQU $8408         }        right curly bracket
SYM.FSPC EQU $8409                  forced space
SYM.LF   EQU $840A                  line feed

***************************
* Operation symbol tokens *
***************************

OPS.ADD  EQU $8501         +        addition
OPS.SUB  EQU $8502         -        subtraction
OPS.MULT EQU $8503         *        multiplication
OPS.DIVD EQU $8504         /        division
OPS.GE   EQU $8505         >=       greater than or equal to   (type 2)
OPS.GT   EQU $8506         >        greater than               (type 2)
OPS.EQUV EQU $8507         ==       equivalent                 (type 3)
OPS.EQ   EQU $8508         =        equal to                   (type 2)
OPS.NEQ  EQU $8509         <>       not equal to               (type 3)
OPS.LE   EQU $850A         <=       less than or equal to      (type 2)
OPS.LT   EQU $850B         <        less than                  (type 2)
OPS.BOR  EQU $850C         ||       bitwise OR
OPS.BAND EQU $850D         &&       bitwise AND
OPS.BXOR EQU $850E         ^^       bitwise exclusive OR
OPS.POWR EQU $850F         ^        raise to the power
OPS.CONC EQU $8510         &        concatenation
OPS.OR   EQU $8511         OR       logical OR
OPS.AND  EQU $8512         AND      logical AND
OPS.XOR  EQU $8513         XOR      logical exclusive OR
OPS.MOD  EQU $8514         MOD      modulus
OPS.DIV  EQU $8515         DIV      integer division
OPS.INST EQU $8516         INSTR    string comparison          (type 1)

********************************
* Mono-operation symbol tokens *
********************************

MON.NEG  EQU $8601         -        negate (unary minus)
MON.POS  EQU $8602         +        positive (unary plus)
MON.BNOT EQU $8603         ~~       bitwise NOT
MON.NOT  EQU $8604         NOT      logical NOT

********************
* Separator tokens *
********************

SEP.COM  EQU $8E01         ,        comma (tabulate)
SEP.SEM  EQU $8E02         ;        semi-colon
SEP.NL   EQU $8E03         \        backslash (force newline)
SEP.SSPC EQU $8E04         !        exclamation (special space)
SEP.TO   EQU $8E05         TO       general tabulation

*****************************
* SUPERBASIC variable types *
*****************************

VT.STRUD EQU $0001         undefined string variable
VT.FPUD  EQU $0002         undefined floating point number
VT.INTUD EQU $0003         undefined integer
VT.STRXP EQU $0101         string expression
VT.FPXP  EQU $0102         flaoting point expression
VT.INTXP EQU $0103         integer expression
VT.STRVA EQU $0201         string variable
VT.FPVA  EQU $0202         floating point variable
VT.INTVA EQU $0203         integer variable
VT.STRSB EQU $0300         substring
VT.STRAR EQU $0301         string array
VT.FPAR  EQU $0302         flaoting point array
VT.INTAR EQU $0303         integer array
VT.SBPRO EQU $0400         SUPERBASIC procedure
VT.STRFN EQU $0501         string function
VT.FPFN  EQU $0502         floating point function
VT.INTFN EQU $0503         integer function
VT.RPTLP EQU $0602         REPeat loop name
VT.FORLP EQU $0702         FOR loop counter
VT.MCPRO EQU $0800         machine code procedure
VT.MCFUN EQU $0900         machine code function 

**************************
* Peripheral I/O devices *
**************************

PC_CLOCK EQU $18000        real time clock long word write only register
PC.CLOCK EQU $00
PC_TCTRL EQU $18002        transmit control register byte
PC.TCTRL EQU $02
PC_IPCWR EQU $18003        IPC write only port
PC.IPCWR EQU $03
PC_IPCRD EQU $18020        IPC read only port
PC.IPCRD EQU $20
*                          bit 0 = network port
*                          bit 1 = microdrive buffer full
*                          bit 4 = port 1 handshake line not ready (DTR)
*                          bit 5 = port 2 handshake line not ready (CTS)

PC_MCTRL EQU $18020        microdrive control write only register
PC.MCTRL EQU $20
PC_INTR  EQU $18021        interrupt register
PC.INTR  EQU $21
PC_TDATA EQU $18022        transmit write only register for serial O/P
PC.TDATA EQU $22
PC_TRAK1 EQU $18022        microdrive read track 1
PC.TRAK1 EQU $22
PC_TRAK2 EQU $18023        microdrive read track 2
PC.TRAK2 EQU $23
MC_STAT  EQU $18063        master chip write only status register
MC.STAT  EQU $63
*                          bit 1 = screen display off if set
*                          bit 3 = 8 colour mode if set, 4 colour mode if reset
*                          bit 7 = screen #0 if reset, screen #1 if set


****************
* IPC commands *
****************

IPC_0    EQU 0             processor reset
IPC_1    EQU 1             report input status
IPC_2    EQU 2             open serial port 1
IPC_3    EQU 3             open serial port 2
IPC_4    EQU 4             close serial port 1
IPC_5    EQU 5             close serial port 2
IPC_6    EQU 6             read serial port 1
IPC_7    EQU 7             read serial port 2
IPC_8    EQU 8             read keyboard
IPC_9    EQU 9             keyboard direct read
IPC_10   EQU 10            initiate sound process
IPC_11   EQU 11            kill sound process
IPC_12   EQU 12            microdrive reduced sensitivity
IPC_13   EQU 13            change baud rate
IPC_14   EQU 14            random number generator
IPC_15   EQU 15            processor test

********************
* Name table entry *
********************

NTB.TYPE EQU 0    byte     name type
NTB.STVT EQU 1    byte     separator type and variable type { MSN, LSN }
NTB.OFFN EQU 2    word     pointer to offset of name in namelist or a copy of
*                          the entry
NTB.OFFV EQU 4    long     This can be one of the following things:

* 1. A pointer to offset of value of the variable in the variables area.
*
* 2. The offset of the array descriptor.
*
* 3. The address of the machine code procedure or function.
*
* 4. The line number of the SUPERbasic procedure or function.

***********************************************
* The variable values area entry for an array *
***********************************************

RA.OFSTV EQU 0    long     offset in variable values area of values
RA.NUMIN EQU 4    word     

****************************************************
* The variable values area entry for a REPeat loop *
****************************************************

RL.INDEX EQU 0     6 bytes
RL.REPLN EQU 6     word    line number of the line containing the REPeat
RL.ENDLN EQU 8     word    line number of the line containing the END REPeat
RL.RELST EQU 10    byte    statement number of the REPeat statement
RL.ENDST EQU 11    byte    statement number of the END REPeat statement

*************************************************
* The variable values area entry for a FOR loop *
*************************************************

FL.INDEX EQU 0     6 bytes
FL.FORLN EQU 6     word
FL.ENDLN EQU 8     word
FL.FORST EQU 10    byte
FL.ENDST EQU 11    byte
FL.ENDV  EQU 12    6 bytes 
FL.STEPV EQU 18    6 bytes
FL.POSRN EQU 24    word

*********************************
* SUPERbasic return stack entry *
*********************************

RS.ONTPE EQU 0     long
RS.ONTLE EQU 4     long
RS.TNTLE EQU 8     long
RS.DEFLN EQU 12    word
RS.FNTYP EQU 14    byte
RS.SWAP  EQU 15    byte
RS.TYPE  EQU 16    byte    type:

*                          0 = GO SUB
*                          1 = PROCedure
*                          2 and 3 = FUNction

RS.STMNT EQU 17    byte
RS.LINEN EQU 18    word
RS.STATS EQU 20    long



LABELS

***********************************
* SYSTEM VECTORS & INITIALISATION *
***********************************

RESETSSP   EQU      $0000    reset stack pointer
RESETPC    EQU      $0004    reset program counter
XVECTOR    EQU      $0008    SYSTEM EXCEPTION VECTORS
XBRANCH    EQU      $0028
XHANDLER   EQU      $0050    INITIAL EXCEPTION HANDLER
NORAMEX    EQU      $0054    
EXIT_HAN   EQU      $005C    
IGNORE     EQU      $005E    
IVECTORS   EQU      $0060    INTERRUPT VECTORS
TVECTORS   EQU      $0080    TRAP VECTORS
MM.ALCHP   EQU      $00C0    allocate commom heap vector
MM.RECHP   EQU      $00C2    release commom heap space vector
UT.WINDW   EQU      $00C4    create window channel vector
UT.CON     EQU      $00C6    create console channel vector
UT.SCR     EQU      $00C8    create screen channel vector
UT.ERR0    EQU      $00CA    send error message to channel 0 vector
UT.ERR     EQU      $00CC    send error message to channel vector
UT.MINT    EQU      $00CE    print decimal no on channel vector
UT.MTEXT   EQU      $00D0    send message to channel vector
UT.LINK    EQU      $00D2    link item into list vector
UT.UNLNK   EQU      $00D4    unlink item from list vector
MM.ALLOC   EQU      $00D8    allocate heapspace vector
MM.LNKFR   EQU      $00DA    link free space into heap vector
IO.QSET    EQU      $00DC    set up a queue header vector
IO.QTEST   EQU      $00DE    test queue status vector
IO.QIN     EQU      $00E0    put byte into queue vector
IO.QOUT    EQU      $00E2    get byte from queue vector
IO.QEOF    EQU      $00E4    put EOF file marker in queue vector
UT.CSTR    EQU      $00E6    string comparison vector
IO.SERQ    EQU      $00E8    direct queue handling vector
IO.SERIO   EQU      $00EA    general I/O handling vector
CN.DATE    EQU      $00EC    get date string vector
CN.DAY     EQU      $00EE    get day string vector
CN.FTOD    EQU      $00F0    convert floating point to ASCII vector
CN.ITOD    EQU      $00F2    convert integer to ASCII vector
CN.ITOBB   EQU      $00F4    convert binary byte to ASCII vector
CN.ITOBW   EQU      $00F6    convert binary word to ASCII vector
CN.ITOBL   EQU      $00F8    convert binary long to ASCII vector
CN.ITOHB   EQU      $00FA    convert hex byte to ASCII vector
CN.ITOHW   EQU      $00FC    convert hex word to ASCII vector
CN.ITOHL   EQU      $00FE    convert hex long to ASCII vector
CN.DTOF    EQU      $0100    convert ASCII to floating point vector
CN.DTOI    EQU      $0102    convert ASCII to integer vector
CN.BTOIB   EQU      $0104    convert ASCII to binary byte vector
CN.BTOIW   EQU      $0106    convert ASCII to binary word vector
CN.BTOIL   EQU      $0108    convert ASCII to binary long vector 
CN.HTOIB   EQU      $010A    convert ASCII to hex byte vector 
CN.HTOIW   EQU      $010C    convert ASCII to hex word vector 
CN.HTOIL   EQU      $010E    convert ASCII to hex long vector 
BP.INIT    EQU      $0110    add superbasic procedures vector
CA.GTINT   EQU      $0112    get word integers vector
CA.GTFP    EQU      $0114    get floating points vector
CA.GTSTR   EQU      $0116    get strings vector
CA.GTLIN   EQU      $0118    get long integers vector
BV.CHRIX   EQU      $011A    reserve space on maths stack vector
RI.EXEC    EQU      $011C    do a maths operation vector
RI.EXECB   EQU      $011E    do a list of maths operations vector
BP.LET     EQU      $0120    return parameter values vector
IO.NAME    EQU      $0122    decode device name vector
MD.READ    EQU      $0124    read a microdrive sector vector
MD.WRITE   EQU      $0126    write a microdrive sector vector
MD.VERIN   EQU      $0128    verify a microdrive sector vector
MD.SECTR   EQU      $012A    read a microdrive sector header vector
SB.SNTX    EQU      $012C    basic syntax analyser
SB.FSTFC   EQU      $012E    first syntax table for commands
SB.SSTFE   EQU      $0130    second syntax table for expressions
SB.FPCBL   EQU      $0132    format pre-compiled basic line
SB.CMPER   EQU      $0134    error when compiling
SB.SPFBL   EQU      $0136    store pre-formated line
SB.CCBTA   EQU      $0138    convert pre-compiled basic to ascii
CHKRAMEX   EQU      $013A    CHECK FOR RAM EXCEPTION TABLE
BADRAM     EQU      $015A
BADRAM2    EQU      $015C    
MEMTEST    EQU      $0168    COMPREHENSIVE MAIN RAM AND EXPANSION RAM MEMORY TEST
CHKRAM1    EQU      $0170    
CHKRAM2    EQU      $0182    
TESTRAM    EQU      $0188    
NXTLONG    EQU      $019A    
ROM_END    EQU      $01A0
TESTED     EQU      $01C0    test the ram refresh
SETIO      EQU      $01CA    
SYSVAR     EQU      $01FC    
LENGTHOK   EQU      $0244    
BLOCKINF   EQU      $024E    set up the three pointers for the system tables
CLEARTAB   EQU      $0284    
ENTER_SM   EQU      $0308    enter supervisor mode
MT_TRAP1   EQU      $030C    memory management and job control
IO_TRAP2   EQU      $0312    I/O allocation
IO_TRAP3   EQU      $0318    actual I/O , file handling and graphics
SB_TRAP4   EQU      $031E    convert to absolute values
SETUPTRA   EQU      $0324    set up registers and stack for trap handlers
SYSINT     EQU      $0340    SYSTEM INTERRUPT HANDLER
EXTNLINT   EQU      $036E    EXTERNAL INTERRUPT HANDLER
EXIT_INT   EQU      $038E    
CLEANUP    EQU      $0392    CLEAN UP ROUTINE FOR ALL THE TRAP HANDLERS
CHKSBIT    EQU      $0394    CHECK IF SUPERVISOR MODE BIT SET ON ENTRY
EXITTRAP   EQU      $03A4    GENERAL EXIT TO RESTORE SUPERBASIC'S REGISTERS
CHKJBID    EQU      $03AA    CHECK JOB ID
ENDJCHK    EQU      $03C4    
CHKJOB     EQU      $03C6    
CHKJBNO    EQU      $03D2    
GETJBID    EQU      $03F6    GET CURRENT JOB'S ID & HEADER
TIMER1     EQU      $040E    TIMER FOR SERIAL & MICRODRIVE I/O
TIMER2     EQU      $0410    
TIMER3     EQU      $041A    
TIMER4     EQU      $0420    
EXITIMER   EQU      $0436    
CLRTMODE   EQU      $0440    ENTRY POINT WHEN M'DRIVE OPERATIONS FINISHED

*********************
* TRAP #1 FUNCTIONS *
*********************

CHKTRP1    EQU      $044E    HANDLE TRAP #1 FUNCTIONS
TABLE1     EQU      $0460    table of vector offsets for the TRAP #1 functions
BADPARAM   EQU      $04A8
MT_INF     EQU      $04AE    GET SYSTEM INFORMATION
MT_JINF    EQU      $04C0    GET JOB INFORMATION
POSSACTI   EQU      $04CE    
MT_CJOB    EQU      $04E8    CREATE A JOB 
NOSPACE    EQU      $04F0    
TESTENTR   EQU      $04FA    
ENTRYFRE   EQU      $050C    
JBMAXOK    EQU      $0528    
CLRHEADR   EQU      $052C    
NOSTART    EQU      $0570    
EXIT_CJB   EQU      $057A    
MT_RJOB    EQU      $0584    REMOVE A JOB
MT_FRJOB   EQU      $059C    FORCE REMOVE A JOB
MARKJOB    EQU      $05B0    
CHKJOBS    EQU      $05C2    
NOTCURNT   EQU      $05E6    
NOTWAIT    EQU      $060A    
CHKBLOCK   EQU      $060E    
NOLOC      EQU      $0622    
NOTOWNED   EQU      $0634    
CHKCURNT   EQU      $0650    
EXIT_REM   EQU      $065A    
FINDSUBS   EQU      $0660    FIND SUBSIDUARY IN JOB TREE
CHKENTRY   EQU      $0664    
CHKPARNT   EQU      $067A    
GETHEAD    EQU      $0688    
NOSUBSID   EQU      $0696    
EXIT_FIN   EQU      $069A    
MT_TRAPV   EQU      $06A4    SET UP RAM EXCEPTION TABLE
MT_ALLOC   EQU      $06B8    ALLOCATE HEAP SPACE
MT_LNKFR   EQU      $06C6    RELEASE HEAP SPACE
MT_ALCHP   EQU      $06D4    ALLOCATE COMMON HEAP SPACE
RELEASE    EQU      $06E8
MT_RECHP   EQU      $06F8    RELEASE COMMON HEAP SPACE
EXIT_REC   EQU      $0700    
MT_ALRES   EQU      $0704    ALLOCATE RESPR SPACE
MT_RERES   EQU      $0720    RELEASE RESIDENT PROCEDURE AREA
SETPOINT   EQU      $072C    
NOTEMPTY   EQU      $073A    
EXIT_RER   EQU      $073C    
MT_ALBAS   EQU      $073E    ALLOCATE BASIC AREA
MT_REBAS   EQU      $0744    RELEASE BASIC AREA
EXIT_REB   EQU      $0758    
MT_DMODE   EQU      $075C    SET OR READ DISPLAY MODE
CLSCREEN   EQU      $0780    clear the screen to all black
REQ_M4     EQU      $07E8    
READ_DM    EQU      $07F8    
WRITE_TY   EQU      $0804    
MT_IPCOM   EQU      $080C    SEND IPC COMMAND
MT_BAUD    EQU      $081C    SET SERIAL PORT BAUD RATE
EXIT_BAU   EQU      $0830    
BAUDOK     EQU      $0838    
BAUDTABL   EQU      $0870    table of valid baud rates
MT_LINK    EQU      $0880    LINK ITEM INTO LIST
MT_UNLNK   EQU      $088C    UNLINK ITEM FROM LIST
EXIT_UNL   EQU      $0896

*****************
* THE SCHEDULER *
*****************
         
FRAMEINT   EQU      $089A    FRAME INTERRUPT HANDLER
POLLM_OK   EQU      $08A4
SCHEDULE   EQU      $08D0    
CHKPOLLM   EQU      $08D4    
MT_SUSJB   EQU      $08EA    SUSPEND A JOB
MT_RELJB   EQU      $090C    RELEASE A SUSPENDED JOB
EXIT_REL   EQU      $0924    
MT_PRIOR   EQU      $092A    CHANGE JOB PRIORITY
MT_ACTIV   EQU      $093A    ACTIVATE A JOB
EXIT_ACT   EQU      $0964    
STILLACT   EQU      $096A    
SHUTDOWN   EQU      $096E    COPY JOB'S DETAILS TO HEADER'S STORAGE AREA
DECIDE     EQU      $09A6    FIND OUT WHICH JOB IS TO BE THE NEXT ONE
STARTUP    EQU      $0A12    COPY JOB'S DETAILS FROM HEADER'S STORAGE AREA
EXECLIST   EQU      $0A38    EXECUTE LINKED LIST OF TASKS
NEXTTASK   EQU      $0A3A    
LIST_END   EQU      $0A56

************************
* SERIAL DEVICE DRIVER *
************************

SER_LB     EQU      $0A5A    LINKAGE BLOCK FOR SERIAL DEVICE
SEROPEN    EQU      $0A6A    OPEN A SERIAL CHANNEL
SERDATA    EQU      $0A78    data for serial device name
IPC_OPEN   EQU      $0A94    command table for IPC
IPC_CLOS   EQU      $0AA4    
SE_ERRNF   EQU      $0AB4    
SE_ERRIU   EQU      $0AB8    
SER_EXIT   EQU      $0ABA    
SERNMOK    EQU      $0AC2    
SER_OUTQ   EQU      $0AF0    create the 228 byte buffer for the serial queue
SER_INQ    EQU      $0B04    
SERCLOSE   EQU      $0B28    CLOSE A SERIAL CHANNEL
SERPORT1   EQU      $0B36    
SER_IPC    EQU      $0B44    SEND IPC COMMAND TO OPEN OR CLOSE SERIAL PORT
SER_IO     EQU      $0B50    GENERAL SERIAL I/O
SE_PEND    EQU      $0B62    TEST FOR PENDING INPUT
SE_SBYTE   EQU      $0B6A    SEND A BYTE
CHAR_OK1   EQU      $0B78    
PTABLE1    EQU      $0B84
SPA_MARK   EQU      $0B8A    
SPA_NONE   EQU      $0B8E    
SPA_SPAC   EQU      $0B98    
SPA_ODD    EQU      $0B9E    
SPA_EVEN   EQU      $0BA6    
SE_FBYTE   EQU      $0BAA    FETCH A BYTE
PTABLE2    EQU      $0BC0
LPA_MARK   EQU      $0BC6    
LPA_ODD    EQU      $0BCC    
LPA_EVEN   EQU      $0BD0    
LPA_SPAC   EQU      $0BD2    
LPA_NONE   EQU      $0BDA    
CHAR_OK2   EQU      $0BE8    
CHKPARIT   EQU      $0BEA    ckeck parity of byte
NEXTPBIT   EQU      $0BEE

**********************
* PIPE DEVICE DRIVER *
**********************
         
PIPE_LB    EQU      $0BFC    LINKAGE BLOCK FOR PIPE DEVICE
PIPEOPEN   EQU      $0C0C    OPEN A PIPE CHANNEL
PIPEDATA   EQU      $0C1A    data for pipe device name
PIPENMOK   EQU      $0C26    
PP_INPUT   EQU      $0C46    
PIPE_OK    EQU      $0C72    
PP_EXIT    EQU      $0C74    
PP_ERRBP   EQU      $0C78    
PIPECLOS   EQU      $0C7E    CLOSE A PIPE CHANNEL
INPIPE     EQU      $0C90    
PIPERECL   EQU      $0CA6

**********************************
* CONSOLE & SCREEN DEVICE DRIVER *
**********************************

CON_LB     EQU      $0CAA    LINKAGE BLOCK FOR CONSOLE DEVICE
CONOPEN    EQU      $0CBA    OPEN A CONSOLE CHANNEL
CONDATA    EQU      $0CCA
CONNMOK    EQU      $0CE6    
SCR_NEWQ   EQU      $0D0C    
TRY_SCR    EQU      $0D12
SCRDATA    EQU      $0D1C
SCRNMOK    EQU      $0D34    OPEN A SCREEN CHANNEL
SCR_OK     EQU      $0D3A    
SCR_EXIT   EQU      $0D3C    
SCROPEN    EQU      $0D42    OPEN A SCREEN OR CONSOLE CHANNEL
SCR_M4     EQU      $0D8A    
SCR_END    EQU      $0DA2    
CONCLOSE   EQU      $0DA4    CLOSE A CONSOLE OR SCREEN CHANNEL 
NEXT_Q1    EQU      $0DB6    
FIND_Q1    EQU      $0DC0    
NEXT_Q2    EQU      $0DC2    
CONRECLM   EQU      $0DCA
CON_IO     EQU      $0DD0    GENERAL CONSOLE OR SCREEN CHANNEL I/O
SCRACTIV   EQU      $0DDA    
SC_OPOK    EQU      $0E0A    
SC_TBL     EQU      $0E12
SC_PEND    EQU      $0E1A    TEST FOR PENDING INPUT
SC_FBYTE   EQU      $0E1E    FETCH A BYTE
SC_FSTRG   EQU      $0E24    FETCH A STRING OF BYTES
SC_GET     EQU      $0E26    
SC_SSTRG   EQU      $0E38    SEND A STRING OF BYTES
SC_ERRBP   EQU      $0E46    
BUF_END    EQU      $0E48    
W_CMND     EQU      $0E56    
SC_SBYTE   EQU      $0E5A    SEND A BYTE
NO_NEWL    EQU      $0E6E    
CHK_LF     EQU      $0E90    
SC_ECHO    EQU      $0EA0    
SC_FLINE   EQU      $0EAE    FETCH A LINE
SC_EDLIN   EQU      $0EB4    EDIT A LINE
BUF_UP     EQU      $0F12    
INSERT     EQU      $0F18    
FILTER     EQU      $0F34    
BUF_DOWN   EQU      $0FE8    
DELETE     EQU      $0FEC

*************************
* NETWORK DEVICE DRIVER *
*************************

NET_LB     EQU      $105E    LINKAGE BLOCK FOR NETWORK DEVICE
NETOPEN    EQU      $106E    OPEN A NETWORK CHANNEL
NETDATA    EQU      $107C
NETNMOK    EQU      $108C    
NET_EXIT   EQU      $10AE    
NETCLOSE   EQU      $10B2    CLOSE A NETWORK CHANNEL
NT_RECLM   EQU      $10D8    
NT_ERRBP   EQU      $10DC    
NET_IO     EQU      $10E0    GENERAL NETWORK I/O
NT_PEND    EQU      $10F2    TEST FOR PENDING INPUT
NT_FBYTE   EQU      $111E    FETCH A BYTE
NT_SBYTE   EQU      $112A    SEND A BYTE

****************************
* MICRODRIVE DEVICE DRIVER *
****************************

SCHDTASK   EQU      $115C    START OF SCHEDULER TASKS LINKED LIST
FLASHCUR   EQU      $1164    FLASH THE CURSOR
EXIT_FLA   EQU      $1188    
MDV_LB     EQU      $118A    LINKAGE BLOCK FOR MICRODRIVE DEVICE
REPEATIO   EQU      $11B4    DO MICRODRIVE I/O OPERATION UNTIL COMPLETE
NEXT_IO    EQU      $11B8
MDV_IO     EQU      $11CE    GENERAL MICRODRIVE I/O
MD_TBL     EQU      $11F6
MD_ERRBP   EQU      $1200
FS_CHECK   EQU      $1204    CHECK PENDING OPERATIONS
FS_FLUSH   EQU      $120A    FLUSH ALL BUFFERS
FS_CHK     EQU      $120E
FS_POSAB   EQU      $1244    POSITION ABSOLUTE FILE POINTER
FS_POSRE   EQU      $124A    POSITION RELATIVE FILE POINTER
FS_MDINF   EQU      $1256    GET MEDIUM INFORMATION
MD_INUSE   EQU      $1274
MD_BAD     EQU      $1276
FS_LOAD    EQU      $1280    LOAD A FILE
FS_SAVE    EQU      $1294    SAVE A FILE
FS_HEADS   EQU      $12A6    SET FILE HEADER
MD_GETBL   EQU      $12AA
FS_HEADR   EQU      $12B8    READ FILE HEADER
GET_HEAD   EQU      $12BC
MD_SSTRG   EQU      $12FA
MD_SBYTE   EQU      $1308
MD_ERRRO   EQU      $1318
MD_ERRFE   EQU      $1322
MD_ERREF   EQU      $133A
MD_ERRNC   EQU      $147A
MD_OPEN    EQU      $168A    OPEN A MICRODRIVE CHANNEL
MD_END     EQU      $179A
MD_ERRNF   EQU      $179E
MD_ERREX   EQU      $17A2
MD_CLOSE   EQU      $1812    CLOSE A MICRODRIVE CHANNEL
FILE_ABS   EQU      $1880    POSITION FILE POINTER USING ABSOLUTE OFFSET
FILE_REL   EQU      $1886    POSITION FILE POINTER USING RELATIVE OFFSET

************************
* SCREEN DEVICE DRIVER *
************************

MT_CLOCK   EQU      $18B4    DO CLOCK FUNCTION
GETTIME    EQU      $18BA    
MT_ACLK    EQU      $18CC    ADJUST CLOCK
MT_SCLK    EQU      $18CE    SET CLOCK
CLKMASK    EQU      $18D4    
SETCLK     EQU      $18DC    
NEWCLK     EQU      $18DE    
CLK_EXIT   EQU      $18E8    
WIN_CMND   EQU      $18EC    CHECK FOR WINDOW TRAP #3 COMMANDS
SD_BADP1   EQU      $1946
SD_ERRBP   EQU      $1948
SD_TBL2    EQU      $194C
SD_CHAR    EQU      $19A6    PRINT A CHARACTER
SD_PXENQ   EQU      $19D2    READ WINDOW SIZE/CURSOR POSITION (PIXEL)
SD_CHENQ   EQU      $19E4    READ WINDOW SIZE/CURSOR POSITION (CHARACTER)
PIXL_DIV   EQU      $1A04
SD_WDEF    EQU      $1A10    REDEFINE WINDOW
SD_BORDR   EQU      $1A52    SET WINDOW WIDTH & COLOUR
SD_BORDE   EQU      $1A56    SET BORDER WIDTH ONLY
NO_CHNGE   EQU      $1A64
SD_REDEF   EQU      $1A6C    REDEFINE WINDOW WITH NEW SIZE
SD_OUTR1   EQU      $1ABE
CHK_BORD   EQU      $1AC6    FORM OVERALL WINDOW SIZE FROM PARAMETERS
CHK_SIZE   EQU      $1AC8    FORM NEW WINDOW SIZE INSIDE BORDER
TOO_BIG    EQU      $1ADC    
SD_CURE    EQU      $1AE0    ENABLE CURSOR
SD_CURS    EQU      $1AEE    DISABLE CURSOR
PRNT_CUR   EQU      $1AFC    PRINT THE CURSOR IF ENABLED
DISP_CUR   EQU      $1B04    REPRINT THE CURSOR
CHK_CURS   EQU      $1B28    CHECK CURSOR CO-ORDINATES
SD_OUTR2   EQU      $1B48    
SD_DONL    EQU      $1B4C    DO PENDING NEWLINE
SD_NEWL    EQU      $1B52    DO FORCED NEWLINE
EXIT_NL    EQU      $1B6C
END_NL     EQU      $1B74
SD_HOME    EQU      $1B76    RESET CURSOR POSITION TO 0,0
SD_POS     EQU      $1B7C    SET CURSOR POSITION
SD_TAB     EQU      $1B82    SET HORIZONTAL POSITION
SD_COL     EQU      $1B86
SD_NL      EQU      $1B8C    DO NEWLINE
SD_PCOL    EQU      $1B98    SET TO PREVIOUS COLUMN
SD_NCOL    EQU      $1BA2    SET TO NEXT COLUMN
SD_PROW    EQU      $1BB0    SET TO PREVIOUS ROW
SD_NROW    EQU      $1BBA    SET TO NEXT ROW
SD_PIXP    EQU      $1BC6    SET PIXEL POSITION
CANCEL     EQU      $1BF4
SD_OUTR3   EQU      $1BFC    
SD_RECOL   EQU      $1C00    RECOLOUR A WINDOW
SD_CLEAR   EQU      $1C08    CLEAR WHOLE WINDOW
SD_CLR     EQU      $1C0E    CLEAR A WINDOW
SD_SCRLL   EQU      $1C18    SCROLL A WINDOW
SD_PANW    EQU      $1C22    PAN A WINDOW
SD_SETUP   EQU      $1C36
SD_DO_OP   EQU      $1C3A
SD_REST    EQU      $1C54
SD_CLINE   EQU      $1C6C
SD_WHOLE   EQU      $1C7C
SD_FILL    EQU      $1C86    FILL A BLOCK
SD_OUTR4   EQU      $1CE2    
SD_FOUNT   EQU      $1CE6    SET CHARACTER FONTS
SD_SETCL   EQU      $1D04    SET COLOURS
SD_SETFL   EQU      $1D18    SET FLASH MODE
SD_SETMD   EQU      $1D24    SET WRITE MODE
SD_SETUL   EQU      $1D2A    SET UNDERLINE MODE
TEST_BIT   EQU      $1D2C
SD_SETSZ   EQU      $1D32    SET CHARACTER SIZE
GET_SIZE   EQU      $1D4C
SD_XOK1    EQU      $1D72
SET_ATTR   EQU      $1D96    
SD_YOK1    EQU      $1DA2
CTABLE_1   EQU      $1DA6
CTABLE_2   EQU      $1DAA    
SD_GCUR    EQU      $1DAC    SET TEXT CURSOR WITH GRAPHIC CO-ORDINATES
SD_FTOIW   EQU      $1DE2
MLIST_1    EQU      $1DE8
SD_SCALE   EQU      $1DFC    SET GRAPHICS SCALE & ORIGIN
SD_FLOOD   EQU      $1E0A    SET FILL MODE/USER VECTORS
SD_POINT   EQU      $1E62    PLOT POINT
SD_LINE    EQU      $1E70    DRAW LINE
MTABLE_1   EQU      $1E7E
MLIST_3    EQU      $1E88
MLIST_0    EQU      $1E9D
SD_ARC     EQU      $1E9E    PLOT ARC
MTABLE_2   EQU      $1EC4
MLIST_4    EQU      $1ED6
MLIST_5    EQU      $1F28
SD_ELIPS   EQU      $1F46    DRAW CIRCLE/ELLIPSE
MTABLE_3   EQU      $1F54
MLIST_6    EQU      $1F66
MLIST_7    EQU      $1F8C
MLIST_8    EQU      $1F92
MLIST_9    EQU      $2046
MLIST_A    EQU      $204A
DO_TABLE   EQU      $2058    DO TABLE OF MATHS OFFSETS
MLIST_B    EQU      $2142
MLIST_C    EQU      $2170
UT_FILL0   EQU      $24A0
UT_FILL1   EQU      $2516
UT_FILL2   EQU      $2522
UT_FILL3   EQU      $252E
UT_SCRLL   EQU      $2556    SCROLL A WINDOW
UT_PAN     EQU      $25A0    PAN A WINDOW
COLRMASK   EQU      $2730    REDO COLOUR MASKS
PRINT_CH   EQU      $2798    PRINT A CHARACTER

****************************************
* MICRODRIVE DEVICE DRIVER (CONTINUED) *
****************************************

MD_SLAVE   EQU      $2916    MICRODRIVE FORCED SLAVING
CLR_SBLK   EQU      $2954    CLEAR THE SLAVE BLOCKS USED BY A DRIVE
BAD_HEAD   EQU      $29B2
BAD_MEDI   EQU      $29B6    CHECK IF MEDIUM BAD OR UNFORMATTED
MED_OK     EQU      $29CC
GAPINT     EQU      $29D6    GAP INTERRUPT HANDLER
MD_EXIT1   EQU      $2A9C
MD_EXIT2   EQU      $2A9E
MD_EXIT3   EQU      $2AA2
MD_EXIT4   EQU      $2AA6
MD_DESEL   EQU      $2B6A    SWITCH ALL MICRODRIVE MOTORS OFF
MD_SELCT   EQU      $2B70    SWITCH A MICRODRIVE MOTOR ON

*****************************
* PERIPHERAL COMMUNICATIONS *
*****************************

IPC_CMND   EQU      $2B8C    DO IPC COMMAND
IPC_PUT    EQU      $2B9E
IPC_END    EQU      $2BBE
IPC_GETP   EQU      $2BD2
ACK_INTR   EQU      $2BD6    ACKNOWLEDGE INTERFACE INTERRUPTS
IPC_PARA   EQU      $2BE2
INTRFINT   EQU      $2BE6    INTERFACE INTERRUPT HANDLER
TRNSMINT   EQU      $2BF2    TRANSMIT INTERRUPT HANDLER
POLLTASK   EQU      $2C12    START OF POLLED TASKS LINKED LIST
SECTASK    EQU      $2C1A    SECOND TASK IN SCHEDULER LINKED LIST
CHK_IPC    EQU      $2C3A
CHK_SER1   EQU      $2C64
CHK_SER2   EQU      $2C78
EXIT_CHK   EQU      $2C8C
SER_TXRX   EQU      $2C8E
CHK_KEY    EQU      $2D72
BRK_KEY    EQU      $2DD8
CHK_ALT    EQU      $2E26
NO_ALT     EQU      $2E4A
CTRL_F5    EQU      $2E4E
CTRL_C     EQU      $2E54
IPC_SET    EQU      $2E80    SET UP IPC COMMAND
IPC_SEND   EQU      $2E8E    SEND COMMAND TO IPC
IPC_RETN   EQU      $2EA8    RETURN IPC PARAMETER NIBBLE
IPC_RETB   EQU      $2EAC    RETURN IPC PARAMETER BYTE

*******************************
* MEMORY ALLOCATION & CONTROL *
*******************************

MM_ALCHP   EQU      $2EC0    ALLOCATE COMMON HEAP
MM_ALTPA   EQU      $2F0C    EXPAND TRANSIENT PROGRAM AREA
MM_RECHP   EQU      $2F70    RELEASE COMMON HEAP SPACE
MM_RETPA   EQU      $2F9E    RELEASE TRANSIENT PROGRAM AREA
MT_FREE    EQU      $2FF2    FIND MAXIMUM AMOUNT OF FREE SPACE
MM_ALLOC   EQU      $3016    ALLOCATE HEAP SPACE
MM_SRCH    EQU      $3046
MM_LNKFR   EQU      $3074    LINK FREE SPACE INTO HEAP
MM_ALBAS   EQU      $30CA    ALLOCATE BASIC AREA
MM_REBAS   EQU      $30DA    RELEASE BASIC AREA

**********************************
* INPUT OUTPUT SUB SYSTEM (IOSS) *
**********************************

CHKTRP2    EQU      $31B4    HANDLE TRAP #2 FUNCTIONS
ABS_ADDR   EQU      $31C6
IO_OPEN    EQU      $31E2    OPEN A CHANNEL
SCAN_CT    EQU      $31F2
SCAN_DD    EQU      $3202
NEXT_DD    EQU      $3206
SET_CHAN   EQU      $3230
END_OPEN   EQU      $325E
IO_CLOSE   EQU      $3264    CLOSE A CHANNEL
END_CLOS   EQU      $328A
CHKTRP3    EQU      $328E    HANDLE TRAP #3 FUNCTIONS
IOSTRING   EQU      $32C0    
BYTE_IO    EQU      $32C2    
A1_ABS     EQU      $32D6    
CHKTRP4    EQU      $3344    CONVERT TO ABSOLUTE VALUES
CHKCHID    EQU      $3356    CHECK CHANNEL ID
DOWAITIO   EQU      $338A    DO WAITING I/O
IO_DELET   EQU      $345C    DELETE A FILE
IO_OPEN2   EQU      $3464
TYPE_OK    EQU      $346E
IO_FORMT   EQU      $35C0    FORMAT A MEDIUM
CHK_DD     EQU      $35DE
NXT_DD     EQU      $35E6
CHK_NAME   EQU      $35F0
BAD_DEV    EQU      $3600
DD_OK      EQU      $3608
IO_ERRNF   EQU      $3622
EXIT_DD    EQU      $3624

******************************
* GENERAL SERIAL I/O DRIVERS *
******************************

IO_NAME    EQU      $3636    DECODE DEVICE NAME
IO_SERQ    EQU      $36D6    DIRECT QUEUE HANDLING
IO_QSET    EQU      $36FE    SET UP A QUEUE HEADER
IO_QTEST   EQU      $3714    TEST QUEUE STATUS
IO_QIN     EQU      $3742    PUT BYTE INTO QUEUE
IO_QOUT    EQU      $3768    GET BYTE FROM QUEUE
IO_QEOF    EQU      $3792    PUT EOF MARKER IN QUEUE
IO_SERIO   EQU      $3796    GENERAL I/O HANDLING
IO_TABLE1  EQU      $37CA
IO_TABLE2  EQU      $37D2
IO_FLINE   EQU      $37D6
IO_LNXTB   EQU      $37DA
IO_SSTRG   EQU      $37EE
IO_SNXTB   EQU      $37F2
IO_LOAD    EQU      $3802
IO_FNXTB   EQU      $3806
IO_FSTRG   EQU      $3808
IO_PEND    EQU      $3814
IO_FBYTE   EQU      $3816
IO_SBYTE   EQU      $3818
IO_EDLIN   EQU      $381E
IO_ERRBO   EQU      $3822
IO_ERROK   EQU      $3826
IO_GEXIT   EQU      $3828
IO_CALLF   EQU      $382C
IO_EEXIT   EQU      $3836
IO_HEADS   EQU      $383A
IO_HEADR   EQU      $384E

********************
* SYSTEM UTILITIES *
********************

UT_ERR0    EQU      $3868    SEND ERROR MESSAGE TO CHANNEL 0
UT_ERR     EQU      $3872    SEND ERROR MESSAGE TO CHANNEL
PRNT_ERR   EQU      $388A
ERR_EXIT   EQU      $3892
ERR_OFST   EQU      $3894
ERR_MSGE   EQU      $38BE
UT_MINT    EQU      $3A00    PRINT DECIMAL NUMBER ON CHANNEL
UT_MTEXT   EQU      $3A22    SEND MESSAGE TO CHANNEL
UT_LINK    EQU      $3A4A    LINK ITEM INTO LIST
UT_UNLNK   EQU      $3A50    UNLINK ITEM FROM LIST
UT_WINDW   EQU      $3A60    CREATE WINDOW CHANNEL
UT_CON     EQU      $3A64    CREATE CONSOLE CHANNEL
UT_SCR     EQU      $3A6A    CREATE SCREEN CHANNEL
UT_CSTR    EQU      $3B0A    STRING COMPARISON

***************
* CONVERSIONS *
***************

CN_DTOF    EQU      $3D84    CONVERT ASCII TO FLOATING POINT
CN_DTOI    EQU      $3E30    CONVERT ASCII TO INTEGER
CN_HTOIB   EQU      $3E42    CONVERT ASCII TO HEX BYTE
CN_HTOIW   EQU      $3E46    CONVERT ASCII TO HEX WORD
CN_HTOIL   EQU      $3E4A    CONVERT ASCII TO HEX LONG
CN_BTOIB   EQU      $3EA4    CONVERT ASCII TO BINARY BYTE
CN_BTOIW   EQU      $3EA8    CONVERT ASCII TO BINARY WORD
CN_BTOIL   EQU      $3EAC    CONVERT ASCII TO BINARY LONG
CN_ITOD    EQU      $3EC4    CONVERT INTEGER TO ASCII
CN_ITOHL   EQU      $3F18    CONVERT HEX LONG TO ASCII
CN_ITOHW   EQU      $3F1C    CONVERT HEX WORD TO ASCII
CN_ITOHB   EQU      $3F20    CONVERT HEX BYTE TO ASCII
CN_ITOBL   EQU      $3F44    CONVERT BINARY LONG TO ASCII 
CN_ITOBW   EQU      $3F48    CONVERT BINARY WORD TO ASCII
CN_ITOBB   EQU      $3F4C    CONVERT BINARY BYTE TO ASCII
CN_FTOD    EQU      $3F66    CONVERT FLOATING POINT TO ASCII
CN_DATE    EQU      $40CE    GET DATE STRING
CN_DAY     EQU      $4122    GET DAY STRING
           EQU      $414E    DAYS OF THE WEEK & MONTHS OF THE YEAR

***********************************
* THE FLOATNG POINT MATHS PACKAGE *
***********************************

RI_SINGL   EQU      $4228    DO SINGLE MATHS OPERATION PRESERVING A6
RI_LIST    EQU      $4230    DO LIST OF MATHS OPERATIONS PRESERVING A6 
RI_EXEC    EQU      $423E    DO A MATHS OPERATION
RI_EXECB   EQU      $4246    DO A LIST OF MATHS OPERATIONS
RI_GET     EQU      $424C
RI_TEST    EQU      $4252
RI_LOAD    EQU      $425E
RI_STORE   EQU      $4270
RI_RESET   EQU      $4278
RI_MOVE    EQU      $427C
RI_EXIT    EQU      $428A
RI_JUMP    EQU      $4290
MATHTBL    EQU      $4298    TABLE OF OFFSETS FOR THE MATHS OPERATIONS
RI_SIN     EQU      $42C8
RI_COS     EQU      $42D0
RI_TRIG    EQU      $42DA
RI_TAN     EQU      $42F4
RI_COT     EQU      $42FC
RI_ACOS    EQU      $437C
RI_ASIN    EQU      $438A
RI_ACOT    EQU      $43B6
RI_ATAN    EQU      $43BE
RI_POWFP   EQU      $447A
RI_LOG10   EQU      $44C4
RI_LN      EQU      $44DE
ERR_OV_1   EQU      $4570
RI_EXP     EQU      $4576
RI_SQRT    EQU      $45C2
ERR_OV_2   EQU      $4784
RI_TRUNC   EQU      $47FA
RI_NORND   EQU      $480C
RI_NINT    EQU      $4830
RI_INT     EQU      $4834
RI_NLINT   EQU      $4840
ERR_OV_3   EQU      $484E
RI_LINT    EQU      $4852
RI_SUB     EQU      $48C4
RI_ADD     EQU      $48D2
RI_MULT    EQU      $4966
ERR_OV_4   EQU      $49FA
RI_DIV     EQU      $49FE
ERR_OV_5   EQU      $4A86
RI_ABS     EQU      $4A8A
RI_NEG     EQU      $4A90
RI_DUP     EQU      $4ACE

*****************************
* SUPERBASIC INITIALISATION *
*****************************

CHKPROMS   EQU      $4AF8    CHECK FOR PERIPHERAL ROMS
CONM4_0    EQU      $4BFA
CONM4_1    EQU      $4C06
CONM4_2    EQU      $4C12
CONM8_0    EQU      $4C1E
CONM8_1    EQU      $4C2A
CONM8_2    EQU      $4C36
CON_I0     EQU      $4C42
CON_I1     EQU      $4C4E
CON_I2     EQU      $4C5A
COPYRIGHT  EQU      $4C66
F1F2_MESS  EQU      $4C86
CA_RERIS   EQU      $4F46    RESERVE SPACE ON MATHS STACK 2
BV_CHRIX   EQU      $4F48    RESERVE SPACE ON MATHS STACK
CA_ALBTP   EQU      $4F4C    ALLOCATE SPACE ON BACKTRACK STACK
CA_ALTGP   EQU      $4F52    ALLOCATE SPACE ON TEMPORARY GRAPH STACK
CA_ALNTP   EQU      $4F58    ALLOCATE SPACE IN NAME TABLE
CA_ALRTP   EQU      $4F5E    ALLOCATE SPACE IN RETURN STACK
CA_ALBFP   EQU      $4F64    ALLOCATE SPACE IN BUFFER
CA_ALTKP   EQU      $4F68    ALLOCATE SPACE IN TOKEN TABLE
CA_ALNLP   EQU      $4F6C    ALLOCATE SPACE IN NAME LIST
CA_ALVVP   EQU      $4F70    ALLOCATE SPACE IN VARIABLE VALUES
CA_ALCHB   EQU      $4F74    ALLOCATE SPACE ON SUPERBASIC CHANNEL TABLE
CA_ALLNP   EQU      $4F78    ALLOCATE SPACE IN LINE NUMBER TABLE
CA_ALFFP   EQU      $4F7C    ALLOCATE SPACE IN PROGRAM FILE
CA_ALSBT   EQU      $4F7E    ALLOCATE SPACE IN SUPERBASIC TABLE
CA_ALSBS   EQU      $4F8A    ALLOCATE SPACE ON SUPERBASIC STACK
CA_REPFP   EQU      $5084    RECLAIM SPACE ABOVE PROGRAM FILE
CA_RENLP   EQU      $5088    RECLAIM SPACE ABOVE NAME LIST
CA_RENTP   EQU      $508C    RECLAIM SPACE ABOVE NAME TABLE
CA_REVVP   EQU      $5090    RECLAIM SPACE ABOVE VARIABLE VALUES
CA_RECHP   EQU      $5094    RECLAIM SPACE ABOVE CHANNEL TABLE
CA_RERTP   EQU      $5098    RECLAIM SPACE ABOVE RETURN STACK
CA_RESBT   EQU      $509A    RECLAIM SPACE ABOVE SUPERBASIC TABLE
CA_GTSTR   EQU      $5C40    GET STRINGS
CA_GTINT   EQU      $5C44    GET WORD INTEGERS
CA_GTFP    EQU      $5C48    GET FLOATING POINTS
CA_GTLIN   EQU      $5C4C    GET LONG INTEGERS       

*************************
* SUPERBASIC PROCEDURES *
*************************

BP_BAUD    EQU      $5F3C    SET BAUD RATE FOR SERIAL CHANNELS
BAUD_EXI   EQU      $5F50
BAUD_ERR   EQU      $5F52
BEEPTBL    EQU      $5F56
BEEP_EXI   EQU      $5F66
BEEP_END   EQU      $5F6C
BP_BEEP    EQU      $5F78    SWITCH SOUND ON OR OFF
SOUNDON    EQU      $5FE2
SOUNDOFF   EQU      $6002
BEEP_INS   EQU      $601A
BP_CALL    EQU      $6024    CALL MACHINE CODE ROUTINE
GETCHID    EQU      $6078    GET SUPER BASIC CHANNEL INFO FROM ID 
BP_CSIZE   EQU      $60FC    SET A NEW CHARACTER SIZE
BP_CURSO   EQU      $6120    POSITION CURSOR WITH GRAPHIC CO-ORDS
BP_AT      EQU      $612E    POSITION CURSOR @ CHARACTER CO-ORDS
BP_ADATE   EQU      $61E2    ADJUST SYSTEM CLOCK
BP_SDATE   EQU      $61F6    RESET SYSTEM CLOCK
EXIT_CLK   EQU      $6266
CLK_END    EQU      $6268
MONTHTBL   EQU      $626C
BP_READ    EQU      $62B8    ASSIGN DATA TO LIST OF VARIABLES
BP_EXEC    EQU      $62E6    LOAD MACHINE CODE PROGRAM & RETURN
BP_EXECW   EQU      $62EA    LOAD MACHINE CODE PROGRAM & WAIT
BP_RJOB    EQU      $634C
BP_LBYTE   EQU      $6358    LOAD DATA FILE INTO MEMORY
BP_SEXEC   EQU      $638E    SAVE EXECUTABLE PROGRAM
BP_SBYTE   EQU      $6392    SAVE AREA OF MEMORY TO DEVICE
DO_CLOSE   EQU      $63D4
BP_END     EQU      $63DA
BP_EXIT    EQU      $63DC
DOTRAP3    EQU      $63E8    
DO_TRAP3   EQU      $63EA
DOIOOPEN   EQU      $6408
DOTRAP2    EQU      $6410    
BP_DLETE   EQU      $642A    REMOVE A FILE FROM DEVICE DIRECTORY
BP_DIR     EQU      $6430    DISPLAY DEVICE DIRECTORY
BP_FORMT   EQU      $64BA    FORMAT DEVICE MEDIUM
BP_COPY    EQU      $64D4    COPY FILE
BP_COPYN   EQU      $64D8    COPY FILE MINUS HEADER
BP_CLOSE   EQU      $656C    CLOSE A CHANNEL
BP_OPEN    EQU      $658E    LINK CHANNEL WITH PHYSICAL DEVICE
BP_OPENI   EQU      $6592    OPEN EXISTING MICRODRIVE FILE FOR I/P
BP_OPENN   EQU      $6596    OPEN NEW MICRODRIVE FILE FOR O/P
BP_SAVE    EQU      $65B4    SAVE SUPERBASIC PROGRAM ON DEVICE
BP_FILL    EQU      $65CE    TURN GRAPHICS FILL ON OR OFF
BP_UNDER   EQU      $65EC    TURN UNDERLINE STATE ON OR OFF
BP_FLASH   EQU      $65F2    TURN FLASH STATE ON OR OFF
BP_OVER    EQU      $6608    SELECT OVER PRINTING TYPE
BP_SCALE   EQU      $663C    ALTER GRAPHICS SCALE FACTOR & ORIGIN
BP_POINT   EQU      $664E    DRAW POINT RELATIVE TO GRAPHICS ORIGIN
BP_RPOIN   EQU      $6652    DRAW POINT RELATIVE TO GRAPHICS CURSOR
BP_LINE    EQU      $6660    DRAW LINE RELATIVE TO GRAPHICS ORIGIN
BP_LINER   EQU      $6664    DRAW LINE RELATIVE TO GRAPHICS CURSOR
BP_ELLIP   EQU      $6678    DRAW ELLIPSE RELATIVE TO GRAPHICS ORIGIN
BP_ELPSR   EQU      $667C    DRAW ELLIPSE RELATIVE TO GRAPHICS CURSOR
BP_ARC     EQU      $66C8    DRAW ARC RELATIVE TO GRAPHICS ORIGIN
BP_ARC_R   EQU      $66CC    DRAW ARC RELATIVE TO GRAPHICS CURSOR
SB_INIT    EQU      $67E8
BP_INIT    EQU      $67EC    ADD SUPERBASIC PROCEDURES
PROCLIST   EQU      $6864    THE SUPERBASIC PROCEDURES & FUNCTIONS LIST
BP_LET     EQU      $6C12    RETURN PARAMETER VALUES
BP_DLINE   EQU      $6DB2    REMOVE SUPERBASIC PROGRAM LINES
BP_LIST    EQU      $6DD0    LIST PART OF PROGRAM ON CHANNEL
SB_CCBTA   EQU      $6E68    CONVERT PRE-COMPILED BASIC TO ASCII
BP_MODE    EQU      $6EE0    SET RESOLUTION OF SCREEN
BP_NET     EQU      $6EFC    SET NETWORK STATION NUMBER
BP_INK     EQU      $6F18    SET CURRENT INK COLOUR
BP_STRIP   EQU      $6F1C    SET CURRENT STRIP COLOUR
BP_PAPER   EQU      $6F20    SET CURRENT PAPER COLOUR
BP_CLS     EQU      $6F3E    CLEAR PART OR ALL OF WINDOW
BP_PAN     EQU      $6F42    PAN PART OR ALL OF SCREEN
BP_SCROL   EQU      $6F46    SCROLL PART OR ALL OF SCREEN
BP_PAUSE   EQU      $6F96    DELAY EXECUTING A SUPERBASIC PROGRAM
BP_POKE    EQU      $6FBA    PLACE BYTE IN MEMORY
BP_POKEW   EQU      $6FC2    PLACE WORD IN MEMORY
BP_POKEL   EQU      $6FC8    PLACE LONG WORD IN MEMORY
BP_INPUT   EQU      $6FF4    READ CHARACTER(S) FROM A CHANNEL
BP_PRINT   EQU      $6FF6    PRINT CHARACTER(S) TO A CHANNEL
BP_RNDMZ   EQU      $72E0    RESEED RANDOM NUMBER GENERATOR
BP_RECOL   EQU      $73BA    RECOLOUR INDIVIDUL PIXELS IN WINDOW
BP_EDIT    EQU      $73E4    EDIT LIST OF SUPERBASIC LINES
BP_AUTO    EQU      $73E8    GENERATE LINE NUMBERS AUTOMATICALLY
BP_RENUM   EQU      $7412    RENUMBER SUPER BASIC PROGRAM LINES
BP_CLEAR   EQU      $7666    CLEAR SUPERBASIC VARIABLES
BP_RUN     EQU      $7672    START PROGRAM EXECUTION
BP_MERGE   EQU      $7698    LOAD & MERGE A SUPERBASIC PROGRAM
BP_MRUN    EQU      $76A2    LOAD,MERGE & RUN A SUPERBASIC PROGRAM
BP_LOAD    EQU      $76C2    LOAD A SUPERBASIC PROGRAM
BP_LRUN    EQU      $76C8    LOAD & RUN A SUPERBASIC PROGRAM
BP_NEW     EQU      $76D4    CLEAR SUPERBASIC PROGRAM & VARIABLES
BP_STOP    EQU      $76D8    TERMINATE PROGRAM EXECUTION
BP_RETRY   EQU      $7714    RE-EXECUTE SUPERBASIC STATEMENT
BP_CONTI   EQU      $771E    CONTINUE HALTED SUPERBASIC PROGRAM
BP_TURNT   EQU      $7722    TURN TURTLE TO SPECIFIED ANGLE
BP_TURN    EQU      $772A    TURN TURTLE BY SPECIFIED ANGLE
BP_PENUP   EQU      $7764    SWITCH TURTLE GRAPHICS PEN OFF
BP_PENDO   EQU      $7768    SWITCH TURTLE GRAPHICS PEN ON
BP_MOVE    EQU      $7776    MOVE TURTLE IN CURRENT DIRECTION
BP_WIDTH   EQU      $77FA    SET DEFAULT WIDTH ON DEVICE
BP_WINDO   EQU      $7810    REDEFINE CHANNEL'S WINDOW
BP_BLOCK   EQU      $781E    FILL A BLOCK WITH COLOUR 
BP_BORDE   EQU      $7836    ADD A BORDER TO A WINDOW

************************
* SUPERBASIC FUNCTIONS *
************************

BF_ACOS    EQU      $78E6    RETURN ARC COSINE
BF_ACOT    EQU      $78EC    RETURN ARC COTANGENT
BF_ASIN    EQU      $78F2    RETURN ARC SINE
BF_ATAN    EQU      $78F8    RETURN ARC TANGENT
BF_COS     EQU      $78FE    RETURN COSINE 
BF_COT     EQU      $7904    RETURN COTANGENT
BF_EXP     EQU      $790A    RETURN EXPONENTIAL
BF_LN      EQU      $7910    RETURN NATURAL LOGARITHM
BF_LOG10   EQU      $7916    RETURN LOGARITHM TO BASE 10
BF_SIN     EQU      $791C    RETURN SINE
BF_SQRT    EQU      $7922    RETURN SQUARE ROOT
BF_TAN     EQU      $7928    RETURN TANGENT
BF_DEG     EQU      $792E    RETURN ANGLE IN DEGREES
BF_RAD     EQU      $7934    RETURN ANGLE IN RADIANS
BF_ABS     EQU      $7954    RETURN ABSOLUTE VALUE OF NUMBER
BF_RND     EQU      $797C    RETURN RANDOM NUMBER WITHIN LIMITS
BF_PI      EQU      $79D2    RETURN THE VALUE 3.141593
BF_INT     EQU      $79E0    RETURN INTEGER PART OF NUMBER
BF_PEEK    EQU      $79F8    RETURN VALUE OF BYTE IN MEMORY
BF_PEEKW   EQU      $7A00    RETURN SIGNED VALUE OF WORD IN MEMORY
BF_PEEKL   EQU      $7A0A    RETURN SIGNED VALUE OF LONG WORD IN MEMORY
BF_RESPR   EQU      $7A2C    RESERVE RESIDENT PROCEDURE SPACE
BF_BEEPI   EQU      $7A42    RETURN SOUND STATUS
BF_EOF     EQU      $7A4E    RETURN FILE OR DATA STATEMENT STATUS
BF_VER     EQU      $7A74    RETURN SUPERBASIC VERSION NUMBER
BF_INKEY   EQU      $7A84    RETURN CHARACTER FROM CHANNEL
BF_CHR     EQU      $7ADA    RETURN ASCII CHARACTER
BF_FILL    EQU      $7AEC    RETURN FILLED STRING
BF_LEN     EQU      $7B3C    RETURN LENGTH OF STRING
BF_CODE    EQU      $7B52    RETURN ASCII VALUE OF CHARACTER
BF_DIMN    EQU      $7B7A    RETURN MAXIMUM SIZE OF DIMENSION
BF_DATE    EQU      $7BCA    RETURN CURRENT DATE IN SECONDS
BF_KEYRW   EQU      $7BDC    RETURN STATE OF ROW OF KEYBOARD
BF_DATES   EQU      $7C22    RETURN CURRENT DATE & TIME
BF_DAY     EQU      $7C28    RETURN CURRENT DAY OF THE WEEK

**************************
* SUPERBASIC INTERPRETER *
**************************

           EQU      $7CDC    ! OPERATOR TABLE NO 1
           EQU      $7D1A    ! LOGICAL OPERATORS
SB_SNTX    EQU      $7FB6    BASIC SYNTAX ANALYSER
SB_CMPER   EQU      $8230    ERROR WHEN COMPILING
SB_FPCBL   EQU      $8296    FORMAT PRE-COMPILED BASIC LINE
SB_FSTFC   EQU      $833C    FIRST SYNTAX TABLE FOR COMMANDS
SB_SSTFE   EQU      $84D4    SECOND SYNTAX TABLE FOR EXPRESSIONS
           EQU      $8538    ! CONSTRUCTS,TOKENS
SB_SPFBL   EQU      $8674    STORE PRE-FORMATTED LINE
SB_GQLCI   EQU      $888E    GET QDOS LIST CHANNEL ID
TEHA_TBL   EQU      $88D6    TOKEN EXPANSION HANDLER ADDRESS TABLE
SB_ELNOT   EQU      $8A24    EXPAND LINE NUMBER TOKEN
SB_ENMTE   EQU      $8A7E    EXPAND NAME TABLE ENTRY
SB_ENAMT   EQU      $8A88    EXPAND NAME TOKEN
SB_ESTRT   EQU      $8ACE    EXPAND STRING TOKEN
SB_ETXTT   EQU      $8AD8    EXPAND TEXT TOKEN
SB_ESPCT   EQU      $8AE4    EXPAND SPACE TOKEN
SB_ESEPT   EQU      $8AF4    EXPAND SEPERATOR TOKEN
SB_EOPST   EQU      $8AFA    EXPAND OPERATION SYMBOL TOKEN
SB_EKEYT   EQU      $8B00    EXPAND KEYWORD TOKEN
SB_EMONT   EQU      $8B06    EXPAND MONO-OPERATION SYMBOL TOKEN
SB_ESYMT   EQU      $8B24    EXPAND SYMBOL TOKEN
           EQU      $8B60    ! OPERATOR TABLE NO 2
           EQU      $8F9E    ! "PROC/FN CLEARED" MESSAGE
           EQU      $92E2    ! "AT LINE" MESSAGE 
FONT_1     EQU      $A1C2    DEFAULT FONT FOR CHARACTERS 32 TO 127        
FONT_2     EQU      $A52E    DEFAULT FONT FOR CHARACTERS 127 TO 191

********************************
* LOW LEVEL DEVICE CONTROLLERS *
********************************

MD_FORMT   EQU      $A77A    FORMAT A MICRODRIVE MEDIUM
MD_SENDH   EQU      $A920    SEND THE SECTOR HEADER
MD_WRITE   EQU      $A92A    WRITE A MICRODRIVE SECTOR
MD_SECTR   EQU      $A9B4    READ A MICRODRIVE SECTOR HEADER
MD_READ    EQU      $A9D4    READ A MICRODRIVE SECTOR
MD_VERIN   EQU      $A9DA    VERIFY A MICRODRIVE SECTOR
           EQU      $AABE    DECODE IPC KEYPRESS
NT_RPCKT   EQU      $ABEE    RECEIVE A NETWORK PACKET
NT_SPCKT   EQU      $AC82    SEND A NETWORK PACKET
END_OF_ROM EQU      $ADB7    END OF ROM

******************************
* START ADDRESS OF EACH PART *
******************************

PART1      EQU      $0000
PART3      EQU      $089A
PART5      EQU      $115C
PART6      EQU      $18B4
PART9      EQU      $2B8C
PART13     EQU      $4228
PART14     EQU      $4AF8
PART15     EQU      $556A
PART16     EQU      $5F3C
PART19     EQU      $6DA2
PART50     EQU      $7C56
PART51     EQU      $9694
PART99     EQU      $A77A







                                  THE DISASSEMBLY

2. The Disassembly proper.

2.1 Initialisation and Exception Handlers.

2.1.1 Switch-on Or Reset Values.

      Computers are like people in more ways than one. When they are woken up
   after a good nights rest, they tend to be a bit confused and in a dishevelled
   condition. When power is first applied to a microprocessor, you can liken it
   then to an Army barracks.

    "The sun rises, the cock crows and the buggle sounds. The men quickly rise
     from there beds and get ready for another days hard graft. All of a sudden
     the Army Major walks in and informs the men that there is about to be an
     inspection by the General. The men start rushing around, bumping into each
     other as they try to clear up the mess. The General walks in and all of a
     sudden, at a deafening shout from the Major, the men stand by their beds
     and all is orderly..."

   In a microprocessor, the part of the Major is played by the Reset line which
   is connected to the chip. On power up, just like the men, the registers and
   other internal switches are in a random state. The hardware is designed in
   such a way that, on receipt of the RESET signal, The processor should take on
   an orderly set of values. In the 68000 range of microprocessors the reset
   signal causes the Program Counter and the Stack pointer to be set to the
   values stored in the first two long words in memory. Thereafter, it is up to
   the machine code stored at the location pointed to by the program counter to
   set up the rest of the machine in an orderly manner and ready for action.

   First of all then, we have the two reset vectors used by the CPU as the cold
   start or warmstart stack pointer and program counter respectively.

   These are the first two of a set of 256 long words taking up a 1K byte long
   table which defines the addresses of the different exception handlers used by
   the MC68000 series devices. All of these processors are upwards compatable so
   that in theory this listing could be assembled and run on an MC68020 based
   machine. For the QL however this would crash the machine as many of these
   vectors have meaningless values due to the presence of data and machine code
   instructions in this area.

0000 RESETSSP      DC.L     $30000                 ;reset value of stack pointer (temporary)
0004 RESETPC       DC.L     MEMTEST                ;reset value of program counter

2.1.2 System Exception Vectors.

   The following eight, long words, specify the addresses for the first of the
   redirectable exceptions. The first one, the bus error, is ignored as it would
   normally only occur if memory management hardware was in use as it signifies
   that an unsuccessfull memory read or memory write cycle was attempted.

0008 XVECTOR       DC.L     EXIT_HAN               ;bus error
                   DC.L     XBRANCH                ;address error
                   DC.L     XBRANCH + 2            ;illegal instruction
                   DC.L     XBRANCH + 4            ;division by zero
                   DC.L     XBRANCH + 6            ;chk instruction
                   DC.L     XBRANCH + 8            ;TRAPV instruction
                   DC.L     XBRANCH + 10           ;privilege violation error
                   DC.L     XBRANCH + 12           ;instruction trace

   This is a table of branch instructions used for the redirectable exceptions.
   The BSR.S instructions are used so that the exception handler can deduce the
   exception number from the return address and hence the RAM exception vector
   number to be used instead. This is the first case of code where it should not
   have been placed.

0028 XBRANCH       BSR.S    XHANDLER               ;normally line 1010 emulator vector
                   BSR.S    XHANDLER
                   BSR.S    XHANDLER               ;normally line 1111 emulator vector
                   BSR.S    XHANDLER
                   BSR.S    XHANDLER               ;normally unassigned vector
                   BSR.S    XHANDLER
                   BSR.S    XHANDLER               ;normally co-processor protocol violation

   Branch instructons for interrupts and user traps.

                   BSR.S    XHANDLER
                   BSR.S    XHANDLER               ;normally Format error
                   BSR.S    XHANDLER
                   BSR.S    XHANDLER               ;normally Uninitialised Interrupt vector
                   BSR.S    XHANDLER
                   BSR.S    XHANDLER               ;normally unassigned vector
                   BSR.S    XHANDLER
                   BSR.S    XHANDLER               ;normally unassigned vector
                   BSR.S    XHANDLER
                   BSR.S    XHANDLER               ;normally unassigned vector
                   BSR.S    XHANDLER
                   BSR.S    XHANDLER               ;normally unassigned vector
                   DC.W     0                      ;align the following code on a long word

   The following piece of code sits where the remaining unassigned vectors would
   sit but as these are un-defined even for the MC68020, it is relatively safe
   to put code here as the exceptions which use these vectors should never occur
   even with faulty hardware.

Ú------------------------------------------------------------------------------¿
³=XHANDLER        INITIAL EXCEPTION HANDLER                                    ³
------------------------------------------------------------------------------
³JOB:    To check for the presence of a RAM exception table, and if one is in  ³
³        use then a jump is made to redirect the exception. On return a check  ³
³        is made to see if it was an address error exception and if so the     ³
³        extra information normally placed on the supervisor stack, under this ³
³        condition, is compensated for prior to a normal return.               ³
------------------------------------------------------------------------------
³ENTRY:  none                                                                  ³
³                                                                              ³
³EXIT:   none                                                                  ³
³                                                                              ³
³ERRORS: none                                                                  ³
À------------------------------------------------------------------------------Ù

   In the following code, the value #2A is subtracted from the value on the
   top of the stack as this value is the same as the return address of the
   "BRS.S" instruction used to pass control to this routine as a result of an
   address error exception.

0050 XHANDLER      BRA.L    CHKRAMEX               ;check for the RAM exception table
0054 NORAMEX       SUBI.L   #$2A,(A7)+             ;was it an address error exception ?
                   BNE.S    IGNORE                 ;exit normally if not, otherwise step
005C EXIT_HAN      ADDQ.W   #8,A7                  ;passed extra information placed on stack
005E IGNORE        RTE                             ;by the address error exception type

2.1.3 Interrupt Vectors.

   Only two of the interrupt exceptions are usable. The main system one which is
   interrupt level two, and of course the non-maskable one, interrupt level 7.
   The system interrupt is used to control all of the real time aspects of the
   machine such as the multitasking and peripheral communications facilities.

0060 IVECTORS      DC.L     IGNORE                 ;spurious interrupt vector
                   DC.L     IGNORE                 ;interrupt level 1 vector
                   DC.L     SYSINT                 ;system interrupt vector (interrupt level 2)
                   DC.L     IGNORE                 ;interrupt level 3 vector
                   DC.L     IGNORE                 ;interrupt level 4 vector
                   DC.L     IGNORE                 ;interrupt level 5 vector
                   DC.L     IGNORE                 ;interrupt level 6 vector
                   DC.L     XBRANCH + 14           ;user interrupt vector (non-maskable)

2.1.4 Trap Vectors.

   The first five TRAPS only are used for QDOS with the remaining 11 TRAPS free
   for use by user routines, provided that they have a suitable table of RAM
   exception vectors in force.

0080 TVECTORS      DC.L     ENTER_SM               ;TRAP #0 enter supervisor mode
                   DC.L     MT_TRAP1               ;TRAP #1 general memory management
                   DC.L     IO_TRAP2               ;TRAP #2 I/O device allocation
                   DC.L     IO_TRAP3               ;TRAP #3 actual I/O and graphics
                   DC.L     SB_TRAP4               ;TRAP #4 basic interpreter
                   DC.L     XBRANCH + 16           ;TRAP #5 (user TRAP vectors)
                   DC.L     XBRANCH + 18           ;TRAP #6
                   DC.L     XBRANCH + 20           ;TRAP #7
                   DC.L     XBRANCH + 22           ;TRAP #8
                   DC.L     XBRANCH + 24           ;TRAP #9
                   DC.L     XBRANCH + 26           ;TRAP #10
                   DC.L     XBRANCH + 28           ;TRAP #11
                   DC.L     XBRANCH + 30           ;TRAP #12
                   DC.L     XBRANCH + 32           ;TRAP #13
                   DC.L     XBRANCH + 34           ;TRAP #14
                   DC.L     XBRANCH + 36           ;TRAP #15

2.1.5 QDOS System Vectors.

   The following word sized vectors are used to access many of the QDOS system
   utilities not covered by TRAPs #1,2 and 3 plus some which are. These all sit
   in locations which would normally contain the floating point co-processor and
   paged memory management co-processor exception vectors. Unfortunately the QL
   contains neither of these "SEXY" devices and so it is reasonably safe to put
   word sized data here.

00C0 MM.ALCHP      DC.W     MM_ALCHP               ;allocate common heap space
00C2 MM.RECHP      DC.W     MM_RECHP               ;release common heap space
00C4 UT.WINDW      DC.W     UT_WINDW               ;create window channel
00C6 UT.CON        DC.W     UT_CON                 ;create console channel
00C8 UT.SCR        DC.W     UT_SCR                 ;create screen channel
00CA UT.ERR0       DC.W     UT_ERR0                ;send error message to channel 0
00CC UT.ERR        DC.W     UT_ERR                 ;send error message to channel
00CE UT.MINT       DC.W     UT_MINT                ;print decimal number on channel
00D0 UT.MTEXT      DC.W     UT_MTEXT               ;send message to channel
00D2 UT.LINK       DC.W     UT_LINK                ;link item into list
00D4 UT.UNLNK      DC.W     UT_UNLNK               ;unlink item from list
                   DC.W     $0000                  ;not implemented
00D8 MM.ALLOC      DC.W     MM_ALLOC               ;allocate heap space
00DA MM.LNKFR      DC.W     MM_LNKFR               ;link free space back into heap
00DC IO.QSET       DC.W     IO_QSET                ;set up a queue header
00DE IO.QTEST      DC.W     IO_QTEST               ;test queue status
00E0 IO.QIN        DC.W     IO_QIN                 ;put byte into queue
00E2 IO.QOUT       DC.W     IO_QOUT                ;get byte from queue
00E4 IO.QEOF       DC.W     IO_QEOF                ;put EOF marker in queue
00E6 UT.CSTR       DC.W     UT_CSTR                ;string comparison
00E8 IO.SERQ       DC.W     IO_SERQ                ;direct queue handling
00EA IO.SERIO      DC.W     IO_SERIO               ;general I/O handling
00EC CN.DATE       DC.W     CN_DATE                ;get date string
00EE CN.DAY        DC.W     CN_DAY                 ;get day string
00F0 CN.FTOD       DC.W     CN_FTOD                ;convert floating point to ascii
00F2 CN.ITOD       DC.W     CN_ITOD                ;convert integer to ascii
00F4 CN.ITOBB      DC.W     CN_ITOBB               ;convert binary byte to ascii
00F6 CN.ITOBW      DC.W     CN_ITOBW               ;convert binary word to ascii
00F8 CN.ITOBL      DC.W     CN_ITOBL               ;convert binary long to ascii
00FA CN.ITOHB      DC.W     CN_ITOHB               ;convert hex byte to ascii
00FC CN.ITOHW      DC.W     CN_ITOHW               ;convert hex word to ascii
00FE CN.ITOHL      DC.W     CN_ITOHL               ;convert hex long to ascii
0100 CN.DTOF       DC.W     CN_DTOF                ;convert ascii to floating point
0102 CN.DTOI       DC.W     CN_DTOI                ;convert ascii to integer
0104 CN.BTOIB      DC.W     CN_BTOIB               ;convert ascii to binary byte
0106 CN.BTOIW      DC.W     CN_BTOIW               ;convert ascii to binary word
0108 CN.BTOIL      DC.W     CN_BTOIL               ;convert ascii to binary long
010A CN.HTOIB      DC.W     CN_HTOIB               ;convert ascii to hex byte
010C CN.HTOIW      DC.W     CN_HTOIW               ;convert ascii to hex word
010E CN.HTOIL      DC.W     CN_HTOIL               ;convert ascii to hex long
0110 BP.INIT       DC.W     BP_INIT                ;add SuperBASIC resident procedures
0112 CA.GTINT      DC.W     CA_GTINT               ;get word integers
0114 CA.GTFP       DC.W     CA_GTFP                ;get floating points
0116 CA.GTSTR      DC.W     CA_GTSTR               ;get strings
0118 CA.GTLIN      DC.W     CA_GTLIN               ;get long integers
011A BV.CHRIX      DC.W     BV_CHRIX               ;reserve space on maths stack
011C RI.EXEC       DC.W     RI_EXEC                ;do a maths operation
011E RI.EXECB      DC.W     RI_EXECB               ;do a list of maths operations
0120 BP.LET        DC.W     BP_LET                 ;return parameter values
0122 IO.NAME       DC.W     IO_NAME                ;decode device name
0124 MD.READ       DC.W     MD_READ  - $4000       ;read a microdrive sector
0126 MD.WRITE      DC.W     MD_WRITE - $4000       ;write a microdrive sector
0128 MD.VERIN      DC.W     MD_VERIN - $4000       ;verify a microdrive sector
012A MD.SECTR      DC.W     MD_SECTR - $4000       ;read a microdrive sector header

   These vectors are for the SuperBASIC parser and are not guaranteed for any
   subsequent versions of QDOS.

012C SB.SNTX       DC.W     SB_SNTX  - $4000       ;basic syntax analyser
012E SB.FSTFC      DC.W     SB_FSTFC - $4000       ;first syntax table for commands
0130 SB.SSTFE      DC.W     SB_SSTFE - $4000       ;second syntax table for expressions
0132 SB.FPCBL      DC.W     SB_FPCBL - $4000       ;format pre-compiled basic line
0134 SB.CMPER      DC.W     SB_CMPER - $4000       ;error when compiling
0136 SB.SPFBL      DC.W     SB_SPFBL - $4000       ;store pre-formated line
0138 SB.CCBTA      DC.W     SB_CCBTA - $4000       ;convert pre-compiled basic to ascii

2.1.6 Check For Ram Exception Table.

   The following information is placed on the supervisor stack when an exception
   occurs:-

    1) One long word containing the old value of the program counter.
    2) One word containing the old status register.
    3) An additional three words if it was a bus or address error.
    4) The return address for the BRS.S instruction.

   RAM exception tables are used so that several of the system exceptions can be
   re-directed to user defined routines to handle them. There can be only one
   exception table for each job in the system and normally a job will use its
   creators's RAM exception table. The exception table itself should contain the
   following long word addresses:-

    ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄ¿
    ³        Exception type hander         ³ Offset ³
    ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄ´
    ³ address error handler address        ³  $00   ³
    ³ illegal instruction handler address  ³  $04   ³
    ³ division by zero handler address     ³  $08   ³
    ³ CHK instruction handler address      ³  $0C   ³
    ³ TRAPV instruction handler address    ³  $10   ³
    ³ Privilege violation handler address  ³  $14   ³
    ³ Trace exception handler address      ³  $18   ³
    ³ Interrupt level 7 handler address    ³  $1C   ³
    ³ TRAP #5 handler address              ³  $20   ³
    ³ TRAP #6 handler address              ³  $24   ³
    ³ TRAP #7 handler address              ³  $28   ³
    ³ TRAP #8 handler address              ³  $2C   ³
    ³ TRAP #9 handler address              ³  $30   ³
    ³ TRAP #10 handler address             ³  $34   ³
    ³ TRAP #11 handler address             ³  $38   ³
    ³ TRAP #12 handler address             ³  $3C   ³
    ³ TRAP #13 handler address             ³  $40   ³
    ³ TRAP #14 handler address             ³  $44   ³
    ³ TRAP #15 handler address             ³  $48   ³
    ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÙ

   RAM exception tables are really intended for programs such as Monitors as the
   errors which would cause them to occur can rarely be recovered from with out
   some sort of debugging facility being used when the error occurs.

   The system variable SV.TRAPV is used to store the start address of the table
   of exception vectors used by the current job. The address stored however is
   for the "fictitious" start as the true start is given by this address plus
   #A8 since the first vector is used for a vector number of #2A which is the
   address error vector number. A similar variable, JB.TRAPV, is used in each
   job control block to store the address of the exception table for that job.

Ú------------------------------------------------------------------------------¿
³=CHKRAMEX        CHECK FOR RAM EXCEPTION TABLE                                ³
------------------------------------------------------------------------------
³JOB:    To check for the presence of a RAM exception table, and if one is in  ³
³        use then to redirect the exception according to the exception table.  ³
------------------------------------------------------------------------------
³ENTRY:  none                                                                  ³
³                                                                              ³
³EXIT:   none                                                                  ³
³                                                                              ³
³ERRORS: none                                                                  ³
À------------------------------------------------------------------------------Ù

013A CHKRAMEX      TST.L    SV_TRAPV               ;is there a RAM exception table in use ?
                   BEQ      NORAMEX                ;return if not
                   MOVE.L   A6,-(A7)               ;save A6 temporarily
                   MOVEA.W  6(A7),A6               ;get vector number word from return address
                   ADDA.W   A6,A6                  ;form long word offset into table from word
                   ADDA.L   SV_TRAPV,A6            ;and add to the "start" of the RAM table
                   MOVE.L   (A6),4(A7)             ;place "return" address above saved register
                   MOVEA.L  (A7)+,A6               ;and restore value of A6
                   RTS                             ;"return" to the new exception handler

2.1.7 Dynamic Stop On Memory Test Failure.

Ú------------------------------------------------------------------------------¿
³=BADRAM          DYNAMIC STOP ON MEMORY TEST FAILURE                          ³
------------------------------------------------------------------------------
³JOB:    To signal visually the reason for the memory test failure.            ³
------------------------------------------------------------------------------
³ENTRY:  none                                                                  ³
³                                                                              ³
³EXIT:   none                                                                  ³
³                                                                              ³
³ERRORS: none                                                                  ³
À------------------------------------------------------------------------------Ù

   This routine constitutes an endless loop and is called if the memory test
   fails for whatever reason. It never terminates as the CPU is in supervisor
   mode and interrupts are disabled. The main result of this is that the screen
   clears and the machine locks up. The screen will clear to white if the ram
   test fails during the first pass due to a single bit read or write error.
   The screen will clear to green if the ram test fails as a result of a RAM
   refresh error during the second pass. The screen clears to these values as
   the least significant byte of D7 is set to #FFFF on the first pass and to
   #FF00 on the second pass. When the screen is in mode 4, these values, if put
   into each screen word, will result in the above colours appearing. The screen
   is put into mode 4 at the start of each pass.

015A BADRAM        MOVEA.L  A3,A5                  ;A5 points at beginning of screen RAM
015C BADRAM2       MOVE.W   D7,(A5)+               ;fill screen with contents of D7 register
                   CMPA.L   #SV_IDENT,A5           ;end of screen ?
                   BNE.S    BADRAM2                ;continue if not
                   BRA.S    BADRAM                 ;and fill screen again anyway even if it is

2.1.8 Comprehensive main RAM and expansion RAM memory test.

Ú------------------------------------------------------------------------------¿
³=MEMTEST         COMPREHENSIVE MAIN RAM & EXPANSION RAM MEMORY TEST           ³
------------------------------------------------------------------------------
³JOB:    To check for the presence of expansion RAM and to test the RAM found  ³
³        initially for read and write errors, and then the refresh circuitry.  ³
------------------------------------------------------------------------------
³ENTRY:  none                                                                  ³
³                                                                              ³
³EXIT:   none                                                                  ³
³                                                                              ³
³ERRORS: none                                                                  ³
À------------------------------------------------------------------------------Ù

    First of all check for the presence of any expansion RAM and set A4 to the
    address of the last byte of expansion RAM + 1. The test is a very simple one
    and this is why expansion RAM has to be added in 64K blocks. If this was not
    done correctly then the memory test which follows would fail as soon as it
    stepped over the break in memory within a 64K block.

    NOTE here that the memory could in fact extend all the way up to the 1Mbyte
    addressing limit without causing any failures. The Miracle Technology TRUMP
    CARD probably uses this fact and places RAM in the peripheral ROM part of
    the memory map which lies immediately after the normal expansion RAM slot.
    It will therefore be found by the memory test.

0168 MEMTEST       MOVEA.L  #$40000,A1             ;A1 points at expansion RAM area
                   MOVEA.L  A1,A4                  ;copy address to A4
0170 CHKRAM1       MOVE.L   A4,(A4)                ;copy data to first long word
                   CMPA.L   (A4),A4                ;memory present ?
                   BNE.S    CHKRAM2                ;jump forward if not
                   CMPA.L   (A1),A1                ;testing first 64k ?
                   BNE.S    CHKRAM2                ;branch if not
                   ADDA.L   #65536,A4              ;move to next 64k block
                   BRA.S    CHKRAM1

   Now check the entire physical RAM two times. The first test checks for any
   dubious single bit read and write errors and leaves the entire RAM containing
   random data from the ROM. The second and final test checks this data to see
   if the  refresh circuitry is working correctly. Since it takes an appreciable
   time for each pass, the data would have changed if it wasn't. If the data was
   preserved then every location in memory is cleared.

0182 CHKRAM2       MOVEQ    #0,D0                  ;clear D0 to all zero's
                   MOVEQ    #-1,D1                 ;then D1 to all one's
                   MOVEQ    #-1,D7                 ;signal "pass 1"
0188 TESTRAM       LEA      SCREEN,A3              ;A3 points at bottom of physical RAM
                   MOVEA.L  A3,A5                  ;copy pointer
                   MOVEA.L  D0,A1                  ;clear A1 for use as a ROM counter
                   LEA      $1FE4(A1),A2           ;A2 points at ROM for part of RAM test
                   SF       -$7F9D(A3)             ;zero MC_STAT (screen #0,on,mode 4)
019A NXTLONG       CMPA.L   A1,A2                  ;end of ROM data ?
                   BNE.S    ROM_END                ;jump forward if not
                   MOVEA.L  D0,A1                  ;otherwise reset count
01A0 ROM_END       MOVE.L   (A1)+,D2               ;get next long word of ROM as data
                   TST.B    D7                     ;second pass ?
                   BEQ.S    TESTED                 ;test refresh if so
                   MOVE.L   D0,(A5)                ;set long word to all zero's
                   CMP.L    (A5),D0                ;RAM ok ?
                   BNE.S    BADRAM                 ;exit if not
                   MOVE.L   D1,(A5)                ;set same long word to all one's
                   CMP.L    (A5),D1                ;RAM ok ?
                   BNE.S    BADRAM                 ;exit if not
                   MOVE.L   D2,(A5)                ;finally set to random data and point at
                   CMP.L    (A5)+,D2               ;next long word, RAM ok ?
                   BNE.S    BADRAM                 ;exit if not
                   CMPA.L   A5,A4                  ;end of physical RAM reached ?
                   BNE.S    NXTLONG                ;check next long word if not

   The next instruction has the following affect on the D7 register. During the
   first pass, D7 goes from #FFFFFFFF to #FFFFFF00. During the second pass, D7
   goes from #FFFFFF00 to #FFFF0000. Placing the least significant word of this
   value in screen memory will cause a different visual affect depending on
   which pass the test is in. This is used to signify to an operator which type
   of memory defect the test has highlighted.

                   LSL.W    #8,D7                  ;signal "pass 2"
                   BRA.S    TESTRAM                ;reset registers ready for pass two

   The RAM test is on its second pass so test the RAM refresh.

01C0 TESTED        CMP.L    (A5),D2                ;long word data preserved ?
                   BNE.S    BADRAM                 ;exit if not
                   CLR.L    (A5)+                  ;clear it and point at next long word
                   CMPA.L   A4,A5                  ;top of memory ?
                   BNE.S    NXTLONG                ;test next long word if not

   All of memory has been tested and found to be ok so set up some of the I/O
   registers.

01CA SETIO         MOVEA.L  #CHKPROMS,A1           ;routine to check for peripheral roms
                   LEA      SV_IDENT,A6            ;A6 points at start of system variables
                   LEA      SV.STACT(A6),A7        ;set SSP to highest allowed position
                   LEA      PC_MCTRL,A3            ;A3 points at middle of I/O ports

   set master chip status register to turn screen #0 on, in mode 8.

                   MOVE.B   #%00001000,MC.STAT - 32(A3)

   and clear the transmit control register after reading it

                   SF       PC.TCTRL - 32(A3)

   then send the value %00000110 to the microdrive control register followed by
   the value %00011111 to the interrupt register and ending with zero to the
   transmit register.

                   MOVE.L   #$061F0000,PC.MCTRL - 32(A3)

   write to the interrupt register again

                   MOVE.B   #%01111111,PC.INTR - 32(A3)

   and presumably tell the IPC that the main processor is just fine!

                   MOVE.B   #%00000001,PC.IPCWR - 32(A3)

   Set up most of the system variables.

01FC SYSVAR        MOVE.B   #$C0,SV.PCINT(A6)      ;default value for interrupt acknowledgement
                   JSR      MD_DESEL(PC)           ;switch off all the microdrive motors
                   MOVE.W   #$D254,(A6)            ;standard identification word for variables
                   MOVE.L   A5,SV.RAMT(A6)         ;top of physical memory + 1
                   SUBA.L   #0,A5                  ;who knows ?

   The resident procedure area, RESPR, is used to store any permanent pieces of
   machine code which may be required. This could be resident procedures used to
   extend SuperBASIC or new device drivers such as SPEEDSCREEN or it could be a
   floppy disc or hard disc device driver linked into the I/O subsystem, IOSS.

   It can also be used to store any other bits of machine code which may be
   required but note that the area can only be contracted in one step and that
   this is a dubious process.

   The transient program area,TRNSP is used to hold executable code and possibly
   data. It expands to make room for these and generally will only contract in
   those cases where either no jobs are running or a contiguous block of memory
   at the SuperBASIC end has been found by the memory manager.

                   MOVE.L   A5,SV.RESPR(A6)        ;start of resident procedure area
                   MOVE.L   A5,SV.TRNSP(A6)        ;start of transient procedure area
                   MOVE.L   SV.RAMT(A6),D0         ;D0 points top of RAM + 1
                   SUB.L    A6,D0                  ;subtract start of system variables
                   LSR.L    #6,D0                  ;and divide by 64

   The spare memory is used as slave blocks with each block being 512 bytes in
   size. The slave block table occurs immediately after the supervisor stack and
   consists of one 8 byte entry for every possible slave block which could be
   used. Available memory is considered to start at $28000 and so the table size
   is given by the formula:-

    size = (SV.RAMT-SV.IDENT)/512 * 8 bytes
              = memory/64

   which gives $600 bytes on an un-expanded machine and $2600 bytes on a fully
   expanded machine. Slave blocks are used to store as many copies of microdrive
   sectors for the current microdrive as possible to speed up the access times
   for microdrive operations.

                   MOVEA.L  A7,A3                  ;A3 points at bottom of supervisor stack
                   LEA      SV.BTPNT(A6),A4        ;A4 points at start of system table pointers
                   BSR.S    BLOCKINF               ;set up SV_BTPNT to SV_BTTOP
                   LSR.L    #1,D0                  ;D0 = memory/128
                   ADD.L    D0,SV.BTPNT(A6)        ;set current entry to the middle one
                   LSR.L    #2,D0                  ;D0 = memory/512
                   ADDI.L   #32,D0                 ;D0 = memory/512 + 32

   The job table comes next and consists of one long word pointer to the job
   header in the transient program area for each job. Again the size of the
   table is dictated by the amount of memory available and is given by:-

    size = free memory / 512 + 32 bytes

   which gives $E0 bytes on an un-expanded machine (128K) and $4E0 bytes on a
   fully expanded one (640K). The maximum number of jobs allowed however is only
   120 so the maximum size of the table is $1E0 or 480 bytes.

                   CMPI.W   #480,D0                ;table length ok ?
                   BLS.S    LENGTHOK               ;jump forward if not too long
                   MOVE.W   #480,D0                ;otherwise set to maximum length
0244 LENGTHOK      BSR.S    BLOCKINF               ;set up SV_JBPNT to SV_JBTOP

   The final table created is the channel table which is set to three times the
   size of the job table and consists of a long word pointer to the channel
   definition block in the common heap for each open channel. It is three times
   the size of the job table since each job must be able to have at least three
   channels open to it. One channel for the error stream, one for I/O stream and
   one for listings. In normal use most jobs will use the default channels.

                   MULU     #3,D0                  ;D0 = job table size * 3
                   BSR.S    BLOCKINF               ;set up SV_CHPNT to SV_CHTOP
                   BRA.S    L0025A                 ;jump over following routine

   Short routine to set up the three pointers for the system tables.

024E BLOCKINF      MOVE.L   A3,(A4)+               ;set up variable for current entry
                   MOVE.L   A3,(A4)+               ;set up variable for table base
                   ADDA.W   D0,A3                  ;add length of area to base
                   MOVE.L   A3,(A4)+               ;set up variable for end of table
                   ADDQ.W   #4,A4                  ;jump over the following two words
                   RTS

   A3 now points at the end of the channel table. Because of the presence of the
   system variables, the supervisor stack and the system tables, the first few
   entries in the slave block table will be unused. The last entry will also be
   unused because of SuperBASIC. So calculate the first entry that is available
   and set this and all the entries after this to "available".

025A L0025A        MOVE.L   A3,D0                  ;D0 points at the end of the channel table
                   SUB.L    A6,D0                  ;then the amount of memory used so far
                   LSR.L    #6,D0                  ;divide it by 64 to give entry number in
                   MOVEA.L  D0,A4                  ;the slave block table and then add it
                   ADDA.L   A7,A4                  ;to the start of the table
                   MOVEA.L  SV.BTTOP(A6),A3        ;A3 points at end of slave block table
                   MOVE.W   #512,D1                ;now compensate for the space used by
                   LSR.W    #6,D1                  ;SuperBASIC at the top of RAM
                   SUBA.W   D1,A3                  ;A3 = end of table - 8

   Set the status byte, BT.STAT in each entry to "available". Note that memory
   is cleared above and that this means that the status byte will normally read
   "not available to OS".

                   MOVEQ    #%00000001,D0
0272 L00272        MOVE.B   D0,(A4)                ;signal "available to OS"
                   ADDQ.W   #8,A4                  ;get address of next entry
                   CMPA.L   A3,A4                  ;end of slave block table reached ?
                   BLT.S    L00272                 ;process next entry if not

   Now clear all the entries in the job and channel tables to "unused".

                   MOVEA.L  SV.JBBAS(A6),A4        ;A4 points at start of job table
                   MOVEA.L  SV.CHTOP(A6),A3        ;A3 points at end of channel table

                   MOVEQ    #-1,D0                 ;set D0 to "no entry"
0284 CLEARTAB      MOVE.B   D0,(A4)                ;set top byte of each entry
                   ADDQ.W   #4,A4                  ;A4 points at top byte of next entry
                   CMPA.L   A3,A4                  ;end of channel table reached ?
                   BLT.S    CLEARTAB               ;set next entry if not

   Now set the pointers for the common heap , slave blocks and SuperBASIC. The
   common heap is a general workspace area and is normally used for holding
   channel definition blocks and other data tables. It is allocated in multiples
   of eight bytes and each block is preceded by a four long word header which
   contains the following information:-

    1.     CH.LEN   length of the block including the header
    2.     CH.DRIVR either the address of the I/O driver to free the block or
           CH.NEXT  a relative pointer to the next free block if unused.
    3.     CH.OWNER channel ID (See under CHKCHID) of the owner job
    4.     CH.RFLAG the release flag which is the address of a byte to be set
                    when the space is released

   This is the minimum amount of information required to reclaim the block when
   it is no longer required which normally happens when the owner job is removed
   from the system.

                   MOVE.L   A3,SV.CHEAP(A6)        ;start of common heap
                   MOVE.L   A3,SV.FREE(A6)         ;start of free memory (slave blocks)
                   MOVEA.L  SV.RESPR(A6),A4        ;A4 points at resident procedure area
                   LEA      -512(A4),A4            ;then 512 bytes below that for
                   MOVE.L   A4,SV.BASIC(A6)        ;start of SuperBASIC area

   Now do the pointers to the system linked lists except for the pointer to the
   external interrupt list, SV.I2LST, which is already set to "end of list" by
   the action of the memory test in clearing the memory.

                   LEA      POLLTASK(PC),A5
                   MOVE.L   A5,SV.PLIST(A6)        ;start of polled tasks list
                   LEA      SCHDTASK(PC),A5
                   MOVE.L   A5,SV.SHLST(A6)        ;start of scheduler tasks list
                   LEA      SER_LB(PC),A5
                   MOVE.L   A5,SV.DRLST(A6)        ;start of simple device driver list
                   LEA      MDV_LB(PC),A5
                   MOVE.L   A5,SV.DDLST(A6)        ;start of directory driver list

   Next set the various remaining miscellaneous system variables.

                   ADDQ.B   #1,SV.NETNR(A6)        ;set network station number to 1
                   ADDQ.B   #8,SV.MCSTA(A6)        ;copy of MC_STAT
                   ADDQ.B   #1,SV.TMODE(A6)        ;set baud rate to 9600
                   ADDQ.W   #1,SV.TIMOV(A6)        ;timeout for serial output to 1
                   MOVE.W   #30,SV.ARDEL(A6)       ;key repeat delay in ms
                   ADDQ.W   #2,SV.ARFRQ(A6)        ;key repeat frequency
                   ADDQ.W   #3,SV.CQCH(A6)         ;and finally change keyboard queue code

   Finally set up the job table for SuperBASIC and its area. The SuperBASIC area
   is rather unusual in that every system variable or other data item that it
   contains is accessed relative to A6 which always points to the base of the
   SuperBASIC system variables which occur after the normal $68 byte job header
   (pointed to by the first entry in the job table). The whole area will move
   down when space in the transient program is allocated and when more space is
   required inside the area itself. It will only move up if the resident
   procedure area is released as areas which were used for jobs are normally
   linked together as free space when finished rather than totally reclaimed.

                   MOVEA.L  SV.JBBAS(A6),A4        ;A4 points at start of job table
                   MOVE.L   A4,SV.JBPNT(A6)        ;current job is job 0 (SuperBASIC)
                   MOVEA.L  SV.TRNSP(A6),A3        ;A3 points at transient program area
                   CLR.L    -(A3)                  ;push a zero onto SuperBASIC's stack
                   MOVEA.L  SV.BASIC(A6),A0        ;A0 points at start of SuperBASIC area
                   MOVE.L   A0,(A4)                ;set first entry to SuperBASIC
                   MOVE.B   #32,JB.PRINC(A0)       ;set job's initial priority
                   MOVE.L   A3,USP                 ;and user stack to end of the area
                   LEA      JB.END(A0),A6          ;A6 points at start of SuperBASIC area
                   MOVEA.L  A3,A5                  ;copy of USP
                   SUBA.L   A6,A5                  ;A5 = top of stack (relative to A6)

   The system is now potentially able to run a job if one was present since
   SuperBASIC has yet to be initialised and jobs can only be started by issueing
   a suitable command within SuperBASIC.

   Note that since the memory test clears all of memory, the two relative free
   space pointers, SV.TRNFR and SV.CHPFR, are set to "non existent". There is
   also no current keyboard queue, no RAM exception vector table and no Capslock
   subroutine. No pointers for the filing system have been set up either as
   peripheral ROM's may want to set this up themselves if say a disc drive or
   winchester was attached. All that remains to be done now is for a check for
   the above ROMS to be carried out before setting up the SuperBASIC system
   variables, and any resident procedures to be added if necessary prior to
   adding the ROM resident ones.

                   MOVE.W   #0,SR                  ;enter user mode and enable interrupts
                   JMP      (A1)                   ;jump to routine to check for roms

2.1.9 Trap handlers for TRAP'S #0,#1,#2,#3 and #4.

Ú------------------------------------------------------------------------------¿
³=ENTER_SM        ENTER CPU SUPERVISOR MODE                                    ³
³=MT_TRAP1        MEMORY MANAGEMENT, JOB CONTROL AND SYSTEM HOUSEKEEPING       ³
³=IO_TRAP2        I/O DEVICE ALLOCATION                                        ³
³=IO_TRAP3        ACTUAL I/O, FILE HANDLING AND GRAPHICS                       ³
³=SB_TRAP4        USE ABSOLUTE INSTEAD OF RELATIVE VALUES IN THE NEXT TRAP     ³
------------------------------------------------------------------------------
³JOB:    To check for the presence of a RAM exception table, and if one is in  ³
³        use then to redirect the exception according to the exception table.  ³
------------------------------------------------------------------------------
³ENTRY:  none                                                                  ³
³                                                                              ³
³EXIT:   none                                                                  ³
³                                                                              ³
³ERRORS: none                                                                  ³
À------------------------------------------------------------------------------Ù

   These are the system TRAP's which are used for accessing all of the standard
   QDOS facilities. Several are also pointed to by the word vector table which
   starts at $000C0. This method of access ensures that any future versions of
   the ROM will be upwards compatible with code written using them. The function
   required is defined by the value of D0 and any parameters required are passed
   in registers D1 to D3 and A0 to A3 with any errors signalled by the value of
   D0 on exit (see the Appendix).

0308 ENTER_SM      ADDQ.W   #2,A7                  ;jump over saved CCR and return still
                   RTS                             ;in supervisor mode

030C MT_TRAP1      BSR.S    SETUPTRA               ;set up registers for the TRAP handler
                   BRA      CHKTRP1                ;and decode the function required

0312 IO_TRAP2      BSR.S    SETUPTRA               ;set up registers for the TRAP handler
                   BRA      CHKTRP2                ;and decode the function required

0318 IO_TRAP3      BSR.S    SETUPTRA               ;set up registers for the TRAP handler
                   BRA      CHKTRP3                ;and decode the function required

031E SB_TRAP4      BSR.S    SETUPTRA               ;set up registers for the next TRAP #3
                   BRA      CHKTRP4                ;and set the "Absolute value" bit

   Set up the registers and stack for all off the individual TRAP handlers.

0324 SETUPTRA      SUBQ.W   #8,A7                  ;create block of two long words
                   MOVE.L   8(A7),-(A7)            ;restack old return address then
                   MOVEM.L  D7/A5-6,4(A7)          ;save SuperBASIC's registers inside
                   MOVEA.L  #SV_IDENT,A6           ;A6 points at the QDOS system variables
                   LEA      4(A7),A5               ;and A5 points at the saved registers
                   MOVEQ    #%01111111,D7          ;mask for bottom 7 bits
                   AND.L    D7,D0                  ;prepare D0 as a long word offset
                   RTS

2.1.10 The interrupt handlers.

Ú------------------------------------------------------------------------------¿
³=SYSINT          SYSTEM INTERRUPT HANDLER                                     ³
------------------------------------------------------------------------------
³JOB:    To handle all the system interrupts by polling the interrupt register ³
³        and directing control to the appropriate interupt handler.            ³
------------------------------------------------------------------------------
³ENTRY:  none                                                                  ³
³                                                                              ³
³EXIT:   none                                                                  ³
³                                                                              ³
³ERRORS: none                                                                  ³
À------------------------------------------------------------------------------Ù

   This one routine handles all the system interrupts. Each one caters for a
   different aspect of the machine operation as follows:-

    1. GAPINT   -   occurs each time the inter-sector gap on the surface of the
                    tape in a microdrive cartridge passes under the read he
                    and signifies the start of a sector header.

    2. INTRFINT -   used for reading the keyboard and the serial ports.

    3. TRNSMINT -   used to control transmission from both serial ports.

    4. FRAMEINT -   used to execute the system housekeeping linked lists.

    5. EXTNLINT -   only occurs with extra peripheral hardware attached.

0340 SYSINT        MOVEM.L  D7/A5-6,-(A7)          ;save registers used by SuperBASIC
                   MOVEA.L  A7,A5                  ;make a copy of the SSP
                   MOVEA.L  #SV_IDENT,A6           ;A6 points at system variables
                   MOVE.B   PC_INTR,D7             ;read the interrupt register
                   LSR.B    #1,D7                  ;check bit 0
                   BCS      GAPINT                 ;handle gap interrupts if set
                   LSR.B    #1,D7                  ;check bit 1
                   BCS      INTRFINT               ;handle interface interrupts if set
                   LSR.B    #1,D7                  ;check bit 2
                   BCS      TRNSMINT               ;handle transmit interrupts if set
                   LSR.B    #1,D7                  ;check bit 3
                   BCS      FRAMEINT               ;handle frame interrupts if set
                   LSR.B    #1,D7                  ;check bit 4
                   BCC.S    EXIT_INT               ;exit if not an external interrupt

Ú------------------------------------------------------------------------------¿
³=EXTNLINT        EXTERNAL INTERRUPT HANDLER                                   ³
------------------------------------------------------------------------------
³JOB:    To handle external interrupts.                                        ³
------------------------------------------------------------------------------
³ENTRY:  none                                                                  ³
³                                                                              ³
³EXIT:   none                                                                  ³
³                                                                              ³
³ERRORS: none                                                                  ³
À----------------------------------------------------------------------Ù

   This interrupt will only occur if additional hardware is attached such as a
   disc drive controller and merely executes a single linked list of tasks, so
   any device driver would have to be set up as one of these.

036E EXTNLINT      MOVEM.L  D0-6/A0-4,-(A7)        ;save remaining registers as well
                   MOVEQ    #0,D0                  ;and signal "no errors"
                   MOVEA.L  SV.I2LST(A6),A0        ;A0 points at external interrupt linked list
                   JSR      EXECLIST(PC)           ;execute the linked list
                   MOVE.B   SV.PCINT(A6),D7        ;get copy of interrupt register
                   ORI.B    #%00010000,D7          ;set external interrupt bit of copy
                   MOVE.B   D7,PC_INTR             ;and acknowledge the interrupt
                   MOVEM.L  (A7)+,D0-6/A0-4        ;partially restore registers
038E EXIT_INT      BRA      EXITTRAP

Ú----------------------------------------------------------------------¿
³=CLEANUP         CLEAN UP ROUTINE FOR ALL THE TRAP HANDLERS                   ³
³=CHKSBIT         CHECK IF SUPERVISOR MODE BIT SET BEFORE TRAP                 ³
³=EXITTRAP        GENERAL EXIT TO RESTORE SuperBASIC'S REGISTERS               ³
Ã----------------------------------------------------------------------´
³JOB:    To generally clean up and test the CPU status prior to the interrupt. ³
Ã----------------------------------------------------------------------´
³ENTRY:  none                                                                  ³
³                                                                              ³
³EXIT:   none                                                                  ³
³                                                                              ³
³ERRORS: none                                                                  ³
À----------------------------------------------------------------------Ù

   These three entry points are called throughout QDOS under the various exit
   conditions which can occur to check the status of QDOS when the exception
   occured.

0392 CLEANUP       MOVEQ    #0,D0                  ;signal "no errors"
0394 CHKSBIT       BTST     #5,12(A7)              ;check "S" bit of saved SR
                   BNE.S    EXITTRAP               ;clean up stack and exit if set
                   TST.W    SV.POLLM(A6)           ;check number of poll interrupts missed
                   BNE      SCHEDULE               ;enter scheduler if any missed
03A4 EXITTRAP      MOVEM.L  (A7)+,D7/A5-6          ;unstack registers saved on entry
                   RTE

2.1.11 Job ID handlers.

Ú----------------------------------------------------------------------¿
³=CHKJBID         CHECK JOB ID                                                 ³
Ã----------------------------------------------------------------------´
³JOB:                                                                          ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     job ID (-1 if current job)                          ³
³                 A6.L     QDOS system variables                               ³
³                                                                              ³
³EXIT:            D1.L     job ID (Z flag set if ok , reset if not)            ³
³                 A0.L     start of corresponding job header                   ³
³                                                                              ³
³ERRORS:          ERR.NJ   invalid job ID                                      ³
À----------------------------------------------------------------------Ù

   To help control multitasking, QDOS uses a large table of vectors known as the
   job table, which contains a long word pointer to the job control header which
   exists at the start of every job in the system. When a job is created, the
   first unused entry in the job table is set to the start address of the job
   header, but thereafter the only reference allowed to a job is its job ID.

   This is essentially, the long word number of the entry in the job table for
   that job and a number specifying how many jobs have been created since the
   machine was switched on, known as the job tag. These are combined into a long
   word as follows:-

    JOB ID = JOB TAG * 65536 + JOB NO

   Channels use a similar system where a channel's only reference is what is
   known as a channel ID, made up from the channel number and the channel tag in
   the same way.

03AA CHKJBID       TST.W    D1                     ;check job number
                   BGE.S    CHKJOB                 ;branch if not current job
                   MOVE.L   SV.JBPNT(A6),D1        ;D1 points at the current job table entry
                   MOVEA.L  D1,A0                  ;and copy to A0
                   MOVEA.L  (A0),A0                ;A0 points at the current job's header
                   SUB.L    SV.JBBAS(A6),D1        ;find entry number in job table
                   LSR.L    #2,D1                  ;form job number
                   SWAP     D1                     ;move job tag field into view
                   MOVE.W   JB.TAG(A0),D1          ;copy job tag from header to low word
                   SWAP     D1                     ;swap back
03C4 ENDJCHK       RTS

03C6 CHKJOB        BSR.S    CHKJBNO                ;check job number and job tag
                   BEQ.S    ENDJCHK                ;return if job ID ok

   All QDOS errors are signified by returning a negative value in DO. There are
   21 of them altogether and all are detailed in the appendix.

                   MOVEQ    #ERR.NJ,D0             ;signal "invalid job" if not
                   ADDQ.W   #4,A7                  ;ignore return address
                   BRA      CHKSBIT

03D2 CHKJBNO       CMP.W    SV.JBMAX(A6),D1        ;compare with maximum job number to date
                   BHI.S    ENDJCHK                ;exit if greater as this is impossible
                   MOVEA.W  D1,A0                  ;then use the job number as an offset
                   ADDA.W   A0,A0                  ;form long word offset
                   ADDA.W   A0,A0
                   ADDA.L   SV.JBBAS(A6),A0        ;and add offset to start of job table
                   TST.B    (A0)                   ;valid job ? (contains $FF if unused)
                   BLT.S    ENDJCHK                ;and return if invalid
                   MOVEA.L  (A0),A0                ;A0 points at job header

   Now check the job tag field just to be absolutely certain.

                   SWAP     D1                     ;move job tag to low byte of D1
                   CMP.W    JB.TAG(A0),D1          ;same job tag ?
                   BNE.S    ENDJCHK                ;return if wrong job tag
                   SWAP     D1                     ;swap job tag and job number back again
                   CMP.B    D1,D1                  ;signal "job ID ok"
                   RTS

Ú----------------------------------------------------------------------¿
³=GETJBID         GET CURRENT JOB'S ID & HEADER ADDRESS                        ³
Ã----------------------------------------------------------------------´
³JOB:                                                                          ³
Ã----------------------------------------------------------------------´
³ENTRY:           A6.L     system variables                                    ³
³                                                                              ³
³EXIT:            D0.L     job ID                                              ³
³                 A3.L     address of job header                               ³
³                 D1,D2,D3,A1 and A2 preserved                                 ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

03F6 GETJBID       MOVEA.L  SV.JBPNT(A6),A3        ;A3 points at current job table entry
                   MOVE.L   A3,D0                  ;copy to D0
                   SUB.L    SV.JBBAS(A6),D0        ;subtract base of table
                   LSR.W    #2,D0                  ;form job number
                   MOVEA.L  (A3),A3                ;get header address in A3
                   SWAP     D0                     ;move tag field into view
                   MOVE.W   JB.TAG(A3),D0          ;get job tag
                   SWAP     D0                     ;swap back
                   RTS

2.1.12 I/O timers.

Ú----------------------------------------------------------------------¿
³=TIMER1          TIMER FOR SERIAL & MICRODRIVE I/O                            ³
³=CLRTMODE        ENTRY POINT WHEN MICRODRIVE OPERATIONS FINISHED              ³
Ã----------------------------------------------------------------------´
³JOB:                                                                          ³
Ã----------------------------------------------------------------------´
³ENTRY:           D0.B     new serial I/O status                               ³
³                 A6.L     start of QDOS system variables                      ³
³                                                                              ³
³EXIT:            D0.L     new ULA transmit mode                               ³
³                 D1,D2,D3,A0,A1,A2 and A3 preserved                           ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

   This routine is the first one which if used an an MC68020 based machine,
   would not operate correctly due to the dependency on the DBF instruction's
   timing. Several others exist at the end of the ROM, in particular, the
   microdrive routines as they also use a large number of timing loops.

040E TIMER1        MOVE.B   D0,-(A7)               ;save the new status
0410 TIMER2        SUBQ.W   #1,SV.TIMO(A6)         ;decrement timeout counter
                   BLT.S    TIMER4                 ;exit timing loop if -ve
                   MOVE.W   #$208B,D0              ;approximate value for ?ms
041A TIMER3        DBF      D0,TIMER3              ;short delay
                   BRA.S    TIMER2                 ;next millisecond worth
0420 TIMER4        CLR.W    SV.TIMO(A6)            ;clear counter and serial I/O bits
                   ANDI.B   #%11100111,SV.TMODE(A6)
                   MOVE.B   (A7)+,D0               ;restore D0
                   OR.B     D0,SV.TMODE(A6)        ;add in serial I/O status and reset register
                   ANDI.B   #%01111111,SV.PCINT(A6)
0436 EXITIMER      MOVE.B   SV.TMODE(A6),PC_TCTRL
                   RTS

0440 CLRTMODE      BCLR     #4,SV.TMODE(A6)        ;signal "microdrive not turning"
                   ORI.B    #$80,SV.PCINT(A6)      ;clear copy of interrupt register
                   BRA.S    EXITIMER               ;and send to transmit register

                                MEMORY MANAGEMENT

                                       AND

                                   JOB CONTROL

                                  TRAP HANDLERS

2.2 Job control TRAP handlers.

2.2.1 Handle TRAP #1 functions.

Ú----------------------------------------------------------------------¿
³=CHKTRP1         HANDLE TRAP #1 FUNCTIONS                                     ³
Ã----------------------------------------------------------------------´
³JOB:                                                                          ³
Ã----------------------------------------------------------------------´
³ENTRY:           D0.W     function number                                     ³
³                                                                              ³
³EXIT:            depends on function                                          ³
³                                                                              ³
³ERRORS:          ERR.BP   bad parameter if invalid function number            ³
À----------------------------------------------------------------------Ù

   All the TRAP #1 calls are concerned with aspects of memory management, job
   control and the system linked lists.

044E CHKTRP1       CMPI.W   #MT.RDD,D0             ;is it a valid TRAP #1 function ?
                   BHI.S    BADPARAM               ;exit if not
                   MOVE.W   D0,D7                  ;copy parameter to D0
                   ADD.W    D7,D7                  ;and double it giving word offset
                   MOVE.W   TABLE1(PC,D7.W),D7
                   JMP      CHKTRP1(PC,D7.W)       ;jump to routine via vector offset

   Table of vector offsets for the TRAP #1 fuctions.

0460 TABLE1        DC.W     MT_INF   -CHKTRP1      ;get system information
                   DC.W     MT_CJOB  -CHKTRP1      ;create job
                   DC.W     MT_JINF  -CHKTRP1      ;get job information
                   DC.W     BADPARAM -CHKTRP1      ;not implemented
                   DC.W     MT_RJOB  -CHKTRP1      ;remove a job
                   DC,W     MT_FRJOB -CHKTRP1      ;force remove a job
                   DC.W     MT_FREE  -CHKTRP1      ;find amount of free space
                   DC.W     MT_TRAPV -CHKTRP1      ;set RAM exception table
                   DC.W     MT_SUSJB -CHKTRP1      ;suspend job
                   DC.W     MT_RELJB -CHKTRP1      ;release a suspended job
                   DC.W     MT_ACTIV -CHKTRP1      ;activate a job
                   DC.W     MT_PRIOR -CHKTRP1      ;change job priority
                   DC.W     MT_ALLOC -CHKTRP1      ;allocate heap space
                   DC.W     MT_LNKFR -CHKTRP1      ;release heap space
                   DC.W     MT_ALRES -CHKTRP1      ;allocate resident procedure space
                   DC.W     MT_ALRES -CHKTRP1      ;release resident procedure area
                   DC.W     MT_DMODE -CHKTRP1      ;set or read display mode
                   DC.W     MT_IPCOM -CHKTRP1      ;send IPC command
                   DC.W     MT_BAUD  -CHKTRP1      ;set serial port baud rate
                   DC.W     MT_CLOCK -CHKTRP1      ;read clock (MT_RCLCK)
                   DC.W     MT_CLOCK -CHKTRP1      ;set clock (MT_SCLCK)
                   DC.W     MT_CLOCK -CHKTRP1      ;adjust clock (MT_ACLCK)
                   DC.W     MT_ALBAS -CHKTRP1      ;allocate basic area
                   DC.W     MT_REBAS -CHKTRP1      ;release basic area
                   DC.W     MT_ALCHP -CHKTRP1      ;allocate common heap space
                   DC.W     MT_RECHP -CHKTRP1      ;release common heap space
                   DC.W     MT_LINK  -CHKTRP1      ;link in external interrupt handler
                   DC.W     MT_UNLNK -CHKTRP1      ;unlink external interrupt handler
                   DC.W     MT_LINK  -CHKTRP1      ;link in polled task (MT_LPOLL)
                   DC.W     MT_UNLNK -CHKTRP1      ;unlink polled task (MT_RPOLL)
                   DC.W     MT_LINK  -CHKTRP1      ;link in scheduler task (MT_LSCHD)
                   DC.W     MT_UNLNK -CHKTRP1      ;unlink scheduler task (MT_RSCHD)
                   DC.W     MT_LINK  -CHKTRP1      ;link in I/O driver (MT_LIOD)
                   DC.W     MT_UNLNK -CHKTRP1      ;unlink I/O driver (MT_RIOD)
                   DC.W     MT_LINK  -CHKTRP1      ;link in directory drive (MT_LDD)
                   DC.W     MT_UNLNK -CHKTRP1      ;unlink directory driver (MT_RDD)

04A8 BADPARAM      MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
                   BRA      CHKSBIT                ;exit via clean up routine

2.2.2 Job details.

Ú----------------------------------------------------------------------¿
³=MT_INF          GET SYSTEM INFORMATION     (TRAP #1 WITH D0 = $00)           ³
Ã----------------------------------------------------------------------´
³JOB:    To return primarily, the QDOS version, but also to return the current ³
³        job ID and the start of the QDOS system variables. In earlier versions³
³        of QDOS, the system variables were to be movable so that both screens ³
³        could be used as screen #1 currently lies over the system variables.  ³
³        The version number is returned as a string of the form "v.xx" where   ³
³        "v" is the revision number and "xx" is the update number. No versions ³
³        above "1.03" have been produced/sold, to the author's knowledge.      ³
Ã----------------------------------------------------------------------´
³ENTRY:           none                                                         ³
³                                                                              ³
³EXIT:            D1.L     current job ID                                      ³
³                 D2.L     QDOS version number as a four letter ASCII string   ³
³                 A0.L     start of QDOS system variables                      ³
³                 D3,D4,D5,D6,D7,A1,A2,A3,A4,A5 and A6 preserved               ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

04AE MT_INF        MOVEQ    #-1,D1                 ;signal "get current job's info"
                   JSR      CHKJBID(PC)            ;get current job's ID
                   MOVE.L   #"1.03",D2             ;set D2 to ASCII version number string
                   MOVEA.L  A6,A0                  ;A0 points at system variables
                   BRA      CLEANUP

Ú----------------------------------------------------------------------¿
³=MT_JINF         GET JOB INFORMATION        (TRAP #1 WITH D0 = $02)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     job ID (-1 if current job)                          ³
³                 D2.L     ID of job at top of job tree                        ³
³                                                                              ³
³EXIT:            D1.L     next job in tree (or zero if no more)               ³
³                 D2.L     owner job ID                                        ³
³                 D3.L     priority (negative if suspended)                    ³
³                 A0.L     location of actual job (after header)               ³
³                 A1       corrupted                                           ³
³                 A2,A3    preserved                                           ³
³                                                                              ³
³ERRORS:          ERR.NJ   invalid job ID                                      ³
À----------------------------------------------------------------------Ù

   Checks the status of jobs and can be used to traverse a complete tree of
   them in job number order by using successive calls until D1 is zero.

04C0 MT_JINF       JSR      CHKJBID(PC)            ;check job ID,A0 points at header on exit
                   MOVEQ    #0,D3                  ;prepare D3 for the priority value
                   TST.W    JB.STAT(A0)            ;check job status
                   BEQ.S    POSSACTI               ;branch if possibly active
                   MOVEQ    #-1,D3                 ;otherwise signal "suspended"
04CE POSSACTI      MOVE.B   JB.PRINC(A0),D3        ;get priority increment in low byte
                   MOVE.L   D2,D0                  ;move owner ID to D0
                   MOVE.L   A0,-(A7)               ;save address of parent job's header
                   JSR      FINDSUBS(PC)           ;find next job in the tree (0 if end)
                   MOVEA.L  (A7)+,A0               ;get header address back
                   MOVE.L   JB.OWNER(A0),D2        ;get owner ID
                   LEA      JB.END(A0),A0          ;A0 points at start of code area
                   BRA      CLEANUP

2.2.3 Job creation and deletion.

   In order for a job to exist at all, it must have, at the very least, some
   memory for its code and data areas. In practice, space will also be set
   aside for the extra information that QDOS requires to keep control of a
   job and space to store the volatile state of the job such as the register
   values, the program counter and the CPU status flags.

   All this is taken care of by the job header which is a $68 byte area of
   memory immediately preceding the area assigned to the code and data.

      HIGH  MEMORY

     ÃÄÄÄÄÄÄÄÄÄÄÄÄ´ <- (A6,A5)
     ³      0     ³
     ÃÄÄÄÄÄÄÄÄÄÄÄÄ´
     ³      0     ³
     ÃÄÄÄÄÄÄÄÄÄÄÄÄ´
     ³            ³
     ³    STACK   ³
     ³            ³
     ÃÄÄÄÄÄÄÄÄÄÄÄÄ´ <- (A7) { this moves as items are pushed and popped }
     ³            ³
     ³    DATA    ³
     ³            ³
     ÃÄÄÄÄÄÄÄÄÄÄÄÄ´ <- (A6,A4)
     ³            ³
     ³    CODE    ³
     ³            ³
     ÃÄÄÄÄÄÄÄÄÄÄÄÄ´ <- (A6)                              Job table
     ³   HEADER   ³                                    ÃÄÄÄÄÄÄÄÄÄÄÄÄ´
     ÃÄÄÄÄÄÄÄÄÄÄÄÄ´ <----------------------------------³            ³
                                                       ÃÄÄÄÄÄÄÄÄÄÄÄÄ´
       LOW MEMORY

Ú----------------------------------------------------------------------¿
³=MT_CJOB         CREATE A JOB               (TRAP #1 WITH D0 = $01)           ³
Ã----------------------------------------------------------------------´
³JOB:    To create a new job in transient program area. The job itself is not  ³
³        activated and this should be done with the MT.AJOB TRAP.              ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     owner job ID:                                       ³
³                                                                              ³
³                          0  = this job to be independant of all other jobs   ³
³                          -1 = this job to be owned by the current job        ³
³                                                                              ³
³                 D2.L     length of code space required in bytes              ³
³                 D3.L     length of data space required in bytes              ³
³                 A1.L     start address of job                                ³
³                                                                              ³
³                          0   = start of job to be at JB.END                  ³
³                          +ve = actual start address of job                   ³
³                                                                              ³
³EXIT:            D1.L     new job's ID                                        ³
³                 A0.L     start of area in TRNSP allocated + $68              ³
³                 D2,D3,D4,D5,D6,A1,A2,A3,A4,A5 and A6 preserved               ³
³                                                                              ³
³ERRORS:          ERR.NJ   invalid owner job ID or job table full              ³
³                 ERR.OM   out of memory                                       ³
À----------------------------------------------------------------------Ù

   This trap then creates a job by allocating space for the header, code and
   data areas required memory permitting. It then sets up the standard values
   for the registers as follows:-

    1.     JB.A6    start of the area assigned to the code
    2.     JB.A4    start of the area assigned to be data relative to A6
    3.     JB.A5    end of the data area relative to A6
    4.     JB.A7    end of the data area - 4

   Note that the job is only created, it is up to the owner job to activate it
   and give it a priority. The space allocated to the job remains until the job
   is removed.

   TRAP handler alters registers so that A6 now points at QDOS system variables.

04E8 MT_CJOB       TST.L    D2                     ;any code space required ?
                   BEQ.S    NOSPACE                ;branch if not
                   JSR      CHKJBID(PC)            ;check job ID, A0 points at header on exit
04F0 NOSPACE       MOVEM.L  D1-3/A1-4,-(A7)        ;save registers

   For a job to exist it must have an entry in the job table so search for the
   first free one.

                   MOVEQ    #0,D7                  ;initialise job number counter
                   MOVEA.L  SV.JBBAS(A6),A4        ;A4 points at first entry in job table
04FA TESTENTR      TST.B    (A4)                   ;is entry free ?
                   BLT.S    ENTRYFRE               ;jump forward if it is
                   ADDQ.W   #1,D7                  ;otherwise increment job number
                   ADDQ.W   #4,A4                  ;A4 points at next entry in job table
                   CMPA.L   SV.JBTOP(A6),A4        ;end of job table reached ?
                   BLT.S    TESTENTR               ;try next entry if not otherwise
                   MOVEQ    #ERR.NJ,D0             ;signal "invalid job" as job table
                   BRA.S    EXIT_CJB               ;is full and there are no free entries

   First free entry found in job table so calculate parameters of area.

050C ENTRYFRE      MOVEQ    #$68,D1                ;make room for job header
                   ADD.L    D2,D1                  ;add length of code space required
                   ADD.L    D3,D1                  ;and length of data space required
                   JSR      MM_ALTPA(PC)           ;expand TRNSP, A0 points at area on exit
                   BNE.S    EXIT_CJB               ;and exit if no room in memory
                   MOVEM.L  (A7),D1-3/A1           ;restore registers with job data
                   MOVE.L   A0,(A4)                ;enter address of header in job table
                   CMP.W    SV.JBMAX(A6),D7        ;is job number > largest to date ?
                   BLS.S    JBMAXOK                ;jump forward if not otherwise
                   MOVE.W   D7,SV.JBMAX(A6)        ;update new maximum job number

   Clear the job header from JB.START onwards.

0528 JBMAXOK       ADDQ.W   #4,A0                  ;A0 points at start of header
                   MOVEQ    #24,D0                 ;total of 100 bytes to clear
052C CLRHEADR      CLR.L    (A0)+                  ;clear a long word and point at next one
                   DBF      D0,CLRHEADR

 A0 now points at JB_END so reset it so that it points at JB_OWNER.

                   SUBA.W   #$60,A0                ;A0 points at start of header + 8
                   MOVE.L   D1,(A0)                ;set JB_OWNER to owner job's ID
                   ADDQ.W   #8,A0                  ;A0 points at JB_TAG
                   SWAP     D7                     ;move job tag field into view
                   MOVE.W   SV.JBTAG(A6),D7        ;set to latest job tag
                   MOVE.W   D7,(A0)                ;insert into JB_TAG
                   SWAP     D7                     ;move job number back into line
                   ADDQ.W   #1,SV.JBTAG(A6)        ;increment job tag for next time

                   MOVE.L   SV.TRAPV(A6),JB.TRAPV - 16(A0)      ;use owners table

                   ADDA.W   #$40,A0                ;A0 points at variable JB_A4

  Set initial contents of register storage area starting at JB_A4.

                   MOVE.L   D2,(A0)+               ;set to value on entry to TRAP
                   ADD.L    D2,D3                  ;form length of data + code space
                   MOVE.L   D3,(A0)+               ;set JB_A5 to length
                   MOVEQ    #$10,D0
                   ADD.L    A0,D0                  ;D0 points at start of job area
                   MOVE.L   D0,(A0)+               ;set JB_A6 to start of job
                   ADD.L    D0,D3                  ;D3 points at end of job area for stack
                   EXG      D3,A0
                   CLR.L    -(A0)                  ;push zero value onto stack
                   EXG      D3,A0
                   MOVE.L   D3,(A0)                ;set JB_A7 to new top of stack
                   ADDQ.W   #6,A0                  ;A0 points at JB_PC
                   MOVE.L   A1,D3                  ;and D3 points at start address specified
                   BEQ.S    NOSTART                ;branch if no address given
                   MOVE.L   D3,D0                  ;copy start of job area to D0

   If no start address given then use start of code area.

0570 NOSTART       MOVE.L   D0,(A0)                ;set JB_PC to address
                   MOVE.L   D0,JB.START-$62(A0)
                   MOVEA.L  D0,A0                  ;A0 points at this address
                   MOVEQ    #0,D0                  ;signal "no errors"
057A EXIT_CJB      MOVEM.L  (A7)+,D1-3/A1-4        ;restore registers
                   MOVE.L   D7,D1                  ;copy job number
                   BRA      CHKSBIT

Ú----------------------------------------------------------------------¿
³=MT_RJOB         REMOVE A JOB               (TRAP #1 WITH D0 = $04)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     job ID (-1 if current)                              ³
³                 D3.L     error code to be passed to job                      ³
³                                                                              ³
³EXIT:            D1,D2,D3,A0,A1,A2 and A3 corrupted                           ³
³                                                                              ³
³ERRORS:          ERR.NC   job is active                                       ³
³                 ERR.NJ   invalid job ID                                      ³
À----------------------------------------------------------------------Ù

   Removes a job and its subsiduaries from the transient program area if the
   job is inactive. The status of the subsiduary jobs is irrelevant.

0584 MT_RJOB       JSR      CHKJBID(PC)            ;check job ID, A0 points at header on exit
                   MOVE.L   D1,D0                  ;copy ID to D0
058A L0058A        TST.B    JB.PRINC(A0)           ;check priority (0 if inactive)
                   BNE      EXIT_REM               ;exit immediately if job active
                   JSR      FINDSUBS(PC)           ;find first job owned by this one
                   TST.L    D1                     ;end if this branch ?
                   BNE.S    L0058A                 ;check next branch of job tree if so
                   MOVE.L   D0,D1                  ;reset job ID for force removal

Ú----------------------------------------------------------------------¿
³=MT_FRJOB        FORCE REMOVE A JOB         (TRAP #1 WITH D0 = $05)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     job ID (-1 if current job)                          ³
³                 D3.L     error code to be passed to job                      ³
³                                                                              ³
³EXIT:            D1,D2,D3,A0,A1,A2 and A3 corrupted                           ³
³                                                                              ³
³ERRORS:          ERR.NJ   invalid job ID                                      ³
À----------------------------------------------------------------------Ù

   Removes a job and its subsiduaries from the transient program area even if
   the job is active. The status of the subsiduary jobs is irrelevant. TRAP
   handler alters registers so that A6 now points at system variables.

059C MT_FRJOB      JSR      CHKJBID(PC)            ;check job ID, A0 points at header on exit
                   MOVE.L   D1,D0                  ;save job ID and check if SUPERBASIC
                   BEQ      EXIT_REM               ;exit if so or job ID invalid

   Traverse job tree forwards and mark each subsiduary job found by setting the
   MSB of the job table entry to 1 which corresponds to an invalid address (it
   is normally zero).

                   MOVEA.W  D1,A1                  ;copy job number to A1
                   ADDA.W   A1,A1                  ;form offset into table from job number
                   ADDA.W   A1,A1
                   ADDA.L   SV.JBBAS(A6),A1        ;add to start of job table
05B0 MARKJOB       ADDQ.B   #1,(A1)                ;set top byte to 1 to mark job
                   JSR      FINDSUBS(PC)           ;get next job in tree
                   TST.L    D1                     ;end of branch ?
                   BNE.S    MARKJOB                ;mark this job and find rest
                   SF       -(A7)                  ;signal "current job not cleared"

   All the jobs owned by one to be removed have been found so start the process
   of removing the subsiduary jobs by traversing tree again.

                   MOVEQ    #0,D1                  ;reset job number to 0
                   MOVEA.L  SV.JBBAS(A6),A1        ;A1 points at job table
05C2 CHKJOBS       ADDQ.W   #4,A1                  ;ignore first job
                   ADDQ.W   #1,D1                  ;increment job number
                   CMP.W    SV.JBMAX(A6),D1        ;job number > than maximum to date ?
                   BHI      CHKCURNT               ;exit if so
                   TST.B    (A1)                   ;is it a subsiduary job (= 1 if so)
                   BLE.S    CHKJOBS                ;check next entry in table if not
                   SF       (A1)                   ;restore entry to old value
                   MOVEA.L  (A1),A0                ;A0 points at header
                   SWAP     D1                     ;move job tag field into line
                   MOVE.W   JB.TAG(A0),D1          ;set to job tag of owner
                   SWAP     D1                     ;swap back fields back
                   CMPA.L   SV.JBPNT(A6),A1        ;is it the current job ?
                   BNE.S    NOTCURNT               ;jump forward if not
                   ST       (A7)                   ;signal "current job cleared"
05E6 NOTCURNT      TST.B    JB.WFLAG(A0)           ;bit 7 set if another job waiting
                   BEQ.S    NOTWAIT                ;jump forward if not waiting
                   MOVE.L   JB.WJOB(A0),D0         ;get ID of waiting job
                   EXG      D0,D1                  ;save ID
                   JSR      CHKJBNO(PC)            ;check ID of waiting job
                   EXG      D1,D0
                   BNE.S    NOTWAIT                ;exit if invalid (may have finished)
                   CMPI.W   #-2,JB.STAT(A0)        ;is job still waiting for I/O ?
                   BNE.S    NOTWAIT                ;jump forward if not
                   CLR.W    JB.STAT(A0)            ;signal "not waiting"
                   MOVE.L   D3,JB.D0(A0)           ;copy error code to waiting job area

   Now check the common heap for any channel definition blocks owned by the job
   or subsiduary to be removed and reclaim the space.

060A NOTWAIT       MOVEA.L  SV.CHEAP(A6),A0        ;A0 points at start of common heap
060E CHKBLOCK      CMP.L    CH.OWNER(A0),D1        ;is block owned by this job ?
                   BNE.S    NOTOWNED               ;branch forward if not
                   MOVEM.L  D1/D3/A0-1,-(A7)
                   MOVE.L   CH.RFLAG(A0),D1        ;address to be set if space removed
                   BEQ.S    NOLOC                  ;branch forward if no location given
                   MOVEA.L  D1,A1                  ;copy address to D1
                   ST       (A1)                   ;set the address
0622 NOLOC         MOVEA.L  CH.DRIVR(A0),A1        ;A1 points at linkage block of channel
                   LEA      -$18(A1),A3            ;set up relative pointer for routines
                   MOVEA.L  DEV.CLOS(A1),A1        ;routine to close this channel
                   JSR      (A1)                   ;call it
                   MOVEM.L  (A7)+,D1/D3/A0-1
0634 NOTOWNED      ADDA.L   (A0),A0                ;A0 points at next definition block
                   CMPA.L   SV.FREE(A6),A0         ;end of common heap reached ?
                   BLT.S    CHKBLOCK               ;check next definition block if not
                   MOVEM.L  D1/D3/A1,-(A7)
                   MOVEA.L  (A1),A0                ;A0 points at area to be reclaimed
                   JSR      MM_RETPA(PC)           ;reclaim TRNSP of subsiduary
                   MOVEM.L  (A7)+,D1/D3/A1
                   ST       (A1)                   ;and finally clear job table entry
                   BRA      CHKJOBS                ;check next subsiduary job if any

0650 CHKCURNT      TST.B    (A7)+                  ;was the current job cleared ?
                   BEQ      CLEANUP                ;exit via clean up routine if not
                   BRA      CHKPOLLM               ;otherwise call the scheduler

065A EXIT_REM      MOVEQ    #ERR.NC,D0             ;signal "not complete"
                   BRA      CHKSBIT                ;exit via clean up routine

Ú----------------------------------------------------------------------¿
³=FINDSUBS        FIND SUBSIDUARY IN JOB TREE                                  ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     job ID of parent                                    ³
³                 A6.L     system variables                                    ³
³                                                                              ³
³EXIT:            D1.L     ID of sibling (0 if no subsiduary found)            ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

   Trees are probably the most complex of all the standard data structures and
   QDOS uses a slightly non-standard implementation of them. Basically each
   item in a tree should have pointers to what is known as its children and each
   child in turn contains pointers to its children. In QDOS the pointers
   refered to here point to the parent from the child instead of to the child
   from the parent and in practise, this makes finding items in a tree of this
   type much more difficult. The reason it is used however is simply to preserve
   space since in the standard approach there must be one pointer for every
   possible child. For a binary tree this would be 2, for denary tree this would
   be 10 etc. By adopting the scheme used here only one pointer is required
   regardless of the number of children. The pointer used is actually the job ID
   of the owner or parent job.

0660 FINDSUBS      MOVE.L   D1,D2                  ;copy ID to D2
                   MOVEQ    #0,D1                  ;start with job number 0
0664 CHKENTRY      ADDQ.W   #1,D1                  ;increment job number (ignore job 0)
                   CMP.W    SV.JBMAX(A6),D1        ;end of branch ?
                   BGT.S    CHKPARNT               ;if so
                   BSR.S    GETHEAD                ;A0 points at entry and A1 at header
                   TST.B    (A1)                   ;entry free ?
                   BLT.S    CHKENTRY               ;check next entry if so
                   CMP.L    JB.OWNER(A0),D2        ;subsiduary found ?
                   BEQ.S    EXIT_FIN               ;finished if so
                   BRA.S    CHKENTRY               ;check next entry if not

067A CHKPARNT      CMP.W    D2,D0                  ;owned by parent job ?
                   BEQ.S    NOSUBSID               ;exit if it is
                   MOVE.W   D2,D1                  ;save ID
                   BSR.S    GETHEAD                ;get pointer to header
                   MOVE.L   JB.OWNER(A0),D2        ;get owner ID (ie move up tree)
                   BRA.S    CHKENTRY               ;check next branch of tree

0688 GETHEAD       MOVEA.W  D1,A1                  ;move ID to A1
                   ADDA.W   A1,A1                  ;form offset
                   ADDA.W   A1,A1
                   ADDA.L   SV.JBBAS(A6),A1        ;add to base of table
                   MOVEA.L  (A1),A0                ;A0 points at header
                   RTS

0696 NOSUBSID      MOVEQ    #0,D1                  ;signal "no subsiduary"
                   RTS

069A EXIT_FIN      SWAP     D1                     ;move job tag field into veiw
                   MOVE.W   JB.TAG(A0),D1          ;get job tag
                   SWAP     D1                     ;swap fields again
                   RTS

Ú----------------------------------------------------------------------¿
³=MT_TRAPV        SET UP RAM EXCEPTION TABLE (TRAP #1 WITH D0 = $07)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     job ID (or -1 if current)                           ³
³                 A1.L     location of table                                   ³
³                                                                              ³
³EXIT:            D1.L     job ID                                              ³
³                 A0.L     start of job header                                 ³
³                 A1       corrupted                                           ³
³                 D2,D3,A2 and A3 preserved                                    ³
³                                                                              ³
³ERRORS:          ERR.NJ   invalid job ID                                      ³
À----------------------------------------------------------------------Ù

   TRAP handler alters registers so that A6 now points at system variables.

06A4 MT_TRAPV      JSR      CHKJBID(PC)            ;check job ID, A0 points at header on exit
                   SUBA.W   #$54,A1                ;compensate for vector return address
                   MOVE.L   A1,SV.TRAPV(A6)        ;current ram vector table
                   MOVE.L   A1,JB.TRAPV(A0)        ;creating job's ram table
                   BRA      CLEANUP

2.3 Memory management TRAP handlers.

   The following set of routines are for memory management and implement the
   basic mechanisms to acheive this result. All off the memory in a QL is under
   the control of QDOS and every byte is carefully accounted for. If this was
   not done by QDOS then eventually a user routine would try to use memory which
   QDOS may subsequently use for something else since it could not be aware of
   its use by the users routine. By passing complete control over to QDOS this
   cannot happen unless a user routine does not stick to its allocated memory.

   In more advanced systems, there would be memory management hardware attached
   designed to prevent even this from occuring. When a job is finished with some
   space, or the job is to be removed from the system, the space is connected to
   other similar areas in a long list with pointers in each section to the next
   section in the list. This is known as a linked list data structure and is a
   very good way of keeping track of memory in a multitasking operating system.

   Each linked list has a system variable to point at the first entry or in the
   case where there is no free space, usually at switch on, this pointer often
   contains a null or zero value and any other value gives the relative
   displacement to the next entry. The following two pointers are used for
   free space memory management under QDOS:-

    1. SV.CHPFR first free space in common heap
    2. SV.TRNFR first free space in transient program area

2.3.1 Common heap.

Ú----------------------------------------------------------------------¿
³=MT_ALLOC        ALLOCATE HEAP SPACE        (TRAP #1 WITH D0 = $0C)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     length of space required                            ³
³                 A0.L     pointer to pointer to space (relative to A6)        ³
³                                                                              ³
³EXIT:            D1.L     amount of bytes allocated                           ³
³                 A0.L     start of area allocated (relative to A6)            ³
³                 D2,D3,A1,A2 and A3 CORRUPTED                                 ³
³                                                                              ³
³ERRORS:          ERR.OM   no free space large enough                          ³
À----------------------------------------------------------------------Ù

   The same mechanisms that apply to QDOS memory management can also be applied
   to user specified areas of memory. This TRAP allows a user heap which as a
   section of memory in one of the users data areas, to be set up as an
   independant structure pointed to, as are the normal areas, by a pointer which
   must be stored elsewhere by the user.

   Space is allocated in multiples of eight bytes and each block is preceded by
   two long words. The first long word gives the length, including the header,
   of the area allocated. The second gives the relative displacement to the next
   block in the linked list.

   Note that the different blocks may be spaced apart in memory in a random
   manner and yet be treated as one structure. This is one very important aspect
   of memory management normally only used in more advanced operating systems
   such as those for mainframe computers and it is unusual to find it in a home
   computer.

   TRAP handler alters registers so that A6 now points at system variables and
   A5 points at saved SUPERBASIC registers.

06B8 MT_ALLOC      ADDA.L   8(A5),A0               ;make A0 absolute by using saved A6
                   JSR      MM_ALLOC(PC)           ;find the space, A0 points at area on exit
                   SUBA.L   8(A5),A0               ;make A0 relative again
                   BRA.S    EXIT_RER

Ú----------------------------------------------------------------------¿
³=MT_LNKFR        RELEASE HEAP SPACE         (TRAP #1 WITH D0 = $0D)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     length to link in                                   ³
³                 A0.L     base of new space (relative to A6)                  ³
³                 A1.L     pointer to pointer to space (relative to A6)        ³
³                                                                              ³
³EXIT             D1,D2,D3,A0,A1,A2 and A3 corrupted                           ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

   Links a user heap section back into the users free space linked list. TRAP
   handler alters registers so that A6 now points at the system variables and
   A5 points at the saved SUPERBASIC registers.

06C6 MT_LNKFR      ADDA.L   8(A5),A0               ;make A0 and A1 absolute using saved A6
                   ADDA.L   8(A5),A1
                   JSR      MM_LNKFR(PC)           ;release the space by linking it in
                   BRA.S    EXIT_RER               ;to a free space list

Ú----------------------------------------------------------------------¿
³=MT_ALCHP        ALLOCATE COMMON HEAP SPACE (TRAP #1 WITH D0 = $18)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     number of bytes required                            ³
³                 D2.L     owner job ID (-1 if current job)                    ³
³                                                                              ³
³EXIT:            D1.L     number of bytes allocated                           ³
³                 A0.L     base of area allocated (after header)               ³
³                 D2,D3,A1,A2 and A3 corrupted                                 ³
³                                                                              ³
³ERRORS:          ERR.NJ   invalid job ID                                      ³
³                 ERR.OM   out of memory                                       ³
À----------------------------------------------------------------------Ù

   Memory permitting, space in the common heap is allocated to the nearest
   multiple of 8 bytes plus the 4 word header. The routine will first of all try
   to allocate the required space from the free space linked list. If it cannot
   manage this then the space is allocated at the end of the common heap, eating
   into the slave block area. The corresponding entries in the slave block table
   are than set to "unavailable to OS". When any job is removed from the system,
   all the common heap space that was used by that job is also released for use
   by other jobs.

06D4 MT_ALCHP      EXG      D2,D1                  ;copy owner ID
                   JSR      CHKJBID(PC)            ;check job ID, A0 points at header on exit
                   MOVE.L   D1,-(A7)               ;save ID
                   MOVEQ    #16,D1                 ;allow for header of 4 long words
                   ADD.L    D2,D1                  ;calculate total number of bytes
                   JSR      MM_ALCHP(PC)           ;find the space, A0 points at header on
                   BNE.S    L00756                 ;and exit if not found
                   ADDQ.W   #4,A0                  ;ignore length long word

   Note that the following three instructions have a different effect which
   depends on whether the space is being allocated or released. In the first
   instance, the address of the routine to release the space is inserted in the
   appropriate long word of the header. In the second case, because of the
   action of the close routine, the address of the next free area in the free
   space linked list, is inserted instead.

06E8 RELEASE       MOVE.L   #RELEASE,(A0)+         ;jump here when space is released
                   MOVE.L   (A7)+,(A0)+            ;set owner ID long word
                   CLR.L    (A0)+                  ;and signal "no address to clear"
                   BRA.S    EXIT_REC               ;A0 now points at base of area after header

Ú----------------------------------------------------------------------¿
³=MT_RECHP        RELEASE COMMON HEAP SPACE  (TRAP #1 WITH D0 = $19)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           A0.L     start of area to be released                        ³
³                                                                              ³
³EXIT:            D1,D2,D3,A0,A1,A2 and A3 corrupted                           ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

   Will release common heap space as long as A0 is a valid value. The free space
   is actually linked into the common heap free space linked list and this is
   pointed to by the QDOS system variable, SV.CHPFR. The other free space linked
   lists also have their corresponding pointers.

                   ORI.B    #%01110000,D0          ;this instruction appears to be unused
06F8 MT_RECHP      LEA      -16(A0),A0             ;A0 now points at 4 long word header
                   JSR      MM_RECHP(PC)           ;release the space
0700 EXIT_REC      BRA      CLEANUP                ;and exit

2.3.2 Resident Procedure area.

Ú----------------------------------------------------------------------¿
³!MT_ALRES        ALLOCATE RESPR SPACE       (TRAP #1 WITH D0 = $0E)           ³
³!MT_RERES        RELEASE RESPR AREA         (TRAP #1 WITH D0 = $0F)           ³
Ã----------------------------------------------------------------------´
³=MT_ALRES        ALLOCATE RESIDENT PROCEDURE SPACE                            ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     number of bytes required                            ³
³                                                                              ³
³EXIT:            A0.L     start of area allocated                             ³
³                 D1,D2,D3,A1,A2 and A3 corrupted                              ³
³                                                                              ³
³ERRORS:          ERR.NC   not complete as TRNSP not empty                     ³
³                 ERR.OM   out of memory                                       ³
À----------------------------------------------------------------------Ù

   This routine allocates space in the resident procedures area provided that
   the transient program area is empty as jobs cannot be relocated.

   MT_RERES releases the whole area, again as long as TRNSP is empty, in one
   step but is faulty such that in some cases, more space may in fact be
   allocated instead of released. Finally, the TRAP handler alters the entry
   conditions so that A6 now points at the system variables.

0704 MT_ALRES      MOVEA.L  SV.RESPR(A6),A0        ;A0 points at start of RESPR area
                   CMPA.L   SV.TRNSP(A6),A0        ;is TRNSP empty ?
                   BNE.S    NOTEMPTY               ;exit immediately if not
                   CMPI.B   #MT.RERES,D0           ;is it a TRAP call to release area ?
                   BEQ.S    MT_RERES               ;jump forward if so
                   TST.L    D1                     ;check amount requested
                   BLE.S    EXIT_REC               ;and exit if negative or zero
                   JSR      MM_ALTPA(PC)           ;find the space, A0 points at area on exit
                   BLT.S    EXIT_REB               ;and exit if out of memory etc
                   BRA.S    SETPOINT               ;otherwise update the pointers

Ú----------------------------------------------------------------------¿
³=MT_RERES        RELEASE RESIDENT PROCEDURE AREA                              ³
Ã----------------------------------------------------------------------´
³ENTRY:           none                                                         ³
³                                                                              ³
³EXIT:            D1,D2,D3,A0,A1,A2 and A3 corrupted                           ³
³                                                                              ³
³ERRORS:          ERR.NC   TRNSP not empty                                     ³
À----------------------------------------------------------------------Ù

   This is meant to reduce the resident procedure area to zero but due to the
   action of MM_RETPA, more space can be allocated instead. Note that
   extensions to SUPERBASIC and the I/O file system may be using this area for
   pointers and/or links which if corrupted by releasing the space, whould cause
   the machine to crash when used at a later time. The TRAP is therefore
   potentially dangerous and should be used with extreme caution.

0720 MT_RERES      MOVE.L   SV.RAMT(A6),D1         ;D1 points at end of RESPR area (top of RAM)
                   SUB.L    SV.RESPR(A6),D1        ;form its length in bytes
                   JSR      MM_RETPA(PC)           ;try to release the space

072C SETPOINT      MOVE.L   SV.TRNSP(A6),SV.RESPR(A6)
                   CLR.L    SV.TRNFR(A6)           ;signal "no free space list for TRNSP"
                   BRA      CLEANUP

073A NOTEMPTY      MOVEQ    #ERR.NC,D0             ;signal "not complete"
073C EXIT_RER      BRA.S    EXIT_REB

2.3.3 SuperBASIC area.

Ú----------------------------------------------------------------------¿
³=MT_ALBAS        ALLOCATE BASIC AREA        (TRAP #1 WITH D0 = $16)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     length of area required                             ³
³                 A6.L     usual SUPERBASIC value                              ³
³                                                                              ³
³EXIT:            D1.L     length of area allocated                            ³
³                 A6.L     updated SUPERBASIC pointer                          ³
³                 A7.L     new user stack pointer                              ³
³                 D2,D3,A0,A1,A2 and A3 corrupted                              ³
³                                                                              ³
³ERRORS:          ERR.OM   out of memory                                       ³
À----------------------------------------------------------------------Ù

073E MT_ALBAS      JSR      MM_ALBAS(PC)           ;jump forward to proper routine
                   BRA.S    EXIT_REB

Ú----------------------------------------------------------------------¿
³=MT_REBAS        RELEASE BASIC AREA         (TRAP #1 WITH D0 = $17)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     number of bytes to release                          ³
³                 A6.L     usual SUPERBASIC value                              ³
³                                                                              ³
³EXIT:            D1.L     number of bytes released                            ³
³                 A6.L     updated SUPERBASIC pointer                          ³
³                 A7.L     new user stack pointer                              ³
³                 D2,D3,A0,A1,A2 and A3 corrupted                              ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

0744 MT_REBAS      MOVE.L   BV.PFP(A6),-(A7)       ;save relative pointer to top
                   SUB.L    D1,BV.PFP(A6)          ;reduce by specified amount
                   JSR      MM_REBAS(PC)           ;release the space
                   MOVE.L   (A7)+,BV.PFP(A6)       ;restore pointer
                   BRA.S    EXIT_REB

0756 L00756        ADDQ.W   #4,A7                  ;ignore saved pointer
0758 EXIT_REB      BRA      CHKSBIT

2.3.4 Device modes.

Ú----------------------------------------------------------------------¿
³=MT_DMODE        SET OR READ DISPLAY MODE   (TRAP #1 WITH D0 = $10)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.B     display mode:                                       ³
³                                                                              ³
³                          0  = set mode 512(4)                                ³
³                          8  = set mode 256(8)                                ³
³                          -1 = read mode                                      ³
³                                                                              ³
³                 D2.B     display type:                                       ³
³                                                                              ³
³                          0  = set "monitor" type                             ³
³                          1  = set "tv" type                                  ³
³                          -1 = read type                                      ³
³                                                                              ³
³EXIT:            D1.B     mode number ( 4 or 8 )                              ³
³                 D2.B     display type ( 0 or 1 )                             ³
³                 A4       corrupted                                           ³
³                 D3,A0,A1,A2 and A3 preserved                                 ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

   TRAP handler alters registers so that A6 now points at system variables.

075C MT_DMODE      MOVE.B   SV.MCSTA(A6),D0        ;get copy of master chip status
                   TST.B    D1                     ;read or write mode ?
                   BLT      READ_DM                ;jump forward if read required
                   ANDI.B   #%11110111,D0          ;clear mode bit of status only
                   ANDI.B   #%00001000,D1          ;and get requested mode
                   OR.B     D1,D0                  ;then merge together
                   MOVE.B   D0,SV.MCSTA(A6)        ;update status copy
                   MOVE.B   D0,MC_STAT             ;and set chip to new mode
                   MOVE.L   A6,-(A7)               ;save pointer
                   MOVE.W   #$1FFF,D0              ;length of screen in long words - 1

   Clear the screen to all black.

0780 CLSCREEN      CLR.L    -(A6)                  ;clear the screen
                   DBF      D0,CLSCREEN

   Now scan through the channel table and redo the colour masks and redraw the
   windows for all the screen or console channels found.

                   MOVEA.L  (A7)+,A6               ;restore pointer
                   MOVEA.L  SV.CHBAS(A6),A4        ;A4 points at channel table
078C L0078C        MOVE.L   (A4)+,D0               ;D0 points at channel definition block
                   MOVEM.L  D1-6/A0-6,-(A7)        ;save all the general registers
                   BLT.S    L007EC                 ;jump forward if "not used"
                   MOVEA.L  D0,A0                  ;copy pointer
                   CMPI.L   #CON_LB,CH.DRIVR(A0)   ;is it a console channel ?
                   BNE.S    L007EC                 ;jump forward if not
                   MOVE.B   D1,-(A7)               ;save requested mode and border width
                   MOVE.W   SD.BORWD(A0),-(A7)
                   MOVEQ    #0,D2
                   JSR      SD_BORDE(PC)           ;set window border
                   LEA      SD.PMASK(A0),A1        ;A1 points at paper colour mask
                   LEA      SD.PCOLR(A0),A5        ;and A5 at the paper colour byte

   As the colour masks required for one mode are different for the other then
   redo the three colour masks using SD_PCOLR,SD_SCOLR and SD_ICOLR.

                   MOVEQ    #2,D0                  ;three bytes to process
07B6 L007B6        MOVE.B   (A5)+,D1               ;get a colour byte and point at next one
                   JSR      COLRMASK(PC)           ;redo its corresponding mask
                   ADDQ.W   #4,A1                  ;point at next mask
                   DBF      D0,L007B6              ;repeat for next two colour bytes

   A5 now points at SD_BCOLR.

                   JSR      SD_CLEAR(PC)           ;clear the window with new colours
                   MOVE.B   (A5),D1                ;get border colour byte
                   MOVE.W   (A7)+,D2               ;and saved border width
                   JSR      SD_BORDR(PC)           ;set window border
                   SUBQ.W   #5,A5                  ;A5 points at SD_CATTR
                   ANDI.B   #0,(A5)                ;clear all the attributes

   Set cursor width to 6 and height to 10.

                   MOVE.L   #$6000A,SD.XINC(A0)
                   TST.B    (A7)+                  ;check saved mode
                   BEQ.S    REQ_M4                 ;jump forward if mode 4 requested
                   BSET     #6,(A5)+               ;signal "double width"
                   LSL      SD.XINC(A0)            ;and double cursor width
07E8 REQ_M4        TST.B    (A5)                   ;was cursor active ?
                   SNE      (A5)                   ;switch it on if not
07EC L007EC        MOVEM.L  (A7)+,D1-6/A0-6        ;restore registers
                   CMPA.L   SV.CHTOP(A6),A4        ;end of channel table ?
                   BLT.S    L0078C                 ;check remaining channels if not
                   BRA.S    L007FC

07F8 READ_DM       MOVEQ    #%00001000,D1          ;create mask for mode bit
                   AND.B    D0,D1                  ;extract the bit
07FC L007FC        TST.B    D2                     ;read or write monitor type ?
                   BGE.S    WRITE_TY               ;jump if write
                   MOVE.B   SV.TVMOD(A6),D2        ;read type
0804 WRITE_TY      MOVE.B   D2,SV.TVMOD(A6)        ;alter (if write)
                   BRA      CLEANUP

Ú----------------------------------------------------------------------¿
³=MT_IPCOM        SEND IPC COMMAND           (TRAP #1 WITH D0 = $11)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           A3.L     pointer to command                                  ³
³                                                                              ³
³EXIT:            D1.B     return parameter                                    ³
³                 D5 and D7  corrupted                                         ³
³                 D2,D3,A0,A1,A2 and A3 preserved                              ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

080C MT_IPCOM      MOVEM.L  D4/D6/A0-1/A3,-(A7)    ;save registers
                   JSR      IPC_CMND(PC)           ;do the command
                   MOVEM.L  (A7)+,D4/D6/A0-1/A3    ;restore registers
                   BRA      CLEANUP

Ú----------------------------------------------------------------------¿
³=MT_BAUD         SET SERIAL PORT BAUD RATE  (TRAP #1 WITH D0 = $12)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.W     required baud rate                                  ³
³                                                                              ³
³EXIT:            D1       corrupted                                           ³
³                 D2,D3,A0,A1,A2 and A3 preserved                              ³
³                                                                              ³
³ERRORS:          ERR.BP   rate not recognised                                 ³
À----------------------------------------------------------------------Ù

   TRAP handler alters registers so that A6 now points at system variables.
   Search the table of valid baud rates for correct value.

081C MT_BAUD       MOVEM.L  D2/D6/A0-2,-(A7)       ;save registers
                   LEA      BAUDTABLE(PC),A0       ;A0 points at valid baud rate table
                   MOVEQ    #7,D2                  ;table has 8 entries
0826 L00826        CMP.W    (A0)+,D1               ;is a valid mode requested ?
                   BEQ.S    BAUDOK                 ;exit if ok
                   DBF      D2,L00826              ;check rest of table if not

   The table has exhausted so the requested mode was not a valid one.

                   MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
0830 EXIT_BAU      MOVEM.L  (A7)+,D2/D6/A0-2       ;restore registers
                   BRA      CHKSBIT

0838 BAUDOK        MOVE.L   #1200,D0               ;form 1200/baud + 1 for rate number
                   DIVU     D1,D0                  ;to be used as a crude timer during
                   ADDQ.W   #1,D0                  ;transmit interrupts
                   MOVE.W   D0,SV.TIMOV(A6)        ;value of timeout for serial O/P
                   ORI.W    #$0700,SR              ;enter user mode and disable interrupts
                   JSR      IPC_SET(PC)            ;set up command, A1 points at string
                   LEA      SV.TMODE(A6),A2        ;A2 points at SV_TMODE
                   ANDI.B   #%11111000,(A2)        ;clear bottom three bits of it
                   OR.B     D2,(A2)                ;and add in the baud rate number
                   MOVE.B   (A2),-1(A1)            ;copy to command string
                   MOVEQ    #$0D,D0                ;IPC command D: "change baud rate"
                   JSR      IPC_SEND(PC)           ;do command
                   MOVE.B   D2,D0                  ;copy rate number to D0
                   JSR      IPC_SEND(PC)           ;finally set the baud rate
                   ANDI.W   #$F8FF,SR              ;enable interupts
                   MOVEQ    #0,D0                  ;signal "no errors"
                   BRA.S    EXIT_BAUD

   Table of valid baud rates.

0870 BAUDTABL      DC.W     75,300,600,1200,2400,4800,9600,19200

2.3.5 Linked lists.

Ú----------------------------------------------------------------------¿
³!MT_LXINT        LINK IN EXT INT HANDLER    (TRAP #1 WITH D0 = $1A)           ³
³!MT_LPOLL        LINK IN POLLED TASK        (TRAP #1 WITH D0 = $1C)           ³
³!MT_LSCHD        LINK IN SCHEDULER TASK     (TRAP #1 WITH D0 = $1E)           ³
³!MT_LIOD         LINK IN I/O DRIVER         (TRAP #1 WITH D0 = $20)           ³
³!MT_LDD          LINK IN DIRECTORY DRIVER   (TRAP #1 WITH D0 = $22)           ³
Ã----------------------------------------------------------------------´
³=MT_LINK         LINK ITEM INTO LIST                                          ³
Ã----------------------------------------------------------------------´
³ENTRY:           A0.L     address of link                                     ³
³                                                                              ³
³EXIT:            D0 and A1  corrupted                                         ³
³                 D1,D2,D3,A0,A2,A2 and A3 preserved                           ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

   TRAP handler alters registers so that A6 now points at system variables.

0880 MT_LINK       ADD.W    D0,D0                  ;double function number
                   LEA      4(A6,D0.W),A1          ;A1 points at appropriate linked list
                   JSR      UT_LINK(PC)            ;link item into list
                   BRA.S    EXIT_UNL

Ú----------------------------------------------------------------------¿
³!MT_RXINT        UNLINK EXT INT HANDLER     (TRAP #1 WITH D0 = $1B)           ³
³!MT_RPOLL        UNLINK POLLED TASK         (TRAP #1 WITH D0 = $1D)           ³
³!MT_RSCHD        UNLINK SCHEDULER TASK      (TRAP #1 WITH D0 = $1F)           ³
³!MT_RIOD         UNLINK I/O DRIVER          (TRAP #1 WITH D0 = $21)           ³
³!MT_RDD          UNLINK DIRECTORY DRIVER    (TRAP #1 WITH D0 = $23)           ³
Ã----------------------------------------------------------------------´
³=MT_UNLNK        UNLINK ITEM FROM LIST                                        ³
Ã----------------------------------------------------------------------´
³ENTRY:           A0.L     address of link to be removed                       ³
³                                                                              ³
³EXIT:            D0 and A1  corrupted                                         ³
³                 D1,D2,D3,A0,A2,A2 and A3 preserved                           ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

   TRAP handler alters registers so that A6 now points at system variables.

088C MT_UNLNK      ADD.W    D0,D0                  ;double function number
                   LEA      2(A6,D0.W),A1          ;A1 points at appropriate linked list
                   JSR      UT_UNLNK(PC)           ;unlink item from list
0896 EXIT_UNL      BRA      CLEANUP


; part3
                                  THE SCHEDULER

2.4 Multi-tasking.

2.4.1 Frame interrupts.

Ú----------------------------------------------------------------------¿
³=FRAMEINT        HANDLE FRAME INTERRUPTS                                      ³
Ã----------------------------------------------------------------------´
³ENTRY:           A6.L     QDOS system variables                               ³
³                                                                              ³
³EXIT:            none                                                         ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

   This interrupt primarily controls the multitasking features of QDOS.
   It normally occurs about fifty times a second for a British QL, and at
   a slightly higher rate (sixty times a second) for the continental and the
   American versions. This routine first of all causes a linked list of some
   system house keeping routines to be executed and then if the CPU was in
   user mode when the interrupt occured, the scheduler is entered.

089A FRAMEINT      ADDQ.W   #1,SV.POLLM(A6)        ;increment poll count
                   BVC.S    POLLM_OK               ;jump forward if less than 127
                   SUBQ.W   #1,SV.POLLM(A6)        ;otherwise reduce back to 127
08A4 POLLM_OK      MOVEM.L  D0-6/A0-4,-(A7)        ;save registers
                   MOVEQ    #-8,D0                 ;offset to assumed start of linkage
                   MOVEQ    #1,D3                  ;block
                   MOVEA.L  SV.PLIST(A6),A0        ;A0 points at start of polled tasks list
                   JSR      EXECLIST(PC)           ;execute the linked list
                   MOVEM.L  (A7)+,D0-6/A0-4        ;restore registers
                   MOVE.B   SV.PCINT(A6),D7        ;get copy of interrupt register
                   ORI.B    #%00001000,D7          ;and acknowledge interrupt
                   MOVE.B   D7,PC_INTR             ;update interrupt register
                   BTST     #5,12(A7)              ;supervisor mode when called ?
                   BNE      EXITTRAP               ;exit if so otherwise enter scheduler

2.4.2 Scheduler.

Ú----------------------------------------------------------------------¿
³=SCHEDULER       RE-ARRANGE JOBS TO IMPLEMENT MULTI-TASKING                   ³
Ã----------------------------------------------------------------------´
³ENTRY:           A5.L     saved SUPERBASIC registers in order D7,A5,A6        ³
³                 A6.L     system variables                                    ³
³                                                                              ³
³EXIT:            none                                                         ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

   All machines which claim to support multitasking in whatever form, must
   have a software routine or hardware mechanism known as a scheduler. The
   purpose of the scheduler is to allow the most suitable job (defined in a
   multitude of different ways) a period of the CPU's processing time. It is
   also the purpose of the scheduler to make this transition invisible to
   the user and to allow all jobs that are capable of being run, a chance to
   run. In general the choice of which job to run next is based on its usage
   of the machines resources such as it's I/O devices particularly if these
   are not shareable as is the case with all of the QL's I/O resouces apart
   from the Screen and console devices.

   The basic scheme then is to switch control from one job to another when
   it is using an I/O device and hence waiting for it to finish. In order to
   implement this scheme, a priority is given to a task when it is created
   and this priority takes on several values depending on the status of the
   job at that time. The scheduler then steadily increments this priority
   until such a time as the job has the highest priority of all jobs in the
   system. At this stage the job will be allowed to run and it's priority
   will be set to zero. The job is also allocated a priority increment when
   it is created and the scheduler increments the job priority by this value
   during every Frame interrupt. In this way, all the jobs will obtain CPU
   time in relation to there priority increment, job's having a large value
   as an increment will execute more often than jobs with a low increment.

   When the machine is first switched on, only one job is normally running,
   which is SUPERBASIC and all jobs are actually subservient to it as it can
   never be removed from the system. This is often known as the null job or
   the one process which is always running in a multitasking system to keep
   the scheduler happy (i.e. the sceduler must never fail to find a job).

08D0 SCHEDULE      JSR      SHUTDOWN(PC)           ;save current job's details in header
08D4 CHKPOLLM      MOVE.W   SV.POLLM(A6),D3        ;get number of polled interrupts missed
                   CLR.W    SV.POLLM(A6)           ;and reset it to zero
                   ADDQ.W   #1,SV.RAND(A6)         ;increment system random number
                   MOVEQ    #-16,D0                ;offset to start of linkage block
                   MOVEA.L  SV.SHLST(A6),A0        ;A0 points at scheduler linked list
                   JSR      EXECLIST(PC)           ;execute the list

2.4.3 Job status.

Ú----------------------------------------------------------------------¿
³=MT_SUSJB        SUSPEND A JOB              (TRAP #1 WITH D0 = $08)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     job ID (-1 if current job)                          ³
³                 D3.W     timeout                                             ³
³                 A1.L     address of byte to be zeroed on job's release       ³
³                                                                              ³
³EXIT:            A0.L     location of job's header                            ³
³                 D1,D2,D3,A1,A2 and A3 preserved                              ³
³                                                                              ³
³ERRORS:          ERR.NJ   invalid job ID                                      ³
À----------------------------------------------------------------------Ù

   Suspends a job for a number of frame interrupt periods as specified by
   the timeout. If this is -1 then the job is suspended indefinitely.
   TRAP handler alters registers so that A6 now points at system variables.

08EA MT_SUSJB      JSR      DECIDE(PC)             ;find out which job is to be next one
                   TST.L    D0                     ;check timeout
                   BLT.S    CHKPOLLM               ;suspend indefinitely if negative
                   MOVE.L   D0,SV.JBPNT(A6)        ;signal "current job suspended"
                   JSR      STARTUP(PC)            ;run next job for one frame
                   JSR      CHKJBID(PC)            ;check job ID, A0 points at header on exit
                   MOVE.W   D3,JB.STAT(A0)         ;set priority to timeout
                   MOVE.L   A1,JB.HOLD(A0)         ;and address to be cleared
                   MOVEQ    #0,D0                  ;signal "no errors"
                   BRA      SCHEDULER

Ú----------------------------------------------------------------------¿
³=MT_RELJB        RELEASE A SUSPENDED JOB    (TRAP #1 WITH D0 = $09)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     job ID                                              ³
³                                                                              ³
³EXIT:            A0.L     location of job's header                            ³
³                 D1,D2,D3,A1,A2 and A3 preserved                              ³
³                                                                              ³
³ERRORS:          ERR.NJ   invalid job ID                                      ³
À----------------------------------------------------------------------Ù

   This routine performs the reverse operation to MT_SUSJB in that it will
   release from suspension, a job which was suspended for whatever reason.
   TRAP handler alters registers so that A6 now points at system variables.

090C MT_RELJB      JSR      CHKJBID(PC)            ;check job ID,A0 points at header on exit
                   TST.W    JB.STAT(A0)            ;is job already possibly active ?
                   BEQ.S    EXIT_REL               ;enter scheduler if so
                   CLR.W    JB.STAT(A0)            ;signal "possibly active"
                   MOVE.L   JB.HOLD(A0),D0         ;D0 points at location to be cleared on release
                   BEQ.S    EXIT_REL               ;exit if number location specified
                   MOVEA.L  D0,A0                  ;otherwise copy address to A0
                   SF       (A0)                   ;and clear the location
0924 EXIT_REL      MOVEQ    #0,D0                  ;then signal "no errors"
                   BRA      SCHEDULER              ;and enter the scheduler

Ú----------------------------------------------------------------------¿
³=MT_PRIOR        CHANGE JOB PRIORITY        (TRAP #1 WITH D0 = $0B)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     job ID (-1 if current)                              ³
³                 D2.B     new priority (0 for inactive)                       ³
³                                                                              ³
³EXIT:            A0.L     address of job's header                             ³
³                 D1,D2,D3,A1,A2 and A3 preserved                              ³
³                                                                              ³
³ERRORS:          ERR.NJ   invalid job ID                                      ³
À----------------------------------------------------------------------Ù

   TRAP handler alters registers so that A6 now points at system variables.

092A MT_PRIOR      JSR      CHKJBID(PC)            ;check job ID, A0 points at header on exit
                   MOVE.B   D2,JB.PRINC(A0)        ;set to new priority
                   BNE.S    EXIT_ACT               ;enter scheduler if this was not zero
                   SF       JB.PRIOR(A0)           ;otherwise signal "job is inactive"
                   BRA.S    EXIT_ACT               ;and enter the scheduler anyway

Ú----------------------------------------------------------------------¿
³=MT_ACTIV        ACTIVATE A JOB             (TRAP #1 WITH D0 = $0A)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     job ID                                              ³
³                 D2.B     priority (0 - 127)                                  ³
³                 D3.W     timeout                                             ³
³                                                                              ³
³EXIT:            A0.L     address of job's header                             ³
³                 D1,A1 and A2 preserved                                       ³
³                 D2,D3 and A3 corrupted                                       ³
³                                                                              ³
³ERRORS:          ERR.NC   not complete (job is already active)                ³
³                 ERR.NJ   invalid job ID                                      ³
À----------------------------------------------------------------------Ù

   The selected job's priority is set to the new value given and the job is
   activated. If the timeout specified is zero then the current job will be
   allowed to continue executing, otherwise the current job will wait until
   this job is finished before continueing.

093A MT_ACTIV      JSR      CHKJBID(PC)            ;check job ID, A0 points at header on exit
                   TST.B    JB.PRINC(A0)           ;is job already active ?
                   BNE.S    STILLACT               ;exit if so
                   MOVE.B   D2,JB.PRINC(A0)        ;otherwise set to new priority
                   MOVE.L   JB.START(A0),JB.PC(A0)
                   TST.W    D3                     ;timeout zero ?
                   BEQ.S    EXIT_ACT               ;continue with current job if so

   New job is to override the current one so signal status in job headers of
   the current job and the new job.

                   ST       JB.WFLAG(A0)           ;signal "job waiting for completion"
                   JSR      GETJBID(PC)            ;A3 points at waiting jobs header
                   MOVE.L   D0,JB.WJOB(A0)         ;set waiting job's ID to current ID
                   MOVE.W   #-2,JB.STAT(A3)        ;signal "waiting for completion"
0964 EXIT_ACT      MOVEQ    #0,D0                  ;and "no errors"
0966 L00966        BRA      SCHEDULER              ;activate new or continue current job

096A STILLACT      MOVEQ    #ERR.NC,D0             ;signal "not complete"
                   BRA.S    L00966

2.4.4 Scheduling mechanism.

Ú----------------------------------------------------------------------¿
³=SHUTDOWN        COPY A JOB'S DETAILS TO JOB HEADER'S STORAGE AREA            ³
Ã----------------------------------------------------------------------´
³ENTRY:           A5.L     copy of user stack pointer                          ³
³                                                                              ³
³EXIT:            A5.L     stack above saved registers                         ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

   Closing down a job essentially consists of saving the volatile status of
   the job which means all the registers, the program counter and the CPU
   status register.

   All the general registers have been saved in the interrupt handler and
   A5 points at the top of the supervisor stack.

096E SHUTDOWN      MOVE.L   A6,-(A7)               ;save A6
                   MOVEA.L  SV.JBPNT(A6),A6        ;A6 points at current job table entry
                   MOVEA.L  (A6),A6                ;and then at job header
                   TST.B    JB.PRIOR(A6)           ;is job inactive ?
                   BEQ.S    L00982                 ;jump forward if so
                   MOVE.B   #1,JB.PRIOR(A6)        ;otherwise set it to 1
0982 L00982        MOVEM.L  D0-7/A0-4,JB.D0(A6)    ;copy registers to storage
                   MOVE.L   (A5)+,JB.D7(A6)        ;copy registers saved in system
                   MOVE.L   (A5)+,JB.A5(A6)        ;interrupt handler [SYSINT] to
                   MOVE.L   (A5)+,JB.A6(A6)        ;job header storage area
                   MOVE.L   USP,A0
                   MOVE.L   A0,JB.A7(A6)           ;copy of user stack pointer
                   MOVE.W   (A5)+,JB.SR(A6)        ;copy of status register
                   MOVE.L   (A5)+,JB.PC(A6)        ;and program counter when interrupted
                   MOVEA.L  (A7)+,A6               ;restore A6
                   RTS

Ú----------------------------------------------------------------------¿
³=DECIDE          FIND OUT WHICH JOB IS TO BE THE NEXT ONE                     ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     current job's  ID                                   ³
³                 D3.W     timeout                                             ³
³                                                                              ³
³EXIT:            D1.L     next job's ID                                       ³
³                                                                              ³
³ERRORS:          ERR.NJ   invalid job                                         ³
À----------------------------------------------------------------------Ù

   Implement the basic scheduling algorithm by scanning the job table and
   checking each job's priority in turn until the job with the highest
   priority is found.

09A6 DECIDE        MOVEQ    #ERR.NJ,D0             ;signal "invalid job"
                   MOVEQ    #0,D1                  ;clear D1
                   MOVEA.L  SV.JBPNT(A6),A2        ;A2 points at current job table entry
                   MOVEA.L  A2,A4                  ;copy pointer to A4
                   MOVE.W   SV.JBMAX(A6),D2        ;set D2 to largest job number to date
                   LSL.W    #2,D2                  ;form offset into table
                   MOVEA.L  SV.JBBAS(A6),A3        ;A3 points at base of table
                   ADDA.W   D2,A3                  ;and add offset to base
09BC L009BC        ADDQ.W   #4,A2                  ;A2 points at entry (jobmax + 1)
                   CMPA.L   A3,A2                  ;current job ?
                   BLE.S    L009C6                 ;jump forward if < max
                   MOVEA.L  SV.JBBAS(A6),A2        ;A2 points at job table base
09C6 L009C6        TST.B    (A2)                   ;entry free ?
                   BLT.S    L00A0C                 ;jump forward if it is
                   MOVEA.L  (A2),A0                ;A0 points at job header if not
                   TST.B    JB.PRINC(A0)           ;job inactive ?
                   BEQ.S    L00A0C                 ;jump forward if it is
                   TST.W    JB.STAT(A0)            ;check job status
                   BEQ.S    L009EE                 ;jump if "possibly active"
                   BLT.S    L00A0C                 ;and if suspended
                   SUB.W    D3,JB.STAT(A0)         ;subtract timeout
                   BGT.S    L00A0C                 ;jump forward if still active
                   CLR.W    JB.STAT(A0)            ;otherwise signal "possibly active"
                   MOVE.L   JB.HOLD(A0),D2         ;get address to be cleared
                   BEQ.S    L009EE                 ;and jump forward if none specified
                   MOVEA.L  D2,A1                  ;copy address
                   SF       (A1)                   ;and clear the location
09EE L009EE        MOVE.B   JB.PRIOR(A0),D2        ;get job priority
                   BEQ.S    L009FE                 ;jump forward if inactive
                   ADD.B    JB.PRINC(A0),D2        ;update priority
                   BCC.S    L00A00                 ;and jump forward unless it was waiting
                   ST       D2                     ;signal "suspended"
                   BRA.S    L00A00

09FE L009FE        MOVEQ    #1,D2                  ;signal "run for one frame"
0A00 L00A00        MOVE.B   D2,JB.PRIOR(A0)        ;set to new priority
                   CMP.B    D1,D2                  ;priority ok ?
                   BLS.S    L00A0C                 ;jump if so
                   MOVE.L   A2,D0                  ;copy pointer to job table entry
                   MOVE.B   D2,D1                  ;and priority to D1 for next job
0A0C L00A0C        CMPA.L   A4,A2                  ;current job ?
                   BNE.S    L009BC                 ;next job entry if not
                   RTS

Ú----------------------------------------------------------------------¿
³=STARTUP         COPY A JOB'S DETAILS FROM JOB HEADER'S STORAGE AREA          ³
Ã----------------------------------------------------------------------´
³ENTRY:           A6.L     system variables                                    ³
³                                                                              ³
³EXIT:            ALL REGISTERS SET TO VALUES WHEN LAST SHUT DOWN              ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

   Starting up a job is more or less the reverse of shutting it down with a
   slight difference. When the job starts it should be running in the same
   CPU mode as it was when it was shutdown and this can only have been user
   mode as multitasking only operates in user mode. To achieve this the RTE
   instruction is used to restart the job.

0A12 STARTUP       MOVEA.L  SV.JBPNT(A6),A0        ;A0 points at current job table entry
                   MOVEA.L  (A0),A0                ;and then at job's header
                   ADDA.W   #$16,A7                ;point at top of saved registers
                   MOVE.L   JB.PC(A0),-(A7)        ;simulate exception by copying job's
                   MOVE.W   JB.SR(A0),-(A7)        ;data to supervisor stack

   Use the job's RAM exception vector table as the system one.

                   MOVE.L   JB.TRAPV(A0),SV.TRAPV(A6)

                   MOVEA.L  JB.A7(A0),A1           ;A1 points at job's stack
                   MOVE.L   A1,USP                 ;and set up user stack pointer

   Finally set up all the address and data registers and start the job by
   using the "return from exception" instruction.

                   MOVEM.L  JB.D0(A0),D0-7/A0-6
                   RTE

Ú----------------------------------------------------------------------¿
³=EXECLIST        EXECUTE LINKED LIST OF TASKS                                 ³
Ã----------------------------------------------------------------------´
³ENTRY:           D0.W     offset to start of linkage block                    ³
³                 D3.W     number of polled interrupts missed                  ³
³                 A0.L     start of linked list                                ³
³                                                                              ³
³EXIT:            A0.L     0 (end of list reached)                             ³
³                 D3,A3    corrupted                                           ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

   QDOS uses interrupts to control multitasking and I/O. Each different type
   of interrupt has associated with it a linked list of tasks to be executed
   every time that interrupt occurs. The frame interrupt has a polled tasks
   linked list, the external interrupt has on switch on an empty list and
   finally there is the scheduler linked list. This routine is used to run
   the tasks in these lists, each of them until completion. It is called by
   each of the interrupt handlers in turn.

   Each list entry consists of two long words. The first long word gives the
   address of the next routine in the linked list. The second long word is
   the actual address of the routine.

0A38 EXECLIST      MOVE.W   D0,-(A7)               ;save offset
0A3A NEXTTASK      MOVEA.L  A0,A3                  ;A3 points at link to next block in list
                   ADDA.W   (A7),A3                ;and then at start of linkage block
                   MOVE.L   A0,-(A7)               ;save pointer to link
                   BEQ.S    LIST_END               ;exit if end of list (null pointer)
                   MOVE.W   D3,-(A7)               ;save poll count
                   ANDI.W   #%01111111,D3          ;form timeout in range 0 - 127
                   MOVEA.L  4(A0),A0               ;get address of task
                   JSR      (A0)                   ;call it
                   MOVE.W   (A7)+,D3               ;restore poll count
                   MOVEA.L  (A7)+,A0               ;and pointer to list
                   MOVEA.L  (A0),A0                ;then A0 points at next block
                   BRA.S    NEXTTASK               ;execute next task
0A56 LIST_END      ADDQ.L   #6,A7                  ;ignore saved registers
                   RTS

                           THE SIMPLE DEVICE DRIVERS

2.5 Simple device drivers.

   The simple device drivers and the directory device drivers are linked
   together as a list pointed to by the system variables SV.DRLST and
   SV.DDLST respectively. This means that by adding new device drivers to
   the start of the lists using TRAP's MT.LIOD and MT.LDD, we can override
   if necessary, the internal drivers in preference to the new user written
   ones. Completely new devices can be be added to the system such as disc
   drive controllers,mouse drivers and printer drivers.

   All the simple device drivers have a four long word linkage block header
   The first entry gives the address of the next linkage block in the list.
   The next three entries give the addresses of the I/O, channel open and
   channel close routines.

   This is all that is required for the I/O sub system (IOSS) to use the
   device driver. QDOS I/O is designed to be "device independant" which in
   practise really means that all the user specifies is the channel ID of
   the required device and the operation to be performed. Obviously though,
   different functions are performed by some devices than others and so to
   cater for this, the functions are split into sections.

   The first section deals with bytes or strings of bytes and is common to
   all the device drivers. The second section is used for the screen and
   console devices and handles the graphics faclities. The third and final
   section covers the file system.

   All I/O is based on the use of channel definition blocks in the common
   heap and these contain all the information relating to that channel.
   No other information can be used by the IOSS as it will not find it. A
   complete list of the different channel definition blocks is given in the
   appendix.

2.5.1 Serial device driver

   This is the first of the simple device drivers and handles the serial
   ports of which there are two. The actual control of the ports is done by
   the IPC and this handles the baud rates and handshake details.
   Conversion of chr$ 10 to and from chr$ 13 is performed if specified by
   the parameters after the device name when the channel is opened.
   The general name is SERnphz where:-

    n = port number (1 or 2)
    p = parity type (even, odd, mark or space)
    h = handshaking (Ignore or use handshake)
    z = protocol as follows:

    R = raw data with number EOF (chr$ 26) terminator
    Z = raw data with an EOF terminator
    C = as for Z with conversion from chr$ 10 to chr$ 13

   and the default is SER1R. Note that only one channel can be open to a
   serial port at any time.

0A5A SER_LB        DC.L     PIPE_LB                ;absolute link to next block in list
                   DC.L     SER_IO                 ;I/O routine address
                   DC.L     SEROPEN                ;open channel routine address
                   DC.L     SERCLOSE               ;close channel routine address

Ú----------------------------------------------------------------------¿
³=SEROPEN         OPEN A SERIAL CHANNEL      (TRAP #3 WITH D0 = $01)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     job ID (-1 if current)                              ³
³                 A0.L     address of channel name                             ³
³                                                                              ³
³EXIT:            D1.L     job ID                                              ³
³                 A0.L     new channel ID                                      ³
³                 D2,D3,A1,A2 and A3 preserved                                 ³
³                                                                              ³
³ERRORS:          ERR.NJ   invalid job ID                                      ³
³                 ERR.OM   out of memory                                       ³
³                 ERR.NO   too many channels                                   ³
³                 ERR.NF   device not found                                    ³
³                 ERR.IU   device in use                                       ³
³                 ERR.BN   bad device name                                     ³
À----------------------------------------------------------------------Ù

0A6A SEROPEN       SUBQ.W   #8,A7                  ;create space for parameter block
                   MOVEA.L  A7,A3                  ;copy stack pointer to A3
                   JSR      IO_NAME(PC)            ;decode the device name

   Return points for the three decode device name errors.

                   BRA.S    SER_EXIT               ;branch if name not found
                   BRA.S    SER_EXIT               ;branch if bad device name
                   BRA.S    SERNMOK                ;branch if name ok

   Data for serial device name.

0A78 SERDATA       DC.W     3,"SER"                ;name length and device name
                   DC.W     4                      ;number of parameters following name
                   DC.W     -1,1                   ;port number (default = 1)
                   DC.W     4,"OEMS"               ;parity (odd, even, mark or space)
                   DC.W     2,"IH"                 ;handshake or ignore
                   DC.W     3,"RZC"                ;protocol (raw, ctrl z or convert)

   Command table for IPC.

0A94 IPC_OPEN      DC.B     2,0,0,0,0,0,1,0        ;"open RS232 channel on port 1"
                   DC.B     3,0,0,0,0,0,1,0        ;"open RS232 channel on port 2"
0AA4 IPC_CLOS      DC.B     4,0,0,0,0,0,1,0        ;"close RS232 channel on port 1"
                   DC.B     5,0,0,0,0,0,1,0        ;"close RS232 channel on port 2"

0AB4 SE_ERRNF      MOVEQ    #ERR.NF,D0             ;signal "not found"
                   BRA.S    SER_EXIT

0AB8 SE_ERRIU      MOVEQ    #ERR.IU,D0             ;signal "in use"
0ABA SER_EXIT      ADDQ.W   #8,A7                  ;ignore parameter block
                   ANDI.W   #$F8FF,SR              ;enable interrupts
                   RTS

0AC2 SERNMOK       ORI.W    #$0700,SR              ;disable interrupts
                   MOVE.W   (A7),D4                ;get port number
                   BLE.S    SE_ERRNF               ;exit if < 0
                   SUBQ.W   #2,D4
                   BGT.S    SE_ERRNF               ;or > 2
                   LEA      SV.SER1C(A6),A5        ;A5 points at port 1 system variable
                   LEA      IPC_OPEN(PC),A4        ;and A4 at IPC open command table
                   BLT.S    L00ADC                 ;jump forward if port 1 required
                   ADDQ.W   #4,A5                  ;otherwise A5 points at SV_SER2C
                   ADDQ.W   #8,A4                  ;and A4 at other command in table
0ADC L00ADC        MOVE.L   (A5),D0                ;then D0 points at queue header
                   BEQ.S    SER_OUTQ               ;and jump forward if number queue
                   MOVEA.L  D0,A0                  ;copy header address to A0 then
                   SUBA.W   #$20,A0                ;A0 points at start of channel definition block
                   BCLR     #7,SER.TXQ(A0)         ;has it been emptied ?
                   BNE.S    SER_INQ                ;jump forward if it has
                   BRA.S    SE_ERRIU               ;and exit with error if it has not

   Create the 228 byte buffer for serial channel.

0AF0 SER_OUTQ      MOVE.W   #$E4,D1                ;create space in heap for header
                   JSR      MM_ALCHP(PC)           ;find the space
                   BNE.S    SER_EXIT               ;and exit immediately if out of memory
                   MOVEQ    #81,D1                 ;O/P buffer length
                   LEA      SER.TXQ(A0),A2         ;A2 points at start of O/P queue
                   JSR      IO_QSET(PC)            ;set up an "empty" queue header

   An O/P queue either already exists and is empty or has been created.

0B04 SER_INQ       MOVEQ    #81,D1                 ;I/P buffer length
                   LEA      SER.RXQ(A0),A2         ;A2 points at start of I/P queue
                   JSR      IO_QSET(PC)            ;set up an "empty" queue header
                   MOVE.L   A2,(A5)                ;and initialise queue address pointer

   Copy queue parameters and flags from stack to newly created header.

                   MOVE.L   (A7),SER.CHNO(A0)      ;get port number again (1 or 2)
                   MOVE.L   4(A7),SER.TXHS(A0)     ;transmit handshake flag
                   SUBQ.W   #1,SER.TXHS(A0)        ;set to "ignore handshake" initially
                   SUBQ.W   #2,SER.PROT(A0)        ;and set protocol to "raw data"
                   BSR.S    SER_IPC                ;open RS232 channel on serial port
                   MOVEQ    #0,D0                  ;signal "no errors" then exit
                   BRA.S    SER_EXIT

Ú----------------------------------------------------------------------¿
³=SERCLOSE         CLOSE A SERIAL CHANNEL    (TRAP #3 WITH D0 = $02)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           A0.L     channel ID (-1 if current)                          ³
³                                                                              ³
³EXIT:            A0       corrupted                                           ³
³                 D1,D2,D3,A1,A2 and A3 preserved                              ³
³                                                                              ³
³ERRORS:          ERR.NC   channel not open                                    ³
À----------------------------------------------------------------------Ù

0B28 SERCLOSE      LEA      IPC_CLOSE(PC),A4       ;A4 points at IPC close command table
                   BTST     #1,SER.CHNO(A0)        ;is port 2 required ?
                   BEQ.S    SERPORT1               ;jump forward if not
                   ADDQ.L   #8,A4                  ;A4 points at command for port 2 if so
0B36 SERPORT1      BSR.S    SER_IPC                ;tell IPC to close the serial port
                   LEA      SER.TXQ(A0),A2         ;A2 points at O/P queue
                   JSR      IO_QEOF(PC)            ;insert an EOF marker
                   MOVEQ    #0,D0                  ;signal "no errors" and exit
                   RTS

Ú----------------------------------------------------------------------¿
³=SER_IPC         SEND IPC COMMAND TO OPEN OR CLOSE SERIAL PORT                ³
Ã----------------------------------------------------------------------´
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À----------------------------------------------------------------------Ù

0B44 SER_IPC       MOVE.L   A0,-(A7)               ;save header address
                   MOVEA.L  A4,A3                  ;copy pointer to command string to A3
                   JSR      IPC_CMND(PC)           ;and send the command then
                   MOVEA.L  (A7)+,A0               ;restore header address
                   RTS

Ú----------------------------------------------------------------------¿
³=SER_IO          GENERAL SERIAL I/O                                           ³
Ã----------------------------------------------------------------------´
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À----------------------------------------------------------------------Ù

0B50 SER_IO        JSR      IO_SERIO(PC)           ;general I/O handling
                   DC.L     SE_PEND                ;test for pending I/P
                   DC.L     SE_FBYTE               ;fetch a byte
                   DC.L     SE_SBYTE               ;send a byte
                   RTS

Ú----------------------------------------------------------------------¿
³=SE_PEND         TEST FOR PENDING I/P       (TRAP #3 WITH D0 = $00)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D3.W     timeout                                             ³
³                 A0.L     channel ID                                          ³
³                                                                              ³
³EXIT:            D1 and A1  corrupted                                         ³
³                 D2,D3,A0,A2 and A3 preserved                                 ³
³                                                                              ³
³ERRORS:          ERR.NC   number pending I/P                                  ³
³                 ERR.NO   invalid channel ID                                  ³
³                 ERR.EF   end of file                                         ³
À----------------------------------------------------------------------Ù

0B62 SE_PEND       LEA      SER.RXQ(A0),A2         ;A2 points at receive queue
                   JMP      IO_QTEST(PC)           ;test queue status for pending byte

Ú----------------------------------------------------------------------¿
³=SE_SBYTE        SEND A BYTE                (TRAP #3 WITH D0 = $05)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.B     byte to be sent                                     ³
³                 D3.W     timeout                                             ³
³                                                                              ³
³EXIT:            D1 and A1  corrupted                                         ³
³                 D2,D3,A0,A2 and A3 preserved                                 ³
³                                                                              ³
³ERRORS:          ERR.NC   not complete                                        ³
³                 ERR.NO   invalid channel ID                                  ³
À----------------------------------------------------------------------Ù

0B6A SE_SBYTE      CMPI.B   #10,D1                 ;is it a line feed ?
                   BNE.S    CHAR_OK1               ;jump forward if not
                   TST.B    SER.PROT+1(A0)         ;convert to carraige return ?
                   BLE.S    CHAR_OK1               ;jump if "raw data" chosen
                   MOVEQ    #13,D1                 ;otherwise convert
0B78 CHAR_OK1      MOVE.W   $SER.PAR(A0),D0        ;get parity and then offset from table
                   MOVE.B   PTABLE1(PC,D0.W),D0
                   JMP      PTABLE1(PC,D0.W)       ;jump to appropriate routine

   Send byte routine offset table for the five different parity's.

0B84 PTABLE1       DC.B     SPA_NONE -PTABLE1      ;number parity
                   DC.B     SPA_ODD  -PTABLE1      ;odd
                   DC.B     SPA_EVEN -PTABLE1      ;even
                   DC.B     SPA_MARK -PTABLE1      ;mark
                   DC.B     SPA_SPAC -PTABLE1      ;space
                   DC.B     0

   For odd parity calculate number of set bits and set bit 7 if odd.
   For even parity do above calculation and set if even.
   For mark parity just set bit seven and for space reset it.

   This is because each transmission consists of a stream of bits :
   one bit as a "start" bit then the eight bits of the character starting
   with bit 0 and finally one or two "stop" bits to terminate so that
   "space" parity means a space or reset bit prior to the stop bits and
   "mark" parity means a set bit prior to the stop bits.

0B8A SPA_MARK      BSET     #7,D1                  ;ensure "mark" before stop bits
0B8E SPA_NONE      LEA      SER.TXQ(A0),A2         ;A2 points at transmit queue
                   JSR      IO_QIN(PC)             ;insert the character
                   BRA.S    CHAR_OK2               ;then exit

0B98 SPA_SPAC      BCLR     #7,D1                  ;ensure "space" before stop bits
                   BRA.S    SPA_NONE               ;and insert character in queue

0B9E SPA_ODD       BSR.S    CHKPARIT               ;calculate even parity for character
                   BCHG     #7,D1                  ;and alter to odd
                   BRA.S    SPA_NONE               ;then insert

0BA6 SPA_EVEN      BSR.S    CHKPARIT               ;calculate even parity
                   BRA.S    SPA_NONE               ;and insert it into queue

Ú----------------------------------------------------------------------¿
³=SE_FBYTE        FETCH A BYTE               (TRAP #3 WITH D0 = $01)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D3.W     timeout                                             ³
³                 A0.L     channel ID                                          ³
³                                                                              ³
³EXIT:            D1.B     byte read                                           ³
³                 A1       corrupted                                           ³
³                 D2,D3,A0,A2 and A3 preserved                                 ³
³                                                                              ³
³ERRORS:          ERR.NC   not complete as number pending input                ³
³                 ERR.NO   invalid channel ID                                  ³
³                 ERR.EF   end of file                                         ³
À----------------------------------------------------------------------Ù

0BAA SE_FBYTE      LEA      SER.RXQ(A0),A2         ;A0 points at I/P queue
                   JSR      IO_QOUT(PC)            ;get a character from the queue
                   BNE.S    CHAR_OK2               ;and exit if EOF or empty
                   MOVE.W   SER.PAR(A0),D3         ;get chosen parity and then offset
                   MOVE.B   PTABLE2(PC,D3.W),D3
                   JMP      PTABLE2(PC,D3.W)       ;jump to appropriate parity handler

   Fetch byte routine offset table for the five different parity's.

0BC0 PTABLE2       DC.B     LPA_NONE -PTABLE2      ;number parity
                   DC.B     LPA_ODD  -PTABLE2      ;odd
                   DC.B     LPA_EVEN -PTABLE2      ;even
                   DC.B     LPA_MARK -PTABLE2      ;mark
                   DC.B     LPA_SPAC -PTABLE2      ;space
                   DC.B     0

0BC6 LPA_MARK      BCHG     #7,D1                  ;normally high for "mark" parity
                   BRA.S    LPA_SPAC               ;check character

0BCC LPA_ODD       BCHG     #7,D1                  ;normally high for "even" parity
0BD0 LPA_EVEN      BSR.S    CHKPARIT               ;calculate even parity for character
0BD2 LPA_SPAC      BTST     #7,D1                  ;ok ?
                   BEQ.S    LPA_NONE               ;branch if so otherwise
                   MOVEQ    #ERR.TE,D0             ;signal "transmit error"
0BDA LPA_NONE      CMPI.B   #13,D1                 ;is it a carraige return ?
                   BNE.S    CHAR_OK2               ;exit if not
                   TST.B    SER.PROT+1(A0)         ;convert to line feed ?
                   BLE.S    CHAR_OK2               ;exit if not
                   MOVEQ    #10,D1                 ;otherwise convert it
0BE8 CHAR_OK2      RTS

   Check parity of byte.

0BEA CHKPARIT      MOVEQ    #6,D3                  ;7 bits to check
                   MOVE.B   D1,D4                  ;duplicate byte
0BEE NEXTPBIT      ROR.B    #1,D1                  ;do the calculation
                   EOR.B    D1,D4                  ;by a standard method
                   DBF      D3,NEXTPBIT            ;process next bit
                   ROXL.B   #1,D4                  ;move parity bit into carry flag
                   ROXR.B   #1,D1                  ;and then into top bit of D1 with the
                   RTS                             ;bottom 7 bits of D1 as before

2.5.2 Pipe device driver.

   A pipe is a short section of memory used as a queue. A pipe can either be
   an input one or an output one. When an input pipe is opened the channel
   ID of the corresponding output pipe must be specified. Information is put
   into the queue at one end and read from the other.

0BFC PIPE_LB       DC.L     CON_LB                 ;link to next block
                   DC.L     IO_SERQ                ;I/O routine
                   DC.L     PIPEOPEN               ;open routine
                   DC.L     PIPECLOS               ;close routine

Ú----------------------------------------------------------------------¿
³=PIPEOPEN        OPEN A PIPE CHANNEL        (TRAP #2 WITH D0 = $01)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     job ID (-1 if current)                              ³
³                 D3.L     O/P pipe ID if I/P pipe requested                   ³
³                 A0.L     address of channel name                             ³
³                                                                              ³
³EXIT:            D1.L     job ID                                              ³
³                 A0.L     new channel ID                                      ³
³                 D2,D3,A1,A2 and A3 preserved                                 ³
³                                                                              ³
³ERRORS:          ERR.NJ   invalid job ID                                      ³
³                 ERR.OM   out of memory                                       ³
³                 ERR.NO   too many channels                                   ³
³                 ERR.NF   device not found                                    ³
³                 ERR.IU   pipe in use                                         ³
³                 ERR.BN   pipe parameters wrong                               ³
À----------------------------------------------------------------------Ù

   TRAP handler alters registers so that A6 now points at system variables and
   A7 points at parameter block.

0C0C PIPEOPEN      SUBQ.W   #2,A7                  ;create space for parameter block
                   MOVEA.L  A7,A3                  ;copy stack pointer to A3
                   JSR      IO_NAME(PC)            ;decode device name

   Return points for the three decode device name errors.

                   BRA.S    PP_EXIT                ;branch if name not found
                   BRA.S    PP_EXIT                ;branch if bad device name
                   BRA.S    PIPENMOK               ;branch if name ok

   Data for pipe device name.

0C1A PIPEDATA      DC.W     4,"PIPE"               ;name length and device name
                   DC.W     1                      ;number of parameters following name
                   DC.W     " _",0                 ;buffer length (0 if I/P pipe)

   All the parameters for a pipe device have been checked and the buffer
   length word placed in the parameter block.

0C26 PIPENMOK      MOVE.W   (A7),D1                ;is an I/P pipe required ?
                   BEQ.S    PP_INPUT               ;jump forward if so

   Total channel definition block length = $18 bytes for the IOSS + 8 bytes
   for the pipe information + $11 bytes for the O/P queue header + the O/P
   buffer length giving ($31 + buffer) bytes.

                   ADDI.W   #$31,D1                ;total length = block + buffer
                   JSR      MM_ALCHP(PC)           ;find the space, A0 points at area on exit
                   BNE.S    PP_EXIT                ;exit if out of memory
                   MOVE.W   (A7),D1                ;get buffer length again
                   ADDQ.W   #1,D1                  ;add one for EOF
                   LEA      CH.QEND(A0),A2         ;A2 points at O/P queue header
                   JSR      IO_QSET(PC)            ;set up an "empty" queue header
                   MOVE.L   A2,CH.QOUT(A0)         ;and pointer to O/P queue
                   BRA.S    PIPE_OK

   An I/P pipe is required so we must first find the corresponding O/P
   pipe's location.

0C46 PP_INPUT      MOVEA.W  D3,A2                  ;get corresponding O/P queue ID
                   ADDA.L   A2,A2                  ;form offset into channel table
                   ADDA.L   A2,A2
                   ADDA.L   SV.CHBAS(A6),A2        ;and add to base of table
                   MOVEA.L  (A2),A2                ;A2 points at O/P channel definition block
                   CMPI.L   #PIPE_LB,CH.DRIVR(A2)
                   BNE.S    PP_ERRBP               ;exit if not a pipe device
                   MOVE.L   A2,-(A7)               ;save pointer
                   MOVEQ    #$20,D1                ;length of new definition block
                   JSR      MM_ALCHP(PC)           ;find the space, A0 points at area on exit
                   MOVEA.L  (A7)+,A2               ;restore pointer
                   BNE.S    PP_EXIT                ;and exit if out of memory
                   LEA      CH.QEND(A2),A2         ;A2 points at start of O/P queue header
                   MOVE.L   A0,(A2)                ;point O/P channel at I/P queue and
                   MOVE.L   A2,CH.QIN(A0)          ;I/P channel at O/P queue

   On exit A0 points at channel definition block and A2 at O/P queue header.

0C72 PIPE_OK       MOVEQ    #0,D0                  ;signal "no errors"
0C74 PP_EXIT       ADDQ.W   #2,A7                  ;ignore parameter block
                   RTS

0C78 PP_ERRBP      MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
                   ADDQ.W   #2,A7                  ;ignore parameter block
                   RTS

Ú----------------------------------------------------------------------¿
³=PIPECLOSE       CLOSE A PIPE CHANNEL       (TRAP #2 WITH D0 = $02)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           A0.L     channel ID                                          ³
³                                                                              ³
³EXIT:            A0       corrupted                                           ³
³                 D1,D2,D3,A1,A2 and A3 preserved                              ³
³                                                                              ³
³ERRORS:          ERR.NC   channel not open                                    ³
À----------------------------------------------------------------------Ù

   TRAP handler alters registers so that A0 now points at channel definition blo
   and A6 at system variables.

0C7E PIPECLOS      TST.L    CH.QIN(A0)             ;I/P or O/P pipe ?
                   BNE.S    INPIPE                 ;jump forward if I/P pipe
                   LEA      CH.QEND(A0),A2         ;A2 points at queue header
                   TST.L    (A2)                   ;queue empty ?
                   BEQ.S    PIPERECL               ;reclaim space if so
                   JMP      IO_QEOF(PC)            ;signal "finished" if not

0C90 INPIPE        MOVE.L   CH.QIN(A0),-(A7)       ;save address of I/P queue
                   BSR.S    PIPERECL               ;reclaim heap space for O/P
                   MOVEA.L  (A7)+,A2               ;restore address
                   LEA      -$20(A2),A0            ;A0 points at channel definition block
                   TST.B    (A2)                   ;job finished with pipe ?
                   BLT.S    PIPERECL               ;reclaim heap space for I/P if so
                   CLR.L    (A2)                   ;otherwise signal "finished"
                   MOVEQ    #0,D0                  ;then "no errors"
                   RTS

0CA6 PIPERECL      JMP      MM_RECHP(PC)           ;reclaim common heap space at A0

2.5.3 Console and screen device driver.

   This is the main screen device driver and is used for printing on the
   screen and for drawing graphics. It also handles reading chcracters from
   the keyboard unlike the SCR driver which does not. Every console channel
   has associated with it a window on the screen and the size and position
   of this window must be specified when the channel is opened by parameters
   after the name. For a console channel, the input buffer size must also be
   specified. When the channel is opened the input buffer is linked into a
   list of similar input buffers and the buffer which the keyboard driver is
   to use is specified by pressing the CTRL C key. The corresponding window
   cursor also associated with the channel will start to flash when it is in
   use by the keyboard driver.

0CAA CON_LB        DC.L     NET_LB                 ;link to next block
                   DC.L     CON_IO                 ;I/O routine
                   DC.L     CONOPEN                ;open routine
                   DC.L     CONCLOSE               ;close routine

Ú----------------------------------------------------------------------¿
³=CONOPEN         OPEN A CONSOLE CHANNEL     (TRAP #2 WITH D0 = $01)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     job ID (-1 if current)                              ³
³                 A0.L     address of channel name                             ³
³                                                                              ³
³EXIT:            D1.L     job ID                                              ³
³                 A0.L     new channel ID                                      ³
³                 D2,D3,A1,A2 and A3 preserved                                 ³
³                                                                              ³
³ERRORS:          ERR.NJ   invalid job ID                                      ³
³                 ERR.OM   out of memory                                       ³
³                 ERR.NO   too many channels                                   ³
³                 ERR.NF   device not found                                    ³
³                 ERR.IU   device in use                                       ³
³                 ERR.BN   device parameters wrong                             ³
À----------------------------------------------------------------------Ù

   TRAP handler alters registers so that A6 now points at system variables
   and A7 points at parameter block.

0CBA CONOPEN       SUBA.W   #$A,A7                 ;create space for parameter block
                   MOVEA.L  A7,A3                  ;copy stack pointer to A3
                   JSR      IO_NAME(PC)            ;decode device name

   Return points for the three decode device name errors.

                   BRA.S    TRY_SCR                ;branch if name not found
                   BRA.S    SCR_EXIT               ;branch if bad device name
                   BRA.S    CONNMOK                ;branch if name ok

   Data for console device name.

0CCA CONDATA       DC.W     3,"CON"                ;name length and device name
                   DC.W     5                      ;number of parameters following name
                   DC.W     " _",448               ;window width
                   DC.W     " X",180               ;window height
                   DC.W     " A",32                ;window x co-ord of LHS
                   DC.W     " X",16                ;window y co-ord of top
                   DC.W     " _",128               ;I/P buffer length

   All the parameters for a console device have been checked and placed in
   the parameter block.

0CE6 CONNMOK       MOVEQ    #$76,D1                ;channel definition block length
                   ADD.W    $8(A7),D1              ;add length of I/P buffer required
                   BSR.S    SCROPEN                ;set up the channel if possible
                   BNE.S    SCR_EXIT               ;and exit if out of memory

   The channel has been created and A0 points at channel definition block.

                   LEA      SD.KBD(A0),A2          ;A2 points at SD_KBD
                   SUBI.W   #$74,D1                ;D1 = length of queue
                   JSR      IO_QSET(PC)            ;set up an "empty" queue header
                   MOVEA.L  SV.KEYQ(A6),A3         ;A3 points at current keyboard queue
                   MOVE.L   A3,D3                  ;copy address to D3
                   BNE.S    SCR_NEWQ               ;and jump forward if there is a queue
                   MOVE.L   A2,(A2)                ;otherwise link into queue list
                   MOVE.L   A2,SV.KEYQ(A6)         ;and set pointer to new queue
                   BRA.S    SCR_OK

0D0C SCR_NEWQ      MOVE.L   (A3),(A2)              ;insert pointer to current queue into
                   MOVE.L   A2,(A3)                ;pointer to next queue for this block
                   BRA.S    SCR_OK

Ú----------------------------------------------------------------------¿
³=TRY_SCR         CHECK IF A SCREEN CHANNEL WAS SPECIFIED INSTEAD              ³
Ã----------------------------------------------------------------------´
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À----------------------------------------------------------------------Ù

0D12 TRY_SCR       JSR      IO_NAME(PC)            ;decode device name

   Return points for the three decode device name errors.

                   BRA.S    SCR_EXIT               ;branch if name not found
                   BRA.S    SCR_EXIT               ;branch if bad device name
                   BRA.S    SCRNMOK                ;branch if name ok

   Data for screen device name.

0D1C SCRDATA       DC.W     3,"SCR"                ;name length and device name
                   DC.W     4                      ;number of parameters following name
                   DC.W     " _",448               ;window width
                   DC.W     " X",180               ;window height
                   DC.W     " A",32                ;window x co-ord of LHS
                   DC.W     " X",16                ;window y co-ord of top

Ú----------------------------------------------------------------------¿
³=SCRNMOK         OPEN A SCREEN CHANNEL                                        ³
Ã----------------------------------------------------------------------´
³ENTRY            A6.L     system variables                                    ³
³                 A7.L     parameter block                                     ³
³                                                                              ³
³EXIT:            A0.L     channel definition block                            ³
³                 A2.L     O/P queue header                                    ³
³                                                                              ³
³ERRORS:          ERR.BP   bad parameter                                       ³
À----------------------------------------------------------------------Ù

0D34 SCRNMOK       MOVEQ    #$68,D1                ;channel definition block length
                   BSR.S    SCROPEN                ;open the channel
                   BRA.S    SCR_EXIT               ;and exit

0D3A SCR_OK        MOVEQ    #0,D0                  ;signal "no errors"
0D3C SCR_EXIT      ADDA.W   #$0A,A7                ;ignore parameter block
                   RTS

Ú----------------------------------------------------------------------¿
³=SCROPEN         OPEN A SCREEN OR CONSOLE CHANNEL                             ³
Ã----------------------------------------------------------------------´
³ENTRY            D1.L     block length                                        ³
³                 A6.L     system variables                                    ³
³                 A7.L     parameter block                                     ³
³                                                                              ³
³EXIT:            A0.L     channel definition block                            ³
³                 A2.L     O/P queue header                                    ³
³                                                                              ³
³ERRORS:          ERR.OM   out of memory                                       ³
À----------------------------------------------------------------------Ù

0D42 SCROPEN       JSR      MM_ALCHP(PC)           ;find the space, A0 points at the start of the area on exit
                   BNE.S    SCR_END                ;and exit if out of memory
                   MOVE.W   D1,-(A7)               ;save the channel length
                   LEA      SD.XINC(A0),A2         ;A2 points at SD_XINC
                   MOVE.L   #$6000A,(A2)+          ;set up the cursor size
                   MOVE.L   #FONT_1,(A2)+          ;the addresses of the two fonts
                   MOVE.L   #FONT_2,(A2)+
                   MOVE.L   #SCREEN,(A2)+          ;and the address of the start of screen memory
                   LEA      SD.IMASK(A0),A1        ;A1 points at SD_IMASK
                   MOVEQ    #4,D1                  ;set to green ink and black paper
                   JSR      COLRMASK(PC)           ;form the colour masks

                   MOVE.L   #$08076400,SD.SCAL(A0)

                   BTST     #3,SV.MCSTA(A6)        ;4 or 8 colour mode ?
                   BEQ.S    SCR_M4                 ;jump forward if mode 4
                   ADDQ.W   #6,SD.XINC(A0)         ;double cursor width if mode 8
                   BSET     #6,SD.CATTR(A0)        ;signal "double width" and "no border"
0D8A SCR_M4        MOVEQ    #0,D2
                   LEA      6(A7),A1               ;A1 points at window parameters
                   JSR      SD_WDEF(PC)            ;redefine window
                   MOVE.W   (A7)+,D1               ;restore definition block length
                   TST.L    D0                     ;any errors ?
                   BEQ.S    SCR_END                ;exit if none
                   MOVE.L   D0,-(A7)               ;save error value
                   JSR      MM_RECHP(PC)           ;release space if window to big
                   MOVE.L   (A7)+,D0               ;restore error value
0DA2 SCR_END       RTS

Ú----------------------------------------------------------------------¿
³=CONCLOSE        CLOSE A CON OR SCR CHANNEL (TRAP #2 WITH D0 = $02)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           A0.L     channel ID                                          ³
³                                                                              ³
³EXIT:            A0       corrupted                                           ³
³                 D1,D2,D3,A1,A2 and A3 preserved                              ³
³                                                                              ³
³ERRORS:          ERR.NC   channel not open                                    ³
À----------------------------------------------------------------------Ù

   TRAP handler alters registers so that A0 now points at channel definition block
   and A6 at system variables.

0DA4 CONCLOSE      LEA      SD.KBD(A0),A3          ;A3 points at keyboard queue header
                   TST.L    (A3)                   ;screen channel ?
                   BEQ.S    CONRECLM               ;reclaim space if so
                   CMPA.L   SV.KEYQ(A6),A3         ;is this the current queue ?
                   BNE.S    NEXT_Q1                ;next queue if not
                   MOVE.L   (A3),SV.KEYQ(A6)       ;set pointer to next queue
0DB6 NEXT_Q1       CMPA.L   (A3),A3                ;end of queue list ?
                   BNE.S    FIND_Q1                ;next queue if not
                   CLR.L    SV.KEYQ(A6)            ;otherwise signal "no queue"
                   BRA.S    CONRECLM               ;and reclaim channel

   Search through the keyboard queue linked list for the queue before this
   one and use this to unlink O/P queue from the list.

0DC0 FIND_Q1       MOVEA.L  A3,A2                  ;A2 points at O/P queue header
0DC2 NEXT_Q2       MOVEA.L  (A2),A2                ;get address of next queue header
                   CMPA.L   (A2),A3                ;correct queue ?
                   BNE.S    NEXT_Q2                ;find next queue if not
                   MOVE.L   (A3),(A2)              ;otherwise delete from queue list
0DCA CONRECLM      JSR      MM_RECHP(PC)           ;and reclaim channel definition block
                   RTS

Ú----------------------------------------------------------------------¿
³=CON_IO          GENERAL CONSOLE OR SCREEN CHANNEL I/O                        ³
Ã----------------------------------------------------------------------´
³ENTRY            D0.B     action required                                     ³
³                 D1.L     0 if string of bytes required                       ³
³                 D3.L     timeout                                             ³
³                 A0.L     channel definition block                            ³
³                 A1.L     buffer location                                     ³
³                 A6.L     system variables                                    ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:          ERR.NC   not complete                                        ³
À----------------------------------------------------------------------Ù

0DD0 CON_IO        TST.B    SV.SCRST(A6)           ;screen active ?
                   BEQ.S    SCRACTIV               ;jump forward if it is
                   MOVEQ    #ERR.NC,D0             ;signal "not complete"
                   RTS

0DDA SCRACTIV      CMPI.B   #IO.SSTRG,D0           ;is it a simple I/O action ?
                   BHI.S    W_CMND                 ;may be window command if not
                   MOVEQ    #-1,D7                 ;signal ""
                   MOVEQ    #0,D6
                   MOVE.W   D2,D5                  ;copy buffer size,cursor position and
                   MOVE.L   D1,D4                  ;buffer location to working registers
                   MOVEA.L  A1,A4
                   LEA      SD.KBD(A0),A5          ;A5 points at sd_kbd
                   TST.L    D3                     ;timeout zero ?
                   BLT.S    SC_OPOK                ;call routine if not
                   CMPI.B   #SC.EDLIN,D0           ;send operation ?
                   BHI.S    SC_OPOK                ;jump forward if so
                   TST.L    (A5)                   ;screen channel ?
                   BEQ.S    SC_ERRBP               ;exit if so
                   MOVEA.L  SV.KEYQ(A6),A2         ;A2 points at current keyboard queue
                   TST.B    -$21(A2)               ;empty ?
                   BNE.S    SC_OPOK                ;jump forward if not
                   MOVE.L   A5,SV.KEYQ(A6)         ;make this queue current one
0E0A SC_OPOK       MOVE.B   SC_TBL(PC,D0.W),D0
                   JMP      SC_TBL(PC,D0.W)        ;do action

   Table of offsets for general console I/O.

0E12 SC_TBL        DC.B     SC_PEND  - SC_TBL      ;test pending I/P
                   DC.B     SC_FBYTE - SC_TBL      ;fetch a byte
                   DC.B     SC_FLINE - SC_TBL      ;fetch a line
                   DC.B     SC_FSTRG - SC_TBL      ;fetch a string of bytes
                   DC.B     SC_EDLIN - SC_TBL      ;edit a line
                   DC.B     SC_SBYTE - SC_TBL      ;send a byte
                   DC.B     SC_ERRBP - SC_TBL      ;not implemented
                   DC.B     SC_SSTRG - SC_TBL      ;send a string of bytes

Ú----------------------------------------------------------------------¿
³=SC_PEND         TEST PENDING I/P           (TRAP #3 WITH D0 = $00)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D3.W     timeout                                             ³
³                 A0.L     channel ID                                          ³
³                                                                              ³
³EXIT:            D1 and A1  corrupted                                         ³
³                 D2,D3,A0,A2 and A3 preserved                                 ³
³                                                                              ³
³ERRORS:          ERR.NC   number pending I/P                                  ³
³                 ERR.NO   invalid channel ID                                  ³
³                 ERR.EF   end of file                                         ³
À----------------------------------------------------------------------Ù

0E1A SC_PEND       JMP      IO_QTEST(PC)           ;jump to general routine

Ú----------------------------------------------------------------------¿
³=SC_FBYTE        FETCH A BYTE               (TRAP #3 WITH D0 = $01)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D3.W     timeout                                             ³
³                 A0.L     channel ID                                          ³
³                                                                              ³
³EXIT:            D1.B     byte read                                           ³
³                 A1       corrupted                                           ³
³                 D2,D3,A0,A2 and A3 preserved                                 ³
³                                                                              ³
³ERRORS:          ERR.NC   not complete as number pending I/P                  ³
³                 ERR.NO   invalid channel ID                                  ³
³                 ERR.EF   end of file                                         ³
À----------------------------------------------------------------------Ù

0E1E SC_FBYTE      MOVEA.L  A5,A2                  ;copy pointer to queue
                   JMP      IO_QOUT(PC)            ;and get the byte

Ú----------------------------------------------------------------------¿
³=SC_FSTRG        FETCH A STRING OF BYTES    (TRAP #3 WITH D0 = $03)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D2.W     buffer size in bytes                                ³
³                 D3.W     timeout                                             ³
³                 A0.L     channel ID                                          ³
³                 A1.L     location of start of buffer                         ³
³                                                                              ³
³EXIT:            D1.W     number of bytes read                                ³
³                 A1       corrupted                                           ³
³                 D2,D3,A0,A2 and A3 preserved                                 ³
³                                                                              ³
³ERRORS:          ERR.NC   not complete                                        ³
³                 ERR.NO   invalid channel ID                                  ³
³                 ERR.EF   end of file                                         ³
À----------------------------------------------------------------------Ù

   A5 points at keyboard queue,D4 = byte count,D5 = buffer size,A4 = start.

0E24 SC_FSTRG      MOVEQ    #0,D0                  ;signal "no errors"
0E26 SC_GET        CMP.W    D4,D5                  ;end of buffer ?
                   BLS.S    BUF_END                ;exit if so
                   MOVEA.L  A5,A2                  ;copy pointer to queue
                   JSR      IO_QOUT(PC)            ;get a byte from the queue in D1
                   BLT.S    BUF_END                ;and exit if empty or end of queue
                   MOVE.B   D1,(A4)+               ;insert in channel buffer
                   ADDQ.W   #1,D4                  ;increment buffer position
                   BRA.S    SC_GET                 ;and try again

Ú----------------------------------------------------------------------¿
³=SC_SSTRG        SEND A STRING OF BYTES     (TRAP #3 WITH D0 = $07)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D2.W     number of bytes to send                             ³
³                 D3.W     timeout                                             ³
³                 A0.L     channel ID                                          ³
³                 A1.L     location of first byte to be sent                   ³
³                                                                              ³
³EXIT:            D1.W     number of bytes sent within timout                  ³
³                 A1       1 past last byte sent                               ³
³                 D2,D3,A0,A2 and A3 preserved                                 ³
³                                                                              ³
³ERRORS:          ERR.NC   not complete                                        ³
³                 ERR.NO   invalid channel ID                                  ³
³                 ERR.DF   drive or device full                                ³
À----------------------------------------------------------------------Ù

   A5 points at keyboard queue,D4 = byte count,D5 = buffer size,A4 = start.

0E38 SC_SSTRG      MOVEQ    #0,D0                  ;signal "no errors"
                   CMP.W    D4,D5                  ;end of buffer?
                   BLS.S    BUF_END                ;exit if so
                   MOVE.B   (A4)+,D1               ;get character from buffer
                   BSR.S    SC_SBYTE               ;and insert in queue
                   ADDQ.W   #1,D4                  ;increment buffer position
                   BRA.S    SC_SSTRG               ;and try again

0E46 SC_ERRBP      MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
0E48 BUF_END       MOVE.W   D4,D1                  ;buffer position and buffer pointer
                   MOVEA.L  A4,A1
                   BCLR     #7,SD.CATTR(A0)        ;signal "not graphics positioned"
                   RTS

0E54 L00E54        MOVEQ    #SC.SBYTE,D0           ;call special routine
0E56 W_CMND        JMP      WIN_CMND(PC)           ;to print character

Ú----------------------------------------------------------------------¿
³=SC_SBYTE        SEND A BYTE                (TRAP #3 WITH D0 = $05)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.B     byte to be sent                                     ³
³                 D3.W     timeout                                             ³
³                                                                              ³
³EXIT:            D1 and A1  corrupted                                         ³
³                 D2,D3,A0,A2 and A3 preserved                                 ³
³                                                                              ³
³ERRORS:          ERR.NC   not complete                                        ³
³                 ERR.NO   invalid channel ID                                  ³
À----------------------------------------------------------------------Ù

0E5A SC_SBYTE      MOVEQ    #0,D0                  ;signal "no errors"
                   CMPI.B   #$0A,D1                ;line feed ?
                   BEQ.S    CHK_LF                 ;update newline status if so
                   TST.B    SD.NLSTA(A0)           ;pending newline ?
                   BEQ.S    NO_NEWL                ;jump forward if none pending
                   MOVE.B   D1,-(A7)               ;save character
                   BSR.S    SC_ECHO                ;do the newline
                   MOVE.B   (A7)+,D1               ;restore character
0E6E NO_NEWL       BSR.S    L00E54                 ;send the character
                   BEQ.S    L00E9E                 ;and exit if any errors
                   MOVE.W   SD.XINC(A0),D0         ;update cursor position
                   ADD.W    D0,SD.XPOS(A0)
                   BTST     #7,SD.CATTR(A0)        ;graphics positioned ?
                   BNE.S    L00E9C                 ;exit if not
                   MOVE.B   D0,SD.NLSTA(A0)        ;signal "no pending newline"
                   TST.B    SD.CURF(A0)            ;cursor on or off ?
                   BEQ.S    L00E9C                 ;exit if off
                   BSR.S    SC_ECHO                ;otherwise echo it
                   BRA.S    L00E9C

0E90 CHK_LF        TST.B    SD.NLSTA(A0)
                   BGE.S    L00E98
                   BSR.S    SC_ECHO
0E98 L00E98        ST       SD.NLSTA(A0)           ;signal "pending" and "no errors"
0E9C L00E9C        MOVEQ    #0,D0
0E9E L00E9E        RTS

0EA0 SC_ECHO       TST.B    SD.CURF(A0)            ;cursor on or off ?
                   BLE.S    L00EAA
                   JSR      PRNT_CUR(PC)
0EAA L00EAA        JMP      SD_NEWL(PC)            ;do forced newline

Ú----------------------------------------------------------------------¿
³=SC_FLINE        FETCH A LINE               (TRAP #3 WITH D0 = $02)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D0.W     cursor position (zero if via CHKTRP3)               ³
³                 D2.W     buffer size in bytes                                ³
³                 D3.W     timeout                                             ³
³                 A0.L     channel ID                                          ³
³                 A1.L     location of buffer                                  ³
³                                                                              ³
³EXIT:            D1.W     number of bytes returned                            ³
³                 A1       1 past last character                               ³
³                 D2,D3,A0,A2 and A3 preserved                                 ³
³                                                                              ³
³ERRORS:          ERR.NC   not complete                                        ³
³                 ERR.BO   too many characters read                            ³
³                 ERR.NO   invalid channel ID                                  ³
³                 ERR.EF   end of file                                         ³
À----------------------------------------------------------------------Ù

   To terminate the line press "ENTER" only.

0EAE SC_FLINE      TST.L    D3                     ;check timeout
                   BEQ.S    L00EC6
                   BRA.S    L00EB8

Ú----------------------------------------------------------------------¿
³=SC_EDLIN        EDIT A LINE                (TRAP #3 WITH D0 = $04)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1       high word = cursor position                         ³
³                          low word = current line length                      ³
³                 D2.W     size of buffer in bytes                             ³
³                 D3.W     timeout                                             ³
³                 A0.L     channel ID                                          ³
³                 A1.L     location of character at cursor position            ³
³                                                                              ³
³EXIT:            D1.W     line length including terminator                    ³
³                 A1       1 past last character in line                       ³
³                 D2,D3,A0,A2 and A3 preserved                                 ³
³                                                                              ³
³ERRORS:          ERR.NC   not complete                                        ³
³                 ERR.BO   too many characters read                            ³
³                 ERR.NO   invalid channel ID                                  ³
À----------------------------------------------------------------------Ù

   A0 altered in TRAP handler to point to character itself. "ENTER", cursor
   up and cursor down all terminate the line.

0EB4 SC_EDLIN      MOVEQ    #-1,D4                 ;D4 = - current line length
                   MOVE.W   D1,D4
0EB8 L00EB8        SWAP     D1                     ;move cursor position into view
                   MOVE.W   D1,D6
                   SUBA.W   D4,A4                  ;A4 points at start of line then current
                   ADDA.W   D6,A4                  ;character in line
                   BNE.S    L00EDE                 ;and exit if cursor at start
                   TST.L    D3                     ;check timeout
                   BLT.S    L00EDE                 ;and jump forward if infinite
0EC6 L00EC6        TST.B    SD.CURF(A0)            ;cursor on or off ?
                   BLE.S    L00ED0                 ;jump forward if on
                   JSR      PRNT_CUR(PC)           ;switch it on otherwise
0ED0 L00ED0        JSR      SD_DONL(PC)            ;do any pending newline
                   BSR      L01036
                   MOVE.W   D4,D6
                   SUB.W    D3,D6
                   SUBA.W   D3,A4
0EDE L00EDE        MOVE.B   SD.CURF(A0),-(A7)
0EE2 L00EE2        MOVEA.L  A5,A2
                   JSR      IO_QOUT(PC)            ;get a character
                   BLT      L00F72
                   TST.B    SD.CURF(A0)            ;cursor off ?
                   BLE.S    L00EFA                 ;jump forward if not
                   MOVE.B   D1,-(A7)               ;save character
                   JSR      PRNT_CUR(PC)
                   MOVE.B   (A7)+,D1               ;restore character
0EFA L00EFA        CMPI.B   #$0A,D1                ;enter ?
                   BEQ.S    L00F5C
                   CMPI.B   #$1F,D1                ;control code ?
                   BLS.S    L00EE2                 ;next character if so
                   CMPI.B   #$BF,D1                ;printable ?
                   BHI.S    FILTER
                   MOVE.W   D4,D0                  ;copy pointer to last character
                   SUB.W    D6,D0                  ;make it relative
                   BRA.S    INSERT                 ;move buffer up one space

0F12 BUF_UP        MOVE.B   0(A4,D0.W),1(A4,D0.W)  ;move byte up one space
0F18 INSERT        DBF      D0,BUF_UP              ;rest of buffer
                   ADDQ.W   #1,D6                  ;increment pointers
                   ADDQ.W   #1,D4
                   MOVE.B   D1,(A4)+               ;insert new character
                   MOVEQ    #-1,D7
                   BSR      L01006
                   BSR      L01028
                   CMP.W    D4,D5                  ;end of buffer reached ?
                   BHI.S    L00EE2                 ;next character if not
                   MOVEQ    #ERR.BO,D0             ;otherwise signal "buffer overflow"
                   BRA.S    L00F7C

0F34 FILTER        TST.L    D4                     ;buffer empty ?
                   BGE.S    L00F44                 ;jump forward if so
                   CMPI.B   #$D0,D1                ;cursor up ?
                   BEQ.S    L00F5C
                   CMPI.B   #$D8,D1                ;cursor down ?
                   BEQ.S    L00F5C
0F44 L00F44        SUBI.B   #$C0,D1
                   BEQ.S    L00F8A                 ;if cursor left
                   SUBQ.B   #2,D1
                   BEQ      L00FD6                 ;if ctrl left
                   SUBQ.B   #6,D1
                   BEQ.S    L00F92                 ;if cursor right
                   SUBQ.B   #2,D1
                   BEQ      L00FDA                 ;if ctrl right
0F5A L00F5A        BRA.S    L00EE2

0F5C L00F5C        MOVE.B   D1,-(A7)
                   MOVEQ    #-1,D7
                   BSR      L0103A
                   MOVE.B   (A7)+,(A4)+
                   ADDQ.W   #1,D4
                   JSR      SD_CURS(PC)            ;disable cursor
                   BSR      CHK_LF
                   BRA.S    L00F84

0F72 L00F72        TST.B    (A7)
                   BLT.S    L00F7C
                   JSR      SD_CURE(PC)            ;enable cursor
                   MOVEQ    #ERR.NC,D0             ;signal "not complete"
0F7C L00F7C        SUBA.W   D6,A4
                   ADDA.W   D4,A4
                   MOVE.W   D6,D1
                   SWAP     D1
0F84 L00F84        ADDQ.W   #2,A7
                   BRA      BUF_END

0F8A L00F8A        BSR.S    L00FAE
                   BEQ.S    L00F5A
0F8E L00F8E        ADDQ.W   #1,D6
                   BRA.S    L00F5A

0F92 L00F92        ADDQ.W   #1,D6
                   CMP.W    D4,D6
                   BHI.S    L00FAA
                   ADDQ.W   #1,A4
                   JSR      SD_NCOL(PC)            ;set to next column
                   BEQ.S    L00F5A
                   JSR      SD_NEWL(PC)            ;do forced newline
                   BSR      L01028
                   BRA.S    L00F5A

0FAA L00FAA        SUBQ.W   #1,D6
0FAC L00FAC        BRA.S    L00F5A

0FAE L00FAE        SUBQ.W   #1,D6
                   BLT.S    L00FD4
                   JSR      SD_PCOL(PC)            ;set to previous column
                   BEQ.S    L00FD2
                   JSR      SD_PROW(PC)            ;set to previous row
                   BNE.S    L01034

   Update cursor position.

                   MOVE.W   SD.XSIZE(A0),D0        ;D0 = window width in pixels
                   DIVU     SD.XINC(A0),D0         ;D0 = window width in characters
                   SUBQ.W   #1,D0                  ;D0 = width - 1
                   MULU     SD.XINC(A0),D0         ;D0 = window width - cursor size
                   MOVE.W   D0,SD.XPOS(A0)         ;update cursor position
                   MOVEQ    #0,D0                  ;signal "no errors"
0FD2 L00FD2        SUBQ.W   #1,A4
0FD4 L00FD4        BRA.S    L01034

0FD6 L00FD6        BSR.S    L00FAE
                   BNE.S    L00F8E
0FDA L00FDA        CMP.W    D6,D4
                   BEQ.S    L00FAC
                   SUBQ.W   #1,D4
                   MOVE.W   D4,D0
                   SUB.W    D6,D0
                   MOVE.W   D0,D1
                   BRA.S    DELETE

0FE8 BUF_DOWN      MOVE.B   1(A4),(A4)+            ;move chaacter one space down
0FEC DELETE        DBF      D0,BUF_DOWN            ;then rest of buffer
                   SUBA.W   D1,A4
                   MOVE.L   SD.XPOS(A0),-(A7)
                   MOVEQ    #0,D7
                   BSR.S    L0103A
                   BNE.S    L01000
                   MOVEQ    #$20,D1
                   BSR.S    L01006
1000 L01000        MOVE.L   (A7)+,D7
                   BSR.S    L0102A
                   BRA.S    L00FAC

1006 L01006        BSR      L00E54
                   BEQ.S    L01034
                   JSR      SD_NL(PC)              ;do newline
                   BEQ.S    L01034
                   TST.W    D7
                   BLT.S    L01022
                   SUB.W    SD.YINC(A0),D7
                   BGE.S    L01022
                   ADD.W    SD.YINC(A0),D7
                   BRA.S    L0105A

1022 L01022        JSR      SD_NEWL(PC)            ;do forced newline
                   BRA.S    L01032

1028 L01028        BSR.S    L01036
102A L0102A        SUBA.W   D4,A4
                   ADDA.W   D6,A4
                   MOVE.L   D7,SD.XPOS(A0)
1032 L01032        MOVEQ    #0,D0                  ;signal "no errors"
1034 L01034        RTS

1036 L01036        MOVE.L   SD.XPOS(A0),D7         ;copy cursor position
103A L0103A        MOVEQ    #0,D0                  ;signal "no errors"
                   MOVE.W   D4,D3
                   SUB.W    D6,D3
                   BRA.S    L0104E

1042 L01042        MOVE.B   (A4)+,D1               ;get character from buffer
                   MOVE.W   D3,-(A7)
                   BSR.S    L01006
                   MOVE.W   (A7)+,D3
                   TST.L    D0
                   BNE.S    L01056
104E L0104E        DBF      D3,L01042
                   MOVEQ    #0,D3
                   RTS

1056 L01056        ADDA.W   D3,A4
                   ADDQ.W   #1,D3
105A L0105A        TST.L    D0
                   RTS

2.5.4 Network device driver.

   This the end of the simple device drivers linked list and handles the network
   device driver.

   Up to 64 QL's and spectrums can be connected together on the network. The
   protocol used is a non standard one designed by Sincliar Research and as a
   result only these machines will support it. Each device is given a station
   number to distinguish it from the others. Communication in one direction only
   at any given time is allowed and the routines NT_SPCKT and NT_RPCKT at the
   end of the ROM are used for this purpose.

105E NET_LB        DC.L     0                      ;link to next block (null)
                   DC.L     NET_IO                 ;I/O routine
                   DC.L     NETOPEN                ;open routine
                   DC.L     NETOPEN                ;close routine

Ú----------------------------------------------------------------------¿
³=NETOPEN         OPEN A NETWORK CHANNEL     (TRAP #2 WITH D0 = $01)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     job ID (-1 if current)                              ³
³                 A0.L     address of channel name                             ³
³                                                                              ³
³EXIT:            D1.L     job ID                                              ³
³                 A0.L     new channel ID                                      ³
³                 D2,D3,A1,A2 and A3 preserved                                 ³
³                                                                              ³
³ERRORS:          ERR.NJ   invalid job ID                                      ³
³                 ERR.OM   out of memory                                       ³
³                 ERR.NO   too many channels                                   ³
³                 ERR.NF   device not found                                    ³
³                 ERR.IU   device in use                                       ³
³                 ERR.BN   network parameters wrong                            ³
À----------------------------------------------------------------------Ù

   TRAP handler alters registers so that A6 now points at system variables
   and A7 points at parameter block.

106E NETOPEN       SUBQ.W   #4,A7                  ;create space for parameter block
                   MOVEA.L  A7,A3                  ;copy stack pointer to A3
                   JSR      IO_NAME(PC)            ;decode device name

   Return points for the three decode device name errors.

                   BRA.S    NET_EXIT               ;branch if name not found
                   BRA.S    NET_EXIT               ;branch if bad device name
                   BRA.S    NETNMOK                ;branch if name ok

   Data for network device name.

107C NETDATA       DC.W     3,"NET"                ;name length and device name
                   DC.W     2                      ;number of parameters following name
                   DC.W     2,"IO"                 ;direction (I/P or O/P)
                   DC.W     " _",0                 ;station number (0 = broadcast)

108C NETNMOK       MOVE.W   #$120,D1               ;length of channel definition block
                   JSR      MM_ALCHP(PC)           ;find the space,A0 points at area on exi
                   BNE.S    NET_EXIT               ;exit if out of memory

   Set up the network parameters from the system variables and parameters.

                   MOVE.B   3(A7),NET.HEDR(A0)
                   MOVE.B   SV.NETNR(A6),NET.SELF(A0)
                   MOVE.B   1(A7),NET.TYPE(A0)
                   SUBQ.B   #2,NET.TYPE(A0)
                   MOVEQ    #0,D0                  ;signal "no errors"
10AE NET_EXIT      ADDQ.W   #4,A7                  ;ignore parameter block
                   RTS

Ú----------------------------------------------------------------------¿
³=NETCLOSE        CLOSE A NETWORK CHANNEL    (TRAP #2 WITH D0 = $02)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           A0.L     channel ID                                          ³
³                                                                              ³
³EXIT:            A0       corrupted                                           ³
³                 D1,D2,D3,A1,A2 and A3 preserved                              ³
³                                                                              ³
³ERRORS:          ERR.NC   channel not open                                    ³
À----------------------------------------------------------------------Ù

   TRAP handler alters registers so that A0 now points at channel definition block
   and A6 at the QDOS system variables.

10B2 NETCLOSE      TST.B    NET.TYPE(A0)           ;I/P or O/P channel ?
                   BGE.S    NT_RECLM               ;reclaim channel if I/P channel
                   MOVE.B   #1,NET.TYPE(A0)        ;otherwise signal "eof packet"
                   MOVE.B   NET.RPNT(A0),NET.NBYT(A0)
10C4 L010C4        TST.B    SV.MDRUN(A6)           ;microdrive turning ?
                   BNE.S    L010C4                 ;wait until it stops if so
                   MOVE.W   #1400,D4               ;number of try's for sending EOF packet
10CE L010CE        JSR      NT_SPCKT               ;send the packet
                   DBEQ     D4,L010CE              ;try again if unsuccessful
10D8 NT_RECLM      JMP      MM_RECHP(PC)           ;reclaim the channel

10DC NT_ERRBP      MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
                   RTS

Ú----------------------------------------------------------------------¿
³=NET_IO          GENERAL NETWORK I/O                                          ³
Ã----------------------------------------------------------------------´

10E0 NET_IO        JSR      IO_SERIO               ;general I/O handling
                   DC.L     NT_PEND                ;test for pending I/P
                   DC.L     NT_FBYTE               ;fetch a byte
                   DC.L     NT_SBYTE               ;send a byte
                   RTS

Ú----------------------------------------------------------------------¿
³=NT_PEND         TEST FOR PENDING I/P       (TRAP #3 WITH D0 = $00)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D3.W     timeout                                             ³
³                 A0.L     channel ID                                          ³
³                                                                              ³
³EXIT:            D1 and A1  corrupted                                         ³
³                 D2,D3,A0,A2 and A3 preserved                                 ³
³                                                                              ³
³ERRORS:          ERR.NC   number pending I/P                                  ³
³                 ERR.NO   invalid channel ID                                  ³
³                 ERR.EF   end of file                                         ³
À----------------------------------------------------------------------Ù

10F2 NT_PEND       MOVE.B   NET.TYPE(A0),D0        ;I/P or O/P channel ?
                   BLT.S    NT_ERRBP               ;exit if I/P channel
                   MOVEQ    #0,D2                  ;prepare D2
                   MOVE.B   NET.RPNT(A0),D2        ;get current buffer position
                   MOVE.B   NET.DATA(A0,D2.W),D1
                   SUB.B    NET.NBYT(A0),D2        ;form length of buffer
                   BCS.S    L01126                 ;get another character if room left

   The buffer is empty so get a packet if an I/P channel.

                   TST.B    D0                     ;I/P or O/P channel
                   BEQ.S    L01110                 ;get a packet if an I/P channel
                   MOVEQ    #ERR.EF,D0             ;otherwise signal "end of file"
                   RTS

1110 L01110        SF       NET.RPNT(A0)           ;signal "buffer empty"
                   JSR      NT_RPCKT               ;get a network packet and report success
                   BEQ.S    NT_PEND
                   RTS

Ú----------------------------------------------------------------------¿
³=NT_FBYTE        FETCH A BYTE               (TRAP #3 WITH D0 = $01)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D3.W     timeout                                             ³
³                 A0.L     channel ID                                          ³
³                                                                              ³
³EXIT:            D1.B     byte read                                           ³
³                 A1       corrupted                                           ³
³                 D2,D3,A0,A2 and A3 preserved                                 ³
³                                                                              ³
³ERRORS:          ERR.NC   not complete                                        ³
³                 ERR.NO   invalid channel ID                                  ³
³                 ERR.EF   end of file                                         ³
À----------------------------------------------------------------------Ù

111E NT_FBYTE      BSR.S    NT_PEND                ;test for pending I/P
                   BNE.S    L01128                 ;exit if any errors
                   ADDQ.B   #1,NET.RPNT(A0)        ;update buffer position
1126 L01126        MOVEQ    #0,D0                  ;signal "no errors"
1128 L01128        RTS

Ú----------------------------------------------------------------------¿
³=NT_SBYTE        SEND A BYTE                (TRAP #3 WITH D0 = $05)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.B     byte to be sent                                     ³
³                 D3.W     timeout                                             ³
³                 A0.L     channel ID                                          ³
³                                                                              ³
³EXIT:            D1 and A1  corrupted                                         ³
³                 D2,D3,A0,A2 and A3 preserved                                 ³
³                                                                              ³
³ERRORS:          ERR.NC   not complete                                        ³
³                 ERR.NO   invalid channel ID                                  ³
³                 ERR.EF   end of file                                         ³
À----------------------------------------------------------------------Ù

112A NT_SBYTE      TST.B    NET.TYPE(A0)           ;I/P or O/P channel ?
                   BGE.S    NT_ERRBP               ;exit if I/P channel
                   MOVEQ    #1,D2
                   ADD.B    NET.RPNT(A0),D2        ;update buffer position and jump forward
                   BCC.S    L01152                 ;if greater than 256 characters
                   MOVE.B   D1,-(A7)               ;save the character if buffer full
                   MOVE.W   #$FF,NET.TYPE(A0)      ;signal "data packet"
                   JSR      NT_SPCKT               ;transmit the packet
                   MOVE.B   (A7)+,D1               ;get character back
                   ST       NET.TYPE(A0)           ;signal "data packet"
                   TST.L    D0                     ;any errors ?
                   BNE.S    L01128                 ;exit if so
                   MOVEQ    #1,D2                  ;otherwise update buffer position

   Insert the character in the now empty buffer or if room left.

1152 L01152        MOVE.B   D1,NET.HCHK(A0,D2.W)
                   MOVE.B   D2,NET.RPNT(A0)        ;form checksum
                   BRA.S    L01126


;part 5

Ú----------------------------------------------------------------------¿
³=FLASHCUR        FLASH THE CURSOR (START OF SCHEDULER LINKED LIST)            ³
Ã----------------------------------------------------------------------´
³ENTRY:           D3.L                                                         ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:          NONE                                                         ³
À----------------------------------------------------------------------Ù

115C SCHDTASK      DC.L     SECTASK                ;link to next entry
                   DC.L     FLASHCUR               ;pointer to routine

1164 FLASHCUR      MOVE.L   SV.KEYQ(A6),D4         ;D4 points at current keyboard queue
                   BEQ.S    EXIT_FLA               ;exit if number queue
                   MOVEA.L  D4,A0
                   LEA      -$64(A0),A0            ;A0 points at start of channel definition block
                   MOVE.W   SV.FSTAT(A6),D4        ;get cursor flash counter
                   TST.B    SD.CURF(A0)            ;cursor suppressed ?
                   BEQ.S    L01182                 ;exit if so
                   SUB.W    D3,D4                  ;update counter
                   BGT.S    L01184                 ;and jump forward unless timed out
                   JSR      PRINT_CUR(PC)          ;flash the cursor
1182 L01182        MOVEQ    #12,D4                 ;reset count again
1184 L01184        MOVE.W   D4,SV.FSTAT(A6)        ;update count
1188 EXIT_FLA      RTS

2.6 Directory device drivers.

2.6.1 Microdrive device driver.

   This is the start of the directory device drivers linked list and handles
   the only directory device driver in an un-expanded QL, the microdrive. The
   microdrive is the only directory based device in the QL and so only one
   driver exists in the directory device drivers linked list.

   The microdrive device driver is the most complex of all the drivers in QDOS
   and occupies quite a large part of the ROM spread about in between the other
   parts of the IOSS (I/O Sub System).

   Sections of memory known as slave blocks are used to store copies of sectors
   of tape and in particular, the directory sectors are stored in RAM to allow
   for fast searches for files on a cartridge to be carried out.

   Up to eight drives can be used at a time and data for each drive is kept in
   a special area known as a physical definition block which is stored in the
   common heap for each drive.

118A MDV_LB        DC.L     0                      ;absolute link to next block (null)
                   DC.L     MDV_IO                 ;I/O routine address
                   DC.L     MD_OPEN                ;open routine address
                   DC.L     MD_CLOSE               ;close routine address
                   DC.L     MD_SLAVE               ;forced slaving routine address
                   DC.L     0                      ;rename routine address (none)
                   DC.L     0                      ;truncate routine address (none)
                   DC.L     MD_FORMT               ;format routine address
                   DC.L     $428                   ;length of physical definition block
                   DC.W     3,"MDV"                ;drive name

Ú----------------------------------------------------------------------¿
³=REPEATIO        DO MICRODRIVE I/O OPERATION UNTIL COMPLETE                   ³
Ã----------------------------------------------------------------------´
³ENTRY:           D0.L     action required                                     ³
³                 D2.L     ?                                                   ³
³                 D3.L     timeout                                             ³
³                                                                              ³
³EXIT:            none                                                         ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

11B4 REPEATIO      MOVEM.L  D0/D2/D4-7/A4-5,-(A7)  ;save registers used by device driver
11B8 NEXT_IO       MOVEM.L  (A7),D0/D2             ;and restore action registers
                   MOVEQ    #0,D3                  ;do the I/O operation for one frame
                   BSR.S    MDV_IO
                   ADDQ.L   #1,D0                  ;was error "not complete" ?
                   BEQ.S    NEXT_IO                ;try I/O again if so otherwise
                   SUBQ.L   #1,D0                  ;restore error code if not
                   ADDQ.W   #4,A7                  ;and ignore saved error long word
                   MOVEM.L  (A7)+,D2/D4-7/A4-5     ;restore registers used by device driver
                   RTS

Ú----------------------------------------------------------------------¿
³=MDV_IO          GENERAL MICRODRIVE FILE I/O                                  ³
Ã----------------------------------------------------------------------´
³ENTRY:           D0.L     action required                                     ³
³                 D2.L     ?                                                   ³
³                 D3.L     timeout                                             ³
³                                                                              ³
³EXIT:            none                                                         ³
³                                                                              ³
³ERRORS:          ERR.BP   invalid function                                    ³
À----------------------------------------------------------------------Ù

   TRAP handler alters registers so that A6 now points at system variables, A0
   points at channel definition block and A3 points at assumed start of linkage
   block.

11CE MDV_IO        MOVEQ    #0,D6                  ;prepare D6
                   MOVE.B   FS.DRIVE(A0),D6        ;get drive number
                   LSL.B    #2,D6                  ;form drive ID from drive number

   Drive numbers are stored in QDOS as an integer from 1 to the maximum number
   of microdrives allowed which is 8. A drive number therefore takes the form
   shown below assuming that the "d"'s stand for the drive number:-

                bit
          7 6 5 4 3 2 1 0
         ÚÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄ¿
         ³0³0³0³0³d³d³d³d³
         ÀÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÙ

   Throughout the rest of the system however, there are various tables of long
   word pointers which are indexed by the drive number. Because the mechanism
   of indexing the table requires that the drive number is multiplied by four,
   the drive number is also stored in a table in the system variables, in the
   multiplied form known as a drive ID. The drive ID therefore takes the form
   shown below, again assuming that the "d"'s represent the drive number:-

                bit
          7 6 5 4 3 2 1 0
         ÚÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄ¿
         ³0³0³d³d³d³d³0³0³
         ÀÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÙ

   This table, SV.MDDID, can then be indexed by the drive number to extract the
   corresponding drive ID. The drive ID can then be used wherever indexing a
   table on drive number is required.

                   LEA      SV.FSDEF(A6),A2

   A2 points at the table of pointers to the physical definition block for each
   drive. This is an example of one of the tables mentioned above.

                   MOVEA.L  0(A2,D6.W),A2          ;point at this drive's physical definition block
                   LSL.B    #2,D6                  ;and move the drive number into the high nibble

   The register, D6, now contains the drive number in the following form:-

                bit
          7 6 5 4 3 2 1 0
         ÚÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄ¿
         ³d³d³d³d³0³0³0³0³
         ÀÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÙ

   This is the form which the drive number takes in the status byte of a slave
   block table entry.

                   CMPI.B   #FS.CHECK,D0           ;filing system function required ?
                   BCS      FS_HEADR               ;jump forward to check for simple I/O if not
                   CMPI.B   #FS.SAVE,D0            ;is it a valid function at all ?
                   BHI.S    MD_ERRBP               ;exit with error if not

   At this point, the major registers are set up as follows:-

    D2.?    Some unknown value which gets tested lots of times
    D3.L    Timeout
    D6.B    Slave block table entry status byte template.
    A0.L    pointer to channel definition block for new channel.
    A2.L    pointer to physical definition block for drive number in FS.DRIVE
    A3.L    pointer to assumed start of linkage block.
    A6.L    pointer to QDOS system variables.

   Get the address offset for the chosen I/O routine and jump to it.

                   MOVE.B   MD_TBL-FS.CHECK(PC,D0.W),D0
                   JMP      MD_TBL(PC,D0.W)

   Table of offsets for general microdrive I/O.

11F6 MD_TBL        DC.B     FS_CHECK - MD_TBL      ;check pending operations
                   DC.B     FS_FLUSH - MD_TBL      ;flush all buffers
                   DC.B     FS_POSAB - MD_TBL      ;position absolute file pointer
                   DC.B     FS_POSRE - MD_TBL      ;position relative file pointer
                   DC.B     MD_ERRBP - MD_TBL      ;rename file (not implemented)
                   DC.B     FS_MDINF - MD_TBL      ;get information about medium
                   DC.B     FS_HEADS - MD_TBL      ;set file header
                   DC.B     FS_HEADR - MD_TBL      ;read file header
                   DC.B     FS_LOAD  - MD_TBL      ;load a file
                   DC.B     FS_SAVE  - MD_TBL      ;save a file

1200 MD_ERRBP      MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
                   RTS

2.6.2 File system TRAP handlers.

Ú----------------------------------------------------------------------¿
³=FS_CHECK        CHECK PENDING OPERATIONS   (TRAP #3 WITH D0 = $40)           ³
³=FS_FLUSH        FLUSH ALL BUFFERS          (TRAP #3 WITH D0 = $41)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D3.W     timeout                                             ³
³                 A0.L     channel ID                                          ³
³                                                                              ³
³EXIT:            D1 and A1  corrupted                                         ³
³                 D2,D3,A0,A2 and A3 preserved                                 ³
³                                                                              ³
³ERRORS:          ERR.NC   not complete                                        ³
³                 ERR.NO   invalid channel ID                                  ³
À----------------------------------------------------------------------Ù

   TRAP handler alters registers so thst A6 now points at system variables and
   A0 points at channel definition block.

1204 FS_CHECK      MOVEQ    #%00000011,D4          ;mask for "availability"
                   MOVEQ    #-1,D5                 ;and for inverting chosen bits
                   BRA.S    FS_CHK                 ;process the slave block table

120A FS_FLUSH      MOVEQ    #%00001100,D4          ;mask for "awaiting" field in status
                   MOVEQ    #0,D5                  ;and invert number bits
120E FS_CHK        MOVE.B   FS.DRIVE(A0),D3        ;get drive number and move into high nibble
                   LSL.B    #4,D3                  ;of bottom byte
                   BSET     #0,D3                  ;set "available" bit
                   MOVE.W   FS.FILNR(A0),D2        ;get file number

   Scan through the slave block table for this drive and process any blocks
   belonging to this file.

                   MOVEA.L  SV.BTBAS(A6),A4        ;A4 points at slave block table
1220 L01220        MOVEQ    #-15,D0                ;D0.B = %11110001

   Mask off all but the drive number and "available" bits in the status byte.

                   AND.B    (A4),D0                ;mask off bits
                   CMP.B    D3,D0                  ;correct drive or unavailable ?
                   BNE.S    L01238                 ;next entry if not
                   CMP.W    BT.FILNR(A4),D2        ;correct file number ?
                   BNE.S    L01238                 ;next entry if not
                   MOVE.B   (A4),D0                ;get the full status byte
                   EOR.B    D5,D0                  ;invert chosen bits
                   AND.W    D4,D0                  ;and mask off "awaiting" field
                   BNE      L01476                 ;do forced slaving if "waiting"
1238 L01238        ADDQ.W   #8,A4                  ;next table entry
                   CMPA.L   SV.BTTOP(A6),A4        ;end of slave block table ?
                   BLT.S    L01220                 ;check next entry if not

   All the entries in the table for this file have been found so exit.

                   MOVEQ    #0,D0                  ;signal "no errors"
                   RTS

Ú----------------------------------------------------------------------¿
³=FS_POSAB        POSITION ABSOLUTE POINTER  (TRAP #3 WITH D0 = $42)           ³
³=FS_POSRE        POSITION RELATIVE POINTER  (TRAO #3 WITH D0 = $43)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     file offset or absolute position                    ³
³                 D3.W     timeout                                             ³
³                 A0.L     channel ID                                          ³
³                                                                              ³
³EXIT:            D1.L     new file position                                   ³
³                 A1       corrupted                                           ³
³                 D2,D3,A0,A2 and A3 preserved                                 ³
³                                                                              ³
³ERRORS:          ERR.NC   not complete                                        ³
³                 ERR.NO   invalid channel ID                                  ³
³                 ERR.EF   end of file                                         ³
À----------------------------------------------------------------------Ù

   TRAP handler alters registers so thst A6 now points at system variables and
   A0 points at channel definition block.

1244 FS_POSAB      JSR      FILE_ABS(PC)           ;position absolute file pointer
                   BRA.S    L01252

124A FS_POSRE      TST.L    D3                     ;timeout zero ?
                   BNE.S    L01252                 ;exit if so
                   JSR      FILE_REL(PC)           ;position relative file pointer
1252 L01252        MOVEQ    #0,D0                  ;signal "no errors"
                   BRA.S    GET_HEAD               ;and set file header

Ú----------------------------------------------------------------------¿
³=FS_MDINF        GET MEDIUM INFORMATION     (TRAP #3 WITH D0 = $45)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D3.W     timeout                                             ³
³                 A0.L     channel ID                                          ³
³                 A1.L     location of buffer for medium name                  ³
³                                                                              ³
³EXIT:            D1.L     high word : number of unused sectors                ³
³                          low word  : number of good sectors                  ³
³                 A1.L     one character past end of medium name               ³
³                 A2 and A3  corrupted                                         ³
³                 D2,D3 and A0 preserved                                       ³
³                                                                              ³
³ERRORS:          ERR.NC   not complete                                        ³
³                 ERR.NO   invalid channel ID                                  ³
À----------------------------------------------------------------------Ù

   A2 points at physical definition block for drive.

1256 FS_MDINF      LEA      FS.MNAME(A2),A3        ;A3 points at medium name
                   MOVE.L   (A3)+,(A1)+            ;copy file name to buffer
                   MOVE.L   (A3)+,(A1)+
                   MOVE.W   (A3)+,(A1)+

   Now check the sector map backwards starting with the last sector.

                   MOVE.W   #508,D0                ;D0 points at second last pair of bytes
                   MOVEQ    #0,D1                  ;clear sector count
                   MOVEQ    #1,D2                  ;at least one good sector available
1268 L01268        CMPI.B   #$FD,MD.MAP(A2,D0.W)
                   BHI.S    MD_BAD                 ;jump forward if bad
                   BNE.S    MD_INUSE               ;and if in use
                   ADDQ.W   #1,D1                  ;increment unused sector count
1274 MD_INUSE      ADDQ.W   #1,D2                  ;increment good sector count
1276 MD_BAD        SUBQ.W   #2,D0                  ;next pair of bytes
                   BNE.S    L01268                 ;check unless end of sector map
                   SWAP     D1                     ;move unused sector count
                   MOVE.W   D2,D1                  ;insert good sector count
                   RTS

Ú----------------------------------------------------------------------¿
³=FS_LOAD         LOAD A FILE                (TRAP #3 WITH D0 = $48)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D2.L     number of bytes required                            ³
³                 D3.W     timeout (must be -1)                                ³
³                 A0.L     channel ID                                          ³
³                 A1.L     location for bytes                                  ³
³                                                                              ³
³EXIT:            A1       one past last byte loaded                           ³
³                 D1       corrupted                                           ³
³                 D2,D3,A0,A2 and A3 preserved                                 ³
³                                                                              ³
³ERRORS:          ERR.NC   not complete                                        ³
³                 ERR.NO   invalid channel ID                                  ³
³                 ERR.EF   end of file                                         ³
À----------------------------------------------------------------------Ù

1280 FS_LOAD       MOVEQ    #IO.FSTRG,D0           ;signal "fetch string of bytes"
                   CMPI.L   #$1000,D2              ;4k or more ?
                   BLT.S    GET_HEAD               ;jump forward if less
                   BSR      FS_FLUSH               ;make room for random loading
                   BEQ      L01534
                   RTS

Ú----------------------------------------------------------------------¿
³=FS_SAVE         SAVE A FILE                (TRAP #3 WITH D0 = $49)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D2.L     number of bytes to save                             ³
³                 D3.W     timeout (must be -1)                                ³
³                 A0.L     channel ID                                          ³
³                 A1.L     location of bytes                                   ³
³                                                                              ³
³EXIT:            A1       one past last byte saved                            ³
³                 D1       corrupted                                           ³
³                 D2,D3,A0,A2 and A3 preserved                                 ³
³                                                                              ³
³ERRORS:          ERR.NC   not complete                                        ³
³                 ERR.NO   invalid channel ID                                  ³
³                 ERR.DF   drive full                                          ³
À----------------------------------------------------------------------Ù

1294 FS_SAVE       MOVEQ    #IO.SSTRG,D0           ;signal "send a string of bytes"
                   BRA.S    GET_HEAD               ;do the operation

1298 L01298        MOVEQ    #IO.FSTRG,D0           ;signal "fetch a string of bytes"
                   MOVE.L   A1,-(A7)               ;save file pointer
                   BSR.S    MD_GETBL               ;get the header string
                   MOVEQ    #64,D4                 ;length of file header
                   MOVEA.L  (A7)+,A2               ;restore pointer
                   SUB.L    D4,(A2)                ;form byte number
                   RTS

Ú----------------------------------------------------------------------¿
³=FS_HEADS        SET FILE HEADER            (TRAP #3 WITH D0 = $46)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D3.W     timeout                                             ³
³                 A0.L     channel ID                                          ³
³                 A1.L     start of header                                     ³
³                                                                              ³
³EXIT:            D1.W     length of set header                                ³
³                 A1       corrupted                                           ³
³                 D2,D3,A0,A2 and A3 preserved                                 ³
³                                                                              ³
³ERRORS:          ERR.NC   not complete                                        ³
³                 ERR.NO   invalid channel ID                                  ³
À----------------------------------------------------------------------Ù

   TRAP handler alters registers so that A0 points at channel definition block

12A6 FS_HEADS      MOVEQ    #IO.SSTRG,D0           ;signal "send a string of bytes"
                   MOVEQ    #14,D2                 ;length of non-directory header
12AA MD_GETBL      CLR.L    FS.NBLOK(A0)           ;set to block zero
                   BSR.S    FS_HEADR               ;load the header
                   MOVE.W   #64,FS.NBYTE(A0)       ;next byte to be read is actual file
                   RTS

Ú----------------------------------------------------------------------¿
³=FS_HEADR        READ FILE HEADER           (TRAP #3 WITH D0 = $47)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D2.W     buffer length                                       ³
³                 D3.W     timeout                                             ³
³                 A0.L     channel ID                                          ³
³                 A1.L     location of buffer for header                       ³
³                                                                              ³
³EXIT:            D1.W     size of header read                                 ³
³                 A1       one past end of buffer                              ³
³                 D2,D3,A0,A2 and A3 preserved                                 ³
³                                                                              ³
³ERRORS:          ERR.NC   not complete                                        ³
³                 ERR.BO   buffer overflow                                     ³
³                 ERR.NO   invalid channel ID                                  ³
À----------------------------------------------------------------------Ù

   TRAP handler alters registers so that A0 points at channel definition block a
   A2 points at physical definition block for current drive.
   D1 contains zero if a string of bytes is required. D3 contains zero if
   routine entered from TRAP #3 handler.

12B8 FS_HEADR      EXT.L    D1                     ;propagate signs
                   EXT.L    D2
12BC GET_HEAD      CMPI.B   #IO.SSTRG,D0           ;valid command ?
                   BHI      MD_ERRBP               ;exit if not
                   MOVEQ    #0,D7                  ;clear frame count
                   TST.L    D3                     ;timeout zero ?
                   BEQ.S    L012CC                 ;jump forward if so
                   SUB.L    D1,D7                  ;decrement frame count
12CC L012CC        SUBQ.B   #4,D0                  ;check for "fetch" function
                   BEQ      MD_ERRBP               ;exit if TRAP to edit a line
                   BLT.S    L012E8                 ;and jump forward if "fetch" TRAP

   Must be functions 5,7 or 8 (now 1 or 3).

                   CMPI.B   #1,FS.ACCESS(A0)       ;old shared device ?
                   BEQ.S    MD_ERRRO               ;exit if so
                   MOVEQ    #-1,D3                 ;use an infinite timeout
                   SUBQ.W   #2,D0                  ;check for function number 6
                   BEQ      MD_ERRBP               ;and exit if so
                   BLT.S    MD_SBYTE               ;jump forward if function number 5
                   BGT.S    MD_SSTRG               ;and if function number 7 or 8

   Must be functions 0 to 3 (now -4 to -1)

12E8 L012E8        MOVEQ    #0,D3
                   ADDQ.B   #4,D0                  ;reset function number
                   BEQ.S    MD_SBYTE               ;jump forward if function 0
                   MOVE.W   #256,D3
                   SUBQ.B   #2,D0                  ;check for function number
                   BLT.S    MD_SBYTE               ;jump forward if functions 0 and 1
                   BGT.S    MD_SSTRG               ;jump forward if functions 2 and 3

                   MOVEQ    #10,D3
12FA MD_SSTRG      ADD.L    A1,D7
                   MOVE.L   D7,-(A7)
                   ADD.L    D2,D7
                   BSR.S    L0131C
                   MOVE.L   A1,D1
                   SUB.L    (A7)+,D1
                   RTS

1308 MD_SBYTE      MOVE.L   D1,-(A7)
                   LEA      3(A7),A1
                   MOVE.L   A1,D7
                   ADDQ.L   #1,D7
                   BSR.S    L0131C
                   MOVE.L   (A7)+,D1
                   RTS

1318 MD_ERRRO      MOVEQ    #ERR.RO,D0             ;signal "read only"
                   RTS

Ú----------------------------------------------------------------------¿
³=                                                                             ³
Ã----------------------------------------------------------------------´
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À----------------------------------------------------------------------Ù

131C L0131C        TST.B    $23(A2)
                   BGE.S    L01326
1322 MD_ERRFE      MOVEQ    #ERR.FE,D0             ;signal "bad medium"
                   RTS

1326 L01326        MOVE.L   FS.FILNR(A0),D5        ;get file number and block number
                   MOVE.L   FS.NBLOK(A0),D4
                   CMP.L    FS.EBLOK(A0),D4        ;last block in file ?
                   BLT.S    L01342                 ;jump forward if not
                   BGT.S    MD_ERREF
                   TST.B    D3
                   BLT.S    L0133E
133A MD_ERREF      MOVEQ    #ERR.EF,D0             ;signal "end of file"
133C L0133C        RTS

133E L0133E        TST.W    D4                     ;first block in file ?
                   BEQ.S    L01366                 ;jump forward if so
1342 L01342        BSR      L01430
                   BNE.S    L0133C
                   TST.W    D4
                   BNE.S    L0137C
                   MOVE.L   A4,-(A7)
                   ADDQ.W   #1,D5
                   MOVEQ    #0,D2
                   MOVE.W   D5,D2
                   SWAP     D2
                   CMP.L    FS.EBLOK(A0),D2
                   BGE.S    L01360
                   BSR      L0143C
1360 L01360        MOVEA.L  (A7)+,A4
                   SUBQ.W   #1,D5
                   BRA.S    L0137C

1366 L01366        CMP.L    A1,D7
                   BLS      L013F0
                   BSR      L014F8
                   BSR      L0147E
                   MOVE.W   D0,2(A4)
                   ORI.B    #3,(A4)
137C L0137C        MOVE.L   A4,FS.CBLOK(A0)
                   BTST     #1,(A4)
                   BEQ      L01476                 ;do pending operations
                   TST.W    D3
                   BEQ.S    L013F0
                   MOVE.L   A4,D0
                   SUB.L    SV.BTBAS(A6),D0
                   LSL.L    #6,D0
                   MOVEA.L  D0,A5
                   ADDA.L   A6,A5
                   ADDA.W   D4,A5
                   TST.W    D3
                   BGT.S    L013BE
139E L0139E        CMP.L    A1,D7
                   BLS.S    L013AC
                   MOVE.B   (A1)+,(A5)+
                   BSR.S    L013FC
                   BNE.S    L0139E
                   JSR      MD_SLAVE(PC)           ;do forced slaving
13AC L013AC        ST       $2C(A0)
                   BSR.S    L01410
                   CMP.L    FS.EBLOK(A0),D4
                   BLT.S    L013D8
                   MOVE.L   D4,FS.EBLOK(A0)
                   BRA.S    L013D8

13BE L013BE        MOVEQ    #0,D0
13C0 L013C0        CMP.L    A1,D7
                   BLS.S    L013D8
                   CMP.L    FS.EBLOK(A0),D4
                   BGE.S    L013F4
                   MOVE.B   (A5)+,D0
                   MOVE.B   D0,(A1)+
                   CMP.W    D0,D3
                   BNE.S    L013D4
                   MOVE.L   A1,D7
13D4 L013D4        BSR.S    L013FC
                   BNE.S    L013C0
13D8 L013D8        MOVE.L   D4,FS.NBLOK(A0)
                   CMP.L    A1,D7
                   BHI      L0131C
                   CMPI.W   #10,D3
                   BNE.S    L013F0
                   CMP.B    D0,D3
                   BEQ.S    L013F0
                   MOVEQ    #ERR.BO,D0             ;signal "buffer full"
                   RTS

13F0 L013F0        MOVEQ    #0,D0                  ;signal "no errors"
                   RTS

13F4 L013F4        MOVE.L   D4,FS.NBLOK(A0)
                   BRA      MD_ERREF

13FC L013FC        ADDQ.W   #1,D4
                   BTST     #9,D4
                   BEQ.S    L0140C
                   ADDQ.W   #1,D5
                   ADDI.L   #$FE00,D4
140C L0140C        TST.W    D4
                   RTS

   D6 contains drive number in bits 4 to 7 of the bottom byte.

1410 L01410        MOVEQ    #%00000111,D0
                   OR.B     D6,D0
                   MOVE.B   D0,(A4)
1416 L01416        MOVE.L   A4,D1
                   SUB.L    SV.BTBAS(A6),D1
                   LSR.L    #3,D1
                   ADDA.W   2(A4),A2
                   MOVE.W   D1,MD.PENDG(A2)
                   SUBA.W   2(A4),A2
                   SF       $24(A2)
                   RTS

   D6 contains drive number in bits 4 to 7 of the bottom byte.

1430 L01430        MOVEA.L  FS.CBLOK(A0),A4
                   MOVE.L   A4,D0
                   BNE.S    L0143C
                   MOVEA.L  SV.BTBAS(A6),A4
143C L0143C        MOVEA.L  A4,A5
143E L0143E        MOVEQ    #14,D0
                   AND.B    (A4),D0
                   BEQ.S    L01454
                   MOVEQ    #-16,D0
                   AND.B    (A4),D0
                   CMP.B    D0,D6
                   BNE.S    L01454
                   MOVEQ    #0,D0
                   CMP.L    4(A4),D5
                   BEQ.S    L0147C
1454 L01454        ADDQ.L   #8,A4
                   CMPA.L   SV.BTTOP(A6),A4
                   BLT.S    L01460
                   MOVEA.L  SV.BTBAS(A6),A4
1460 L01460        CMPA.L   A4,A5
                   BNE.S    L0143E
                   BSR      L014F2
                   BSR      L014F8
                   MOVE.W   D0,2(A4)
                   ORI.B    #9,(A4)
                   BSR.S    L01416
1476 L01476        JSR      MD_SLAVE(PC)           ;forced slaving routine
147A MD_ERRNC      MOVEQ    #ERR.NC,D0             ;signal "not complete"
147C L0147C        RTS

147E L0147E        BSR.S    L014D4
                   SUBQ.B   #1,D2
                   BCC.S    L0148C
                   MOVEQ    #-$28,D0
                   ADD.W    MD.LSECT(A2),D0
                   BRA.S    L0148E

148C L0148C        BSR.S    L014E0
148E L0148E        SUBI.W   #$18,D0
                   BGE.S    L014A4
                   MOVE.W   #$1FE,D1
1498 L01498        SUBQ.W   #2,D1
                   CMPI.B   #$FF,$28(A2,D1.W)
                   BEQ.S    L01498
                   ADD.W    D1,D0
14A4 L014A4        MOVE.W   D0,-(A7)
14A6 L014A6        SUBQ.W   #2,D0
                   BPL.S    L014AE
                   MOVE.W   #$1FC,D0
14AE L014AE        CMPI.B   #$FD,$28(A2,D0.W)
                   BEQ.S    L014C0
                   CMP.W    (A7),D0
                   BNE.S    L014A6
                   ADDQ.W   #6,A7
                   MOVEQ    #ERR.DF,D0             ;signal "drive full"
                   RTS

14C0 L014C0        ADDQ.B   #1,D2
                   MOVE.W   D2,$28(A2,D0.W)
                   MOVE.W   D0,MD.LSECT(A2)
                   MOVE.W   #$FFFF,MD.PENDG(A2)
                   ADDQ.W   #2,A7
                   RTS

14D4 L014D4        MOVE.W   #$1FE,D0
                   MOVE.L   D5,D2
                   LSL.W    #8,D2
                   LSR.L    #8,D2
                   RTS

14E0 L014E0        SUBQ.W   #2,D0
                   BLT.S    L014EC
                   CMP.W    $28(A2,D0.W),D2
                   BNE.S    L014E0
                   RTS

14EC L014EC        ADDQ.W   #8,A7
                   BRA      MD_ERRFE

14F2 L014F2        BSR.S    L014D4
                   BSR.S    L014E0
                   RTS

14F8 L014F8        MOVEA.L  SV.BTPNT(A6),A4
                   MOVEA.L  A4,A5
14FE L014FE        ADDQ.W   #8,A4
                   CMPA.L   SV.BTTOP(A6),A4
                   BLT.S    L0150A
                   MOVEA.L  SV.BTBAS(A6),A4
150A L0150A        MOVEQ    #15,D1
                   AND.B    (A4),D1
                   SUBQ.B   #1,D1
                   BEQ.S    L01520
                   SUBQ.B   #2,D1
                   BEQ.S    L01520
                   CMPA.L   A5,A4
                   BNE.S    L014FE
                   ADDQ.W   #4,A7
                   BRA      MD_ERRNC

   D6 contains drive number in bits 4 to 7 of the bottom byte.

1520 L01520        MOVE.L   A4,SV.BTPNT(A6)
                   MOVE.L   A4,FS.CBLOK(A0)
                   MOVE.B   D6,(A4)
                   ORI.B    #1,(A4)
                   MOVE.L   D5,4(A4)
                   RTS

1534 L01534        JSR      L014F8(PC)
                   SUBQ.L   #8,SV.BTPNT(A6)
                   MOVE.L   A4,D0
                   SUB.L    SV.BTBAS(A6),D0
                   LSL.L    #6,D0
                   MOVEA.L  D0,A4
                   ADDA.L   A6,A4
                   JSR      MD_SLAVE(PC)           ;do forced slaving
                   LEA      PC_MCTRL,A3
                   ANDI.B   #$DF,SV.PCINT(A6)
                   MOVE.B   SV.PCINT(A6),1(A3)
                   LSL.L    #8,D0
                   CMP.B    SV.MDRUN(A6),D1
                   BEQ.S    L0156C
                   MOVEQ    #ERR.NC,D0             ;signal "not complete"
                   BRA      L0167E

156C L0156C        MOVEQ    #7,D0
                   LEA      $58(A0),A5
1572 L01572        CLR.L    (A5)+
                   DBF      D0,L01572
                   MOVE.L   FS.EBLOK(A0),D2
                   TST.W    D2
                   BNE.S    L01586
                   SUBI.L   #$FE00,D2
1586 L01586        MOVE.L   D2,FS.NBLOK(A0)
                   SWAP     D2
                   MOVE.W   D2,D0
                   LSR.W    #3,D0
                   LEA      $58(A0),A5
                   BRA.S    L01598

1596 L01596        ST       (A5)+
1598 L01598        DBF      D0,L01596
                   MOVE.W   #$FF01,D1
                   MOVEQ    #7,D0
                   AND.W    D2,D0
                   ROL.W    D0,D1
                   MOVE.B   D1,(A5)
                   SUBA.W   #$40,A1
                   MOVEM.L  A0-2/A4,-(A7)
15B0 L015B0        ANDI.W   #$F8FF,SR
                   ORI.W    #$0700,SR
15B8 L015B8        MOVEA.L  (A7),A0
                   LEA      $78(A0),A1
                   JSR      MD_SECTR               ;read sector header

   Return points for the three read sector header errors.

                   BRA.S    L01630                 ;branch if bad header
                   BRA.S    L015B0                 ;branch if bad medium

                   MOVEM.L  (A7),A0-2/A4           ;branch if ok
                   ADD.W    D7,D7
                   BEQ      L01656
                   MOVE.B   $28(A2,D7.W),D0
                   CMP.B    $1F(A0),D0
                   BNE.S    L015B0
                   MOVEQ    #0,D4
                   MOVE.B   $29(A2,D7.W),D4
                   MOVE.L   D4,D7
                   MOVEQ    #7,D5
                   AND.W    D4,D5
                   LSR.W    #3,D4
                   BTST     D5,$58(A0,D4.W)
                   BEQ.S    L015B0
                   MOVEA.W  D4,A5
                   MOVEA.L  A4,A1
                   JSR      MD_READ                ;read a microdrive sector
                   BRA.S    L015B8

15FC L015FC        MOVEM.L  (A7),A0-2/A4
                   BCLR     D5,$58(A0,A5.W)
                   MOVE.L   #$80,D0
                   MOVEA.L  A1,A5
                   MOVE.L   D7,D1
                   LSL.W    #8,D1
                   ADD.L    D1,D1
                   ADDA.L   D1,A5
                   CMP.W    FS.NBLOK(A0),D7
                   BNE.S    L01620
                   MOVE.W   $22(A0),D0
                   ROR.L    #2,D0
1620 L01620        TST.W    D7
                   BNE.S    L01634
                   MOVEQ    #$40,D1
                   ADDA.W   D1,A4
                   ADDA.W   D1,A5
                   SUBI.W   #$10,D0
                   BRA.S    L01634

1630 L01630        BRA.S    L01664

1632 L01632        MOVE.L   (A4)+,(A5)+
1634 L01634        DBF      D0,L01632
                   CLR.W    D0
                   ROL.L    #2,D0
                   BRA.S    L01640

163E L0163E        MOVE.B   (A4)+,(A5)+
1640 L01640        DBF      D0,L0163E
                   MOVEQ    #8,D0
                   LEA      $58(A0),A5
164A L0164A        TST.L    (A5)+
                   BNE      L015B8
                   SUBQ.W   #1,D0
                   BGT.S    L0164A
                   BRA.S    L01666

1656 L01656        ADDQ.B   #1,$24(A2)
                   CMPI.B   #8,$24(A2)
                   BLT      L015B0
1664 L01664        MOVEQ    #-$10,D0
1666 L01666        MOVEM.L  (A7)+,A0-2/A4
                   SF       $24(A2)
                   MOVEQ    #0,D7
                   MOVE.W   FS.EBLOK(A0),D7
                   LSL.L    #8,D7
                   ADD.L    D7,D7
                   ADDA.L   D7,A1
                   ADDA.W   $26(A0),A1
167E L0167E        ORI.B    #$20,SV.PCINT(A6)
                   ANDI.W   #$F8FF,SR
                   RTS

Ú----------------------------------------------------------------------¿
³=MD_OPEN         OPEN A MICRODRIVE CHANNEL  (TRAP #2 WITH D0 = $01)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     job ID (-1 if current job)                          ³
³                 D3.L     open type:-                                         ³
³                                                                              ³
³                          0 = old exclusive device                            ³
³                          1 = old shared device                               ³
³                          3 = new overwrite file                              ³
³                          4 = open directory                                  ³
³                          -ve delete                                          ³
³                                                                              ³
³                 A0.L     address of channel name                             ³
³                                                                              ³
³EXIT:            D1.L     job ID                                              ³
³                 A0.L     new channel ID                                      ³
³                 D2,D3,A1,A2 and A3 preserved                                 ³
³                                                                              ³
³ERRORS:          ERR.NJ   invalid job ID                                      ³
³                 ERR.OM   out of memory                                       ³
³                 ERR.NO   too many channels                                   ³
³                 ERR.NF   device not found                                    ³
³                 ERR.FE   file already exists                                 ³
³                 ERR.IU   file or device in use                               ³
³                 ERR.BN   bad device name                                     ³
À----------------------------------------------------------------------Ù

   TRAP handler alters registers so that A0 points at channel definition block,
   A1 points at physical definition block for specified drive,A3 is assumed start
   of linkage block and A6 points at system variables.

168A MD_OPEN       MOVEA.L  A1,A2                  ;A2 points at physical definition block
                   MOVEQ    #0,D1                  ;prepare D1
                   MOVE.B   FS.DRIVN(A2),D1        ;get drive number
                   MOVEQ    #0,D0                  ;prepare D0
                   MOVE.B   FS.DRIVE(A0),D0        ;get drive ID
                   LSL.B    #2,D0                  ;move into high nibble of low byte
                   LEA      SV.MDDID - 2(A6),A4
                   MOVE.B   D0,1(A4,D1.W)          ;set up drive ID
                   CMP.B    (A4),D1                ;currently turning microdrive ?
                   BEQ.S    L016C0                 ;jump forward if so
                   TST.B    7(A4,D1.W)             ;any pending operations ?
                   BNE.S    L016C0                 ;jump forward if so
                   MOVE.B   #1,$23(A2)
                   JSR      L0291A(PC)
16B6 L016B6        TST.B    $23(A2)
                   BGT.S    L016B6
                   BMI      MD_ERRNF
16C0 L016C0        LEA      FS.SPARE(A0),A4
                   MOVEQ    #64,D2                 ;length of file header
                   MOVE.L   D2,FS.EBLOK(A0)        ;set block number to zero and EOF to 64
                   MOVEQ    #-1,D3
                   BSR      L017A6
                   MOVE.L   (A4),D4
                   MOVE.L   D4,D0
                   LSL.L    #7,D0
                   LSR.W    #7,D0
                   MOVE.L   D0,FS.EBLOK(A0)
                   CMPI.B   #4,FS.ACCESS(A0)       ;open directory ?
                   BEQ      MD_END                 ;exit if so
                   LSR.L    #6,D4
                   MOVEQ    #0,D5
                   MOVEQ    #0,D6
                   BRA.S    L01718

16EE L016EE        BSR      L017A6
                   TST.L    (A4)
                   BEQ.S    L01712
                   MOVE.L   A0,-(A7)
                   MOVE.L   A6,-(A7)
                   SUBA.L   A6,A6
                   LEA      14(A4),A1
                   LEA      FS.FNAME(A0),A0
                   MOVEQ    #1,D0
                   JSR      UT_CSTR(PC)            ;compare filenames
                   MOVEA.L  (A7)+,A6
                   MOVEA.L  (A7)+,A0
                   BEQ.S    L0177C
                   BRA.S    L01718

1712 L01712        TST.W    D6
                   BNE.S    L01718
                   MOVE.W   D5,D6
1718 L01718        ADDQ.W   #1,D5
                   CMP.W    D4,D5
                   BLT.S    L016EE
                   MOVE.B   FS.ACCESS(A0),D0
                   BLT.S    MD_END
                   CMPI.B   #2,D0                  ;new exclusive device ?
                   BLT.S    MD_ERRNF
                   TST.W    D6
                   BEQ.S    L0173C
                   MOVE.L   D6,D0
                   LSL.L    #6,D0
                   LSL.L    #7,D0
                   LSR.W    #7,D0
                   MOVE.L   D0,FS.NBLOK(A0)
                   MOVE.L   D6,D5

   Now set up the medium name.

173C L0173C        MOVE.L   D2,(A4)+               ;first set the random number prefix
                   CLR.W    (A4)+                  ;and clear the remaining ten bytes
                   CLR.L    (A4)+
                   CLR.L    (A4)+
                   MOVEQ    #9,D0                  ;length of medium name - 1
                   LEA      FS.FNAME(A0),A5
174A L0174A        MOVE.L   (A5)+,(A4)+            ;copy name to header
                   DBF      D0,L0174A
                   LEA      FS.SPARE(A0),A4
                   BSR.S    L017AA
                   TST.W    D6
                   BNE.S    L0176A
                   ADDQ.W   #1,D4
                   LSL.L    #6,D4
                   MOVE.L   D4,(A4)
                   CLR.L    FS.NBLOK(A0)
                   MOVEQ    #4,D2
                   BSR.S    L017AA
                   MOVEQ    #$40,D2
176A L0176A        MOVE.L   D2,(A4)
                   CLR.L    FS.NBLOK(A0)
                   CLR.L    FS.EBLOK(A0)
                   MOVE.W   D5,FS.FILNR(A0)
                   BSR.S    L017AA
                   BRA.S    MD_END

177C L0177C        MOVE.B   FS.ACCESS(A0),D0
                   BLT.S    L017B8
                   CMPI.B   #2,D0
                   BGE.S    MD_ERREX
                   MOVE.L   (A4),D0
                   LSL.L    #7,D0
                   LSR.W    #7,D0
                   MOVE.L   D0,FS.EBLOK(A0)
                   MOVE.W   D5,FS.FILNR(A0)
                   MOVE.L   D2,FS.NBLOK(A0)
179A MD_END        MOVEQ    #0,D0
                   BRA.S    L017A4

179E MD_ERRNF      MOVEQ    #ERR.NF,D0             ;signal "not found"
                   BRA.S    L017A4

17A2 MD_ERREX      MOVEQ    #ERR.EX,D0             ;signal "already exists"
17A4 L017A4        RTS

17A6 L017A6        MOVEQ    #IO.FSTRG,D0           ;signal "fetch a string of bytes"
                   BRA.S    L017AC

17AA L017AA        MOVEQ    #IO.SSTRG,D0           ;signal "send a string of bytes"
17AC L017AC        MOVEA.L  A4,A1
                   JSR      REPEATIO(PC)           ;repeat I/O operation until finished
                   BEQ.S    L017A4                 ;exit if number errors otherwise ignore
                   ADDQ.W   #4,A7                  ;saved error long word
                   RTS

17B8 L017B8        MOVEQ    #-64,D1                ;length of file header
                   JSR      FILE_REL(PC)           ;position relative file pointer
                   CLR.L    (A4)
                   CLR.W    14(A4)
                   BSR.S    L017AA
                   MOVE.W   #$1FE,D0
                   LEA      $28(A2,D0.W),A4
17CE L017CE        CMP.B    (A4),D5
                   BNE.S    L017DA
                   MOVE.W   #$FD00,(A4)
                   CLR.W    512(A4)
17DA L017DA        SUBQ.W   #2,A4
                   SUBQ.W   #2,D0
                   BNE.S    L017CE
                   MOVE.B   FS.DRIVE(A0),D1
                   LSL.B    #4,D1
                   ADDQ.W   #1,D1
                   MOVEA.L  SV.BTBAS(A6),A4
17EC L017EC        MOVEQ    #-15,D0
                   AND.B    (A4),D0
                   CMP.B    D0,D1
                   BNE.S    L017FE
                   CMP.W    4(A4),D5
                   BNE.S    L017FE
                   MOVE.B   #1,(A4)
17FE L017FE        ADDQ.W   #8,A4
                   CMPA.L   SV.BTTOP(A6),A4
                   BLT.S    L017EC
                   MOVE.W   #-1,MD.PENDG(A2)
                   JSR      MD_SLAVE(PC)           ;do forced slaving
                   BRA.S    MD_END

Ú----------------------------------------------------------------------¿
³=MD_CLOSE        CLOSE A MICRODRIVE CHANNEL (TRAP #2 WITH D0 = $02)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           A0.L     channel ID                                          ³
³                                                                              ³
³EXIT:            A0       corrupted                                           ³
³                 D1,D2,D3,A1,A2 and A3 preserved                              ³
³                                                                              ³
³ERRORS:          ERR.NC   channel not open                                    ³
À----------------------------------------------------------------------Ù

   TRAP handler alters registers so that A6 now points at system variables and
   A0 points at channel definition block.

1812 MD_CLOSE      TST.B    FS.UPDT(A0)            ;file updated ?
                   BEQ.S    L0184A                 ;jump forward if not
                   MOVE.L   FS.EBLOK(A0),D0        ;get block number containing EOF
                   LSL.W    #7,D0                  ;form overall file pointer
                   LSR.L    #7,D0
                   LEA      FS.SPARE(A0),A1
                   MOVE.L   D0,(A1)
                   CLR.L    FS.NBLOK(A0)           ;signal "block 0 contains next byte"
                   BSR.S    L01874
                   MOVEQ    #0,D0                  ;prepare D0
                   MOVE.W   FS.FILNR(A0),D0        ;get file number
                   LSL.L    #6,D0
                   LSL.L    #7,D0
                   LSR.W    #7,D0
                   MOVE.L   D0,FS.NBLOK(A0)
                   CLR.W    FS.FILNR(A0)
                   ST       FS.EBLOK + 1(A0)
                   BSR.S    L01874
                   JSR      MD_SLAVE(PC)           ;do forced slaving
184A L0184A        MOVEQ    #0,D0
                   MOVE.B   FS.DRIVE(A0),D0
                   LSL.B    #2,D0
                   LEA      SV.FSDEF(A6),A2
                   MOVEA.L  0(A2,D0.W),A2
                   SUBQ.B   #1,FS.FILES(A2)
                   LEA      SV.STACB(A6),A1
                   LEA      FS.NEXT(A0),A0         ;A0 points at next channel for file syst
                   JSR      UT_UNLNK(PC)           ;unlink this channel from list
                   LEA      -$18(A0),A0
                   JSR      MM_RECHP(PC)           ;reclaim the channel definition block
                   RTS

1874 L01874        MOVEQ    #IO.SSTRG,D0           ;signal "send a string of bytes"
                   MOVEQ    #4,D2
                   JSR      REPEATIO(PC)           ;repeat I/O operation until finished
                   SUBA.W   D1,A1
                   RTS

Ú----------------------------------------------------------------------¿
³=FILE_ABS        POSITION FILE POINTER USING ABSOLUTE OFFSET                  ³
³=FILE_REL        POSITION FILE POINTER USING RELATIVE OFFSET                  ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     required offset                                     ³
³                 A0.L     channel definition block                            ³
³                 A6.L     system variables                                    ³
³                                                                              ³
³EXIT:            A1.L     updated file pointer                                ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

1880 FILE_ABS      MOVEQ    #64,D2                 ;length of file header
                   ADD.L    D2,D1                  ;add to file pointer
                   BRA.S    L01892                 ;position the pointer

1886 FILE_REL      MOVEQ    #64,D2                 ;length of file header

   get block number containing next byte,in high word and byte no in low word.

1888 L01888        MOVE.L   FS.NBLOK(A0),D0        ;get block and byte number
188C L0188C        LSL.W    #7,D0                  ;move byte number to bits 7 to 15 of D0
                   LSR.L    #7,D0                  ;form byte number within whole file
                   ADD.L    D0,D1                  ;add requested signed position
1892 L01892        MOVE.L   D1,D0
                   LSL.L    #7,D0                  ;move block number and byte no back into
                   LSR.W    #7,D0                  ;there respective positions
                   CMP.L    FS.EBLOK(A0),D0        ;past end of file ?
                   BLE.S    L018A6                 ;jump forward if not
                   MOVE.L   FS.EBLOK(A0),D0        ;otherwise recalculate byte number of end
                   MOVEQ    #0,D1                  ;of file
                   BRA.S    L0188C

18A6 L018A6        SUB.L    D2,D1                  ;subtract header length
                   BGE.S    L018AE                 ;jump forward if past start of file
                   MOVE.L   D2,D1                  ;otherwise set to start of file
                   BRA.S    L01892

18AE L018AE        MOVE.L   D0,FS.NBLOK(A0)        ;update block number of next byte
                   RTS



;part 9
2.10 IPC routines.

Ú----------------------------------------------------------------------¿
³=IPC_CMND        DO IPC COMMAND                                               ³
Ã----------------------------------------------------------------------´
³ENTRY:           A3.L     address of command string                           ³
³                                                                              ³
³EXIT:            A3.L     one past end of command string                      ³
³                 D1.B     return parameter if specified                       ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

   All user IPC commands have a precisely defined format. Any deviation
   from this will result in the IPC crashing. the format is as follows:-

   1.     Function number in low nibble (0 to 15)          $00(A3) byte
   2.     number of parameters to send, n = 0 to 17        $01(A3) byte
   3.     Amount bit string (see below)                    $02(A3) long
   4.     The parameters to be sent                        $06(A3) n bytes
   5.     size of reply expected if any                    7+n(A3) byte

   There are 16 commands altogether as follows:-

    1.    IPC_0    processor reset                     0 0 ? ? ? ? 1
    2.    IPC_1    report input status                 1 0 ? ? ? ? 2
    3.    IPC_2    open serial port 1                  2 0 ? ? ? ? 1
    4.    IPC_3    open serial port 2                  3 0 ? ? ? ? 1
    5.    IPC_4    close serial port 1                 4 0 ? ? ? ? 1
    6.    IPC_5    close serial port 2                 5 0 ? ? ? ? 1
    7.    IPC_6    read serial port 1
    8.    IPC_7    read serial port 2
    9.    IPC_8    read keyboard
   10.    IPC_9    keyboard direct read                9 1 0 0 0 0 row 2
   11.    IPC_10   initiate sound process              23 bytes total
   12.    IPC_11   kill sound process                  B 0 ? ? ? ? 1
   13.    IPC_12   microdrive reduced sensitivity
   14.    IPC_13   change baud rate
   15.    IPC_14   random number generator             E 0 ? ? ? ? 2
   16.    IPC_16   test

   The whole IPC communications process is extremely slow as it uses a very
   complex protocol consisting of multiple bit tests for each bit used.

2B8C IPC_CMND      MOVE     SR,-(A7)
                   ORI.W    #$0700,SR              ;disable interrupts
                   JSR      IPC_SET(PC)            ;set up registers for IPC command
                   MOVE.B   (A3)+,D0               ;get command number
                   BSR.S    IPC_PARA               ;send the command number nibble
                   MOVE.B   (A3)+,D7               ;get number of parameters to send
                   MOVE.L   (A3)+,D4               ;and the amount bit string long word

   The amount bit string long word consists of pairs of bits for each of
   the parameters sent as follows:-

   1.     %00 = send least significant nibble (four bits)
   2.     %01 = send nothing
   3.     %10 = send all eight bits,high nibble first, then low nibble
   4.     %11 = send nothing

   The reply size byte also uses the same format.

2B9E IPC_PUT       SUBQ.B   #1,D7                  ;next parameter number
                   BLT.S    IPC_END                ;exit if number more or finished
                   MOVE.B   (A3)+,D0               ;get the parameter
                   BTST     #0,D4                  ;nothing to be sent ?
                   BNE.S    L02BBA                 ;jump forward if so
                   BTST     #1,D4                  ;4 or 8 bits ?
                   BEQ.S    L02BB8                 ;jump forward if only 4
                   MOVE.W   D0,D5                  ;save parameter
                   ROR.W    #4,D0                  ;move high nibble into view
                   BSR.S    IPC_PARA               ;send it
                   MOVE.W   D5,D0                  ;restore parameter
2BB8 L02BB8        BSR.S    IPC_PARA               ;then send the low nibble
2BBA L02BBA        ROR.L    #2,D4                  ;move next amount bits into place
                   BRA.S    IPC_PUT                ;and check next parameter

   All the parameters, if any, have been sent so check to see if a return
   parameter is required and find it's size.

2BBE IPC_END       MOVE.B   (A3)+,D4               ;get size of reply required
                   BTST     #0,D4                  ;number reply ?
                   BNE.S    ACK_INTR               ;jump forward if so
                   BTST     #1,D4                  ;4 or 8 bits ?
                   BNE.S    IPC_GETP               ;jump forward if only 8
                   JSR      IPC_RETN(PC)           ;get return parameter nibble
                   BRA.S    ACK_INTR               ;acknowledge receipt of parameter

2BD2 IPC_GETP      JSR      IPC_RETB(PC)           ;get return parameter byte

Ú----------------------------------------------------------------------¿
³=ACK_INTR        ACKNOWLEDGE PERIPHERAL INTERRUPT OR COMMAND                  ³
Ã----------------------------------------------------------------------´
³ENTRY:           A0.L     address of interrupt or peripheral register         ³
³                 A6.L     system variables                                    ³
³                                                                              ³
³EXIT:            D7.L     new interrupt status                                ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

2BD6 ACK_INTR      MOVEQ    #%00000010,D7          ;mask for acknowledge bit
                   OR.B     SV.PCINT(A6),D7        ;update copy of register

   Acknowledge the interrupt by sending copy to transmit register.

                   MOVE.B   D7,1(A0)               ;acknowledge the interrupt or command
                   RTE

2BE2 IPC_PARA      JMP      IPC_SEND(PC)           ;send command to ipc

Ú----------------------------------------------------------------------¿
³=INTRFINT        INTERFACE INTERRUPT HANDLER                                  ³
Ã----------------------------------------------------------------------´
³ENTRY:           A5.L     saved SuperBASIC registers                          ³
³                 A6.L     start of system variables                           ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À----------------------------------------------------------------------Ù

   The registers are saved in the order:-

   1.     Long word for program counter       $0E(A5)
   2.     Word for status register            $0C(A5)
   3.     Long word for A6                    $08(A5)
   4.     Long word for A5                    $04(A5)
   5.     Long word for D7                    $00(A5)

2BE6 INTRFINT      MOVEM.L  D0-6/A0-4,-(A7)        ;save the rest of the registers
                   MOVEQ    #0,D3
                   BSR.S    CHK_IPC                ;check IPC I/P status
                   MOVEQ    #%00000010,D7          ;mask for interface bit
                   BRA.S    L02C00                 ;acknowledge the interrupt

Ú----------------------------------------------------------------------¿
³=TRNSMINT        TRANSMIT INTERRUPT HANDLER                                   ³
Ã----------------------------------------------------------------------´
³ENTRY:           A5.L     saved SuperBASIC registers                          ³
³                 A6.L     start of system variables                           ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À----------------------------------------------------------------------Ù

   The registers are saved in the order:-

   1.     Long word for program counter       $0E(A5)
   2.     Word for status register            $0C(A5)
   3.     Long word for A6                    $08(A5)
   4.     Long word for A5                    $04(A5)
   5.     Long word for D7                    $00(A5)

2BF2 TRNSMINT      MOVEM.L  D0-6/A0-4,-(A7)        ;save the rest of the registers
                   MOVEQ    #0,D3
                   ST       D4
                   BSR      SER_TXRX               ;handle serial port transmission
                   MOVEQ    #%00000100,D7          ;mask for transmit bit
2C00 L02C00        OR.B     SV.PCINT(A6),D7        ;add to copy of interrupt register
                   MOVE.B   D7,PC_INTR             ;acknowledge the interrupt
                   MOVEM.L  (A7)+,D0-6/A0-4        ;restore the registers saved above
                   BRA      EXITTRAP               ;exit TRAP #1's

Ú----------------------------------------------------------------------¿
³=POLLTASK        START (AND END) OF POLLED TASKS LINKED LIST                  ³
³=SECTASK         SECOND TASK IN SCHEDULER LINKED LIST                         ³
Ã----------------------------------------------------------------------´
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À----------------------------------------------------------------------Ù

2C12 POLLTASK      DC.L     0                      ;link to next entry (null)
                   DC.L     L02C22                 ;pointer to routine

2C1A SECTASK       DC.L     DOWAITIO               ;link to next entry
                   DC.L     L02C2E                 ;pointer to routine

   Similar to interface interrupt.

2C22 L02C22        MOVE     SR,-(A7)               ;save SR to allow "RTE" return
                   ORI.W    #$0700,SR              ;disable interrupts
                   BSR.S    CHK_IPC                ;do normal interface interrupt actions
                   JMP      ACK_INTR(PC)           ;then acknowledge the interrupt

   Similar to transmit interrupts.

2C2E L02C2E        MOVE     SR,-(A7)               ;save SR to allow "RTE" return
                   ORI.W    #$0700,SR              ;disable interrupts
                   SF       D4
                   BSR.S    SER_TXRX               ;do normal transmit interrupt actions
                   RTE

Ú----------------------------------------------------------------------¿
³=CHK_IPC         CHECK IPC INPUT STATUS                                       ³
Ã----------------------------------------------------------------------´
³ENTRY:           A6.L     start of system variables                           ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

2C3A CHK_IPC       JSR      IPC_SET(PC)            ;set up registers for IPC command
                   MOVEQ    #IPC_1,D0              ;"read IPC input status" command
                   JSR      IPC_SEND(PC)           ;send the command
                   JSR      IPC_RETB(PC)           ;get the return parameter byte

   The bits of the IPC status byte have the following meanings when set:-

   1.     bit 0 = key being pressed
   2.     bit 1 = sound is being produced
   3.     bit 4 = a byte has been read from serial port 1
   4.     bit 5 = a byte has been read from serial port 2
   5.     bit 6 = the rotating cartridge is write protected

   Bits 2,3 and 7 are undefined but may change between readings.

                   MOVE.B   D1,D7                  ;copy status
                   BTST     #6,D7                  ;rotating cartridge write protected ?
                   SEQ      SV.WP(A6)              ;signal "not protected" if not
                   BTST     #1,D7                  ;sound being produced ?
                   SNE      SV.SOUND(A6)           ;signal "sound on" if so
                   BTST     #0,D7                  ;key being pressed ?
                   BEQ.S    CHK_SER1               ;jump forward if not
                   JSR      CHK_KEY(PC)            ;otherwise decode the key press

   Read both RS232 ports if data available and suitable queues exist.

2C64 CHK_SER1      MOVE.L   SV.SER1C(A6),D0        ;D0 points at serial port 1 I/P queue
                   BEQ.S    CHK_SER2               ;jump forward if number queue
                   BTST     #4,D7                  ;byte read from port 1 ?
                   BEQ.S    CHK_SER2               ;jump forward if not
                   MOVEA.L  D0,A2                  ;copy address of queue
                   MOVEQ    #6,D5
                   JSR      L02D32(PC)             ;insert the byte read into the queue
2C78 CHK_SER2      MOVE.L   SV.SER2C(A6),D0        ;D0 points at serial port 2 I/P queue
                   BEQ.S    EXIT_CHK               ;exit if number queue
                   BTST     #5,D7                  ;byte read from port 2 ?
                   BEQ.S    EXIT_CHK               ;exit if not
                   MOVEA.L  D0,A2                  ;copy address of queue
                   MOVEQ    #7,D5
                   JSR      L02D32(PC)             ;insert the byte read into the queue
2C8C EXIT_CHK      RTS

Ú----------------------------------------------------------------------¿
³=SER_TXRX        DO TRANSMIT INTERRUPT ACTION FOR SERIAL PORTS                ³
Ã----------------------------------------------------------------------´
³ENTRY:           A6.L     start of system variables                           ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À----------------------------------------------------------------------Ù

2C8E SER_TXRX      LEA      SV.TMODE(A6),A4        ;A4 points at ULA transmit mode copy
                   BTST     #4,(A4)                ;microdrive turning ?
                   BNE.S    L02CA2                 ;jump forward if not
                   LEA      PC_IPCRD,A1            ;A1 points at IPC read only port
                   BTST     #1,(A1)
2CA2 L02CA2        BNE.S    L02D1C
                   MOVEQ    #0,D6
                   MOVE.B   (A4),D6
                   LSL.B    #4,D6
                   LSR.B    #7,D6
                   MOVE.W   D6,D7
                   ADDQ.B   #4,D7
                   LSL.B    #2,D6
                   LEA      SV.SER1C(A6),A5
                   ADDA.W   D6,A5
                   MOVE.L   (A5),D0
                   BEQ.S    L02D1E
                   MOVEA.W  #$62,A2
                   ADDA.L   D0,A2
                   TST.B    -$65(A2)
                   BEQ.S    L02CCC
                   BTST     D7,(A1)
                   BNE.S    L02CD8
2CCC L02CCC        JSR      IO_QOUT(PC)
                   BEQ.S    L02D10
                   ADDQ.L   #1,D0
                   BEQ.S    L02D1E
                   BRA.S    L02CEE

2CD8 L02CD8        JSR      IO_QTEST(PC)           ;test queue status
                   CMPI.W   #ERR.IU,D0             ;in use ?
                   BNE.S    L02D1E
                   TST.B    -$63(A2)
                   BLT.S    L02CEE
                   TST.B    -$65(A2)
                   BNE.S    L02D1C
2CEE L02CEE        TST.B    D4
                   BNE.S    L02D1C
                   MOVE.B   -$63(A2),D6
                   LEA      -$82(A2),A0
                   JSR      MM_RECHP(PC)           ;release the space
                   CLR.L    (A5)
                   TST.B    D6
                   BLT.S    L02D1C
                   MOVEQ    #$1A,D1
                   BTST     #0,-$67(A2)
                   BEQ.S    L02D10
                   MOVEQ    #-$66,D1
2D10 L02D10        MOVE.B   D1,PC_TDATA            ;send to transmit register
                   MOVE.W   SV.TIMOV(A6),SV.TIMO(A6)
2D1C L02D1C        RTS

2D1E L02D1E        SUB.W    D3,SV.TIMO(A6)
                   BGE.S    L02D1C
                   CLR.W    SV.TIMO(A6)
                   BCHG     #3,(A4)
                   MOVE.B   (A4),-$1E(A1)
                   RTS

Ú----------------------------------------------------------------------¿
³=                                                                             ³
Ã----------------------------------------------------------------------´
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À----------------------------------------------------------------------Ù

2D32 L02D32        JSR      IO_QTEST(PC)           ;test queue status
                   CMPI.W   #$19,D2                ;enough free space ?
                   BLT.S    L02D70
                   MOVE.L   D5,D0
                   JSR      IPC_SEND(PC)
                   JSR      IPC_RETB(PC)
                   MOVE.B   D1,D4
                   ANDI.W   #%00111111,D4
                   BEQ.S    L02D70
                   SUBQ.W   #1,D4
2D50 L02D50        JSR      IPC_RETB(PC)
                   TST.B    -2(A2)
                   BLT.S    L02D68
                   MOVEQ    #%01111111,D0
                   AND.B    D1,D0
                   CMPI.B   #$1A,D0
                   BNE.S    L02D68
                   JSR      IO_QEOF(PC)
2D68 L02D68        JSR      IO_QIN(PC)
                   DBF      D4,L02D50
2D70 L02D70        RTS

Ú----------------------------------------------------------------------¿
³=CHK_KEY         SCAN THE KEYBOARD AND DECODE KEY PRESS                       ³
Ã----------------------------------------------------------------------´
³ENTRY:           A6.L     QDOS system variables                               ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À----------------------------------------------------------------------Ù

2D72 CHK_KEY       MOVEA.L  SV.KEYQ(A6),A2         ;A2 points at current keyboard queue
                   MOVE.L   A2,D0
                   BEQ.S    L02DD6                 ;exit if number queue
                   MOVEQ    #IPC_8,D0              ;"read keyboard" command
                   JSR      IPC_SEND(PC)           ;send the command
                   JSR      IPC_RETN(PC)           ;and get the return parameter nibble
                   MOVE.B   D1,D5                  ;save it
                   MOVE.B   D1,D4
                   ANDI.W   #%00000111,D4          ;multiple key press ?
                   BEQ.S    L02DAC                 ;jump forward if so
                   SUBQ.W   #1,D4

   Now scan the keyboard and perform the key repeat algorithm. The ????????
   routine takes into account all the special key combinations.

2D90 L02D90        CLR.W    SV.ARBUF(A6)           ;clear auto-repeat buffer
                   JSR      IPC_RETN(PC)           ;get parameter nibble for row number
                   MOVE.B   D1,D2                  ;copy to D2
                   JSR      IPC_RETB(PC)           ;get key bits byte for that row
                   JSR      L0AABE                 ;convert to ascii code in D1

   These are the return points for the two decode key errors.

                   BRA.S    BRK_KEY                ;branch if break key pressed
                   BSR.S    L02E00                 ;branch if key ok
                   DBF      D4,L02D90              ;scan keyboard again

   the keyboard has been scanned to ?

2DAC L02DAC        BTST     #3,D5                  ;multiple key press ?
                   BEQ.S    L02DD0                 ;jump forward if so
                   SUB.W    D3,SV.ARCNT(A6)        ;reduce count
                   BGT.S    L02DD6                 ;exit if not timed out
                   JSR      IO_QTEST(PC)           ;test current keyboard queue status
                   TST.L    D0                     ;in use ?
                   BEQ.S    L02DC8
                   MOVE.W   SV.ARBUF(A6),D1
                   BEQ.S    L02DC8
                   BSR.S    L02E00
2DC8 L02DC8        MOVE.W   SV.ARFRQ(A6),SV.ARCNT(A6)
                   RTS

2DD0 L02DD0        MOVE.W   SV.ARDEL(A6),SV.ARCNT(A6)
2DD6 L02DD6        RTS

2DD8 BRK_KEY       SF       SV.SCRST(A6)           ;switch screen on
                   MOVEA.L  SV.JBBAS(A6),A3        ;A3 points at first entry in job table
                   MOVEA.L  (A3),A3                ;and then at SuperBASIC's job header
                   SF       JB.END+BV.BRK(A3)      ;signal "break pressed"
                   MOVE.W   JB.STAT(A3),D0         ;get job status
                   BEQ.S    L02DFE                 ;exit if already active
                   ADDQ.W   #1,D0                  ;otherwise increment status
                   BLT.S    L02DFE                 ;and exit if it was "waiting"
                   CLR.W    JB.STAT(A3)            ;signal "not suspended"
                   MOVE.L   JB.HOLD(A3),D0         ;get address to be cleared on release
                   BEQ.S    L02DFE                 ;exit if none given
                   MOVEA.L  D0,A3                  ;copy address and clear it
                   SF       (A3)
2DFE L02DFE        RTS

   check for any special key codes.

2E00 L02E00        CMPI.W   #$F9,D1                ;CTRL F5 ?
                   BEQ.S    CTRL_F5                ;jump forward if so
                   SF       SV.SCRST(A6)           ;otherwise signal "screen active"
                   CMP.W    SV.CQCH(A6),D1         ;change keyboard queue ?
                   BEQ.S    CTRL_C                 ;jump forward if so
                   CMPI.W   #$E0,D1                ;CAPS LOCK ?
                   BNE.S    CHK_ALT                ;jump forward if not
                   NOT.B    SV.CAPS(A6)            ;invert caps lock status
                   TST.L    SV.CSUB(A6)            ;is there a routine to call ?
                   BEQ.S    L02DD6                 ;exit if not
                   LEA      SV.CSUB(A6),A5         ;otherwise get address of routine
                   JMP      (A5)                   ;and call it

   Now check for combinations using the ALT key. D1 will contain $FF in
   it's least significant byte if the ALT key was pressed with it.

2E26 CHK_ALT       MOVE.W   SV.ARDEL(A6),SV.ARCNT(A6)
                   MOVE.W   D1,SV.ARBUF(A6)        ;use as last key pressed
                   CMPI.B   #$FF,D1                ;ALT pressed with the key ?
                   BNE.S    NO_ALT                 ;insert the character alone if not
                   SWAP     D1                     ;save both characters
                   JSR      IO_QTEST(PC)           ;check queue status

   The free space left in the queue is now in D2.

                   CMPI.W   #2,D2                  ;room for another two characters ?
                   BLT.S    L02DD6                 ;exit if not
                   SWAP     D1                     ;move characters back into view
                   JSR      IO_QIN(PC)             ;and insert $FF into the queue
                   LSR.W    #8,D1                  ;move key pressed with it into view
2E4A NO_ALT        JMP      IO_QIN(PC)             ;and insert it into the queue.

Ú----------------------------------------------------------------------¿
³=CTRL_F5         SWITCH SCREEN STATUS                                         ³
³=CTRL_C          CHANGE CURRENT KEYBOARD UEUE                                 ³
Ã----------------------------------------------------------------------´
³ENTRY:           A2.L     start of keyboard queue linked list                 ³
³                 A6.L     start of system variables                           ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À----------------------------------------------------------------------Ù

2E4E CTRL_F5       NOT.B    SV.SCRST(A6)           ;invert screen status
                   RTS

   All the keybaord queues in the common heap are linked together in a
   linked list format.

2E54 CTRL_C        LEA      -SD.KBD(A2),A0         ;A0 points at start of channel definitio
                   TST.B    SD.CURF(A0)            ;cursor enabled ?
                   BGE.S    L02E66                 ;jump forward if enabled
                   JSR      SD_CURE(PC)            ;otherwise enable cursor

   Scan the list until the current one is found.

                   LEA      SD.KBD(A0),A2          ;A2 points at keyboard queue header
2E66 L02E66        MOVEA.L  (A2),A2                ;get address of next queue in list
2E68 L02E68        CMPA.L   SV.KEYQ(A6),A2         ;current queue ?
                   BEQ.S    L02E7C                 ;jump forward if so
                   TST.B    SD.CURF-SD.KBD(A2)
                   BEQ.S    L02E66                 ;try next queue if not enabled

   The current keyboard queue has been found and the address of the next
   queue in the list is in A2.

                   MOVE.L   A2,SV.KEYQ(A6)         ;use this as the new current queue
                   CLR.W    SV.FSTAT(A6)           ;reset cursor flash counter
2E7C L02E7C        JMP      IPC_SET(PC)            ;set up a new "empty" queue header

Ú----------------------------------------------------------------------¿
³=IPC_SET         SET UP IPC COMMAND                                           ³
Ã----------------------------------------------------------------------´
³ENTRY:           none                                                         ³
³                                                                              ³
³EXIT:            D6.L     bit number to test for completeion (6)              ³
³                 A0.L     pointer to IPC read only register, PC_IPCRD         ³
³                 A1.L     pointer to IPC write only register, PC_IPCWR        ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

2E80 IPC_SET       LEA      PC_IPCWR,A1            ;A1 points at IPC write only port
                   LEA      $1D(A1),A0             ;and A0 at the IPC read only port
                   MOVEQ    #6,D6
                   RTS

Ú----------------------------------------------------------------------¿
³=IPC_SEND        SEND COMMAND TO IPC                                          ³
Ã----------------------------------------------------------------------´
³ENTRY:           D0.B     command or parameter to be sent                     ³
³                 D6.L     bit number to test for completion                   ³
³                 A0.L     pointer to IPC read only register                   ³
³                 A1.L     pointer to IPC write only register                  ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

2E8E IPC_SEND      LSL.B    #4,D0
                   ORI.B    #8,D0
2E94 L02E94        LSL.B    #1,D0
                   BEQ.S    L02EA6
                   MOVEQ    #3,D1
                   ROXL.B   #1,D1
                   ASL.B    #1,D1
                   MOVE.B   D1,(A1)
2EA0 L02EA0        BTST     D6,(A0)
                   BNE.S    L02EA0
                   BRA.S    L02E94

2EA6 L02EA6        RTS

Ú----------------------------------------------------------------------¿
³=IPC_RETN        GET IPC RETURN PARAMETER NIBBLE                              ³
³=IPC_RETB        GET IPC RETURN PARAMETER BYTE                                ³
Ã----------------------------------------------------------------------´
³ENTRY:           D6.B     bit number to test for completion                   ³
³                 A0.L     pointer to IPC read only register                   ³
³                 A1.L     pointer to IPC write only register                  ³
³                                                                              ³
³EXIT:            D1.B     return parameter                                    ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

   Communications with the IPC are particularly slow and this routine is number
   exception as it transfers information one bit at a time until either the
   lower nibble or a full byte's worth has been collected.

2EA8 IPC_RETN      MOVEQ    #%00010000,D1          ;signal "get four bits from the IPC"
                   BRA.S    L02EAE                 ;get the bits

2EAC IPC_RETB      MOVEQ    #%00000001,D1          ;signal "get eight bits from the IPC"
2EAE L02EAE        MOVE.B   #%00001110,(A1)        ;signal "expect a return parameter"
2EB2 L02EB2        BTST     D6,(A0)                ;is it ok to fetch it ?
                   BNE.S    L02EB2                 ;wait until it is ok if not
                   MOVE.B   (A0),D0                ;then get a parameter bit
                   ROXL.B   #1,D0                  ;and move it into the return parameter
                   ROXL.B   #1,D1                  ;check number of bits received so far
                   BCC.S    L02EAE                 ;carry flag set if amount correct
                   RTS

2.11 General memory management utilities.

Ú----------------------------------------------------------------------¿
³=MM_ALCHP        ALLOCATE COMMMON HEAP               (VECTOR $C0)             ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     number of bytes required                            ³
³                 A6.L     system variables                                    ³
³                                                                              ³
³EXIT:            D1.L     number of bytes allocated                           ³
³                 A0.L     start of area allocated                             ³
³                 D2,D3,A1,A2 and A3 corrupted                                 ³
³                                                                              ³
³ERRORS:          ERR.OM   out of memory                                       ³
À----------------------------------------------------------------------Ù

2EC0 MM_ALCHP      LEA      SV.CHPFR(A6),A0
                   MOVEQ    #15,D2
                   JSR      L03018(PC)
                   BLT.S    L02EE8
                   LEA      4(A6),A2
                   CMPA.L   A1,A2
                   BEQ.S    L02ED8
                   CLR.L    8(A1)
2ED8 L02ED8        MOVE.L   D1,D0
                   ADDQ.W   #4,A0
                   SUBQ.L   #4,D0
2EDE L02EDE        CLR.L    (A0)+
                   SUBQ.L   #4,D0
                   BGT.S    L02EDE
                   SUBA.L   D1,A0
                   BRA.S    L02F0A

2EE8 L02EE8        MOVE.L   D1,-(A7)
2EEA L02EEA        ADDA.L   (A0),A1
                   CMPA.L   SV.FREE(A6),A1
                   BNE.S    L02EF4
                   SUB.L    (A0),D1
2EF4 L02EF4        JSR      L03160(PC)
                   BNE.S    L02F08
                   SUBA.L   D1,A0
                   LEA      SV.CHPFR(A6),A1
                   JSR      L03070(PC)
                   MOVE.L   (A7)+,D1
                   BRA.S    MM_ALCHP

2F08 L02F08        ADDQ.W   #4,A7
2F0A L02F0A        RTS

Ú----------------------------------------------------------------------¿
³=MM_ALTPA        EXPAND TRANSIENT PROGRAM AREA                                ³
Ã----------------------------------------------------------------------´
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À----------------------------------------------------------------------Ù

2F0C MM_ALTPA      LEA      SV.TRNFR(A6),A0
2F10 L02F10        MOVEQ    #15,D2
                   MOVEQ    #1,D0
                   JSR      MM_SRCH(PC)
                   TST.L    D2
                   BGT.S    L02F44
                   MOVE.L   D1,-(A7)
                   LEA      SV.TRNSP(A6),A1
                   ADDA.L   4(A1),A1
                   CMPA.L   SV.TRNSP(A6),A1
                   BNE.S    L02F2E
                   SUB.L    (A1),D1
2F2E L02F2E        JSR      MM_ALBAS(PC)
                   BNE.S    L02F6C
                   SUB.L    D1,SV.TRNSP(A6)
                   LEA      SV.TRNFR(A6),A1
                   JSR      L03070(PC)
                   MOVE.L   (A7)+,D1
                   BRA.S    MM_ALTPA

2F44 L02F44        MOVEA.L  A2,A0
2F46 L02F46        ADDA.L   4(A2),A0
                   MOVE.L   (A0),D3
                   CMP.L    D1,D3
                   BGT.S    L02F60
                   MOVE.L   4(A0),D3
                   BEQ.S    L02F5A
                   ADD.L    A0,D3
                   SUB.L    A2,D3
2F5A L02F5A        MOVE.L   D3,4(A2)
                   BRA.S    L02F68

2F60 L02F60        SUB.L    D1,D3
2F62 L02F62        MOVE.L   D3,(A0)
                   ADDA.L   D3,A0
                   MOVE.L   D1,(A0)
2F68 L02F68        MOVEQ    #0,D0                  ;signal "no errors"
                   RTS

2F6C L02F6C        ADDQ.W   #4,A7
2F6E L02F6E        RTS

Ú----------------------------------------------------------------------¿
³=MM_RECHP        RELEASE COMMON HEAP SPACE           (VECTOR $C2)             ³
Ã----------------------------------------------------------------------´
³ENTRY:           A0.L     start of area to release                            ³
³                 A6.L     system variables                                    ³
³                                                                              ³
³EXIT:            D1,D2,D3,A0,A1,A2 and A3 corrupted                           ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

2F70 MM_RECHP      MOVE.L   (A0),D1
                   LEA      SV.CHPFR(A6),A1
                   JSR      L03070(PC)
                   MOVE.L   (A1),D2
                   ADDA.L   D2,A1
                   CMPA.L   SV.FREE(A6),A1
                   BNE.S    L02F9A
                   MOVE.L   D2,D1
                   JSR      L03194(PC)
                   SUB.L    D1,D2
                   BEQ.S    L02F96
                   ADDA.L   4(A2),A2
                   MOVE.L   D2,(A2)
                   BRA.S    L02F9A

2F96 L02F96        CLR.L    4(A2)
2F9A L02F9A        MOVEQ    #0,D0                  ;signal "no errors"
2F9C L02F9C        RTS

Ú----------------------------------------------------------------------¿
³=MM_RETPA        RELEASE TRANSIENT PROGRAM AREA                               ³
Ã----------------------------------------------------------------------´
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À----------------------------------------------------------------------Ù

2F9E MM_RETPA      MOVE.L   (A0),D1
                   LEA      SV.TRNFR(A6),A1
                   JSR      L03070(PC)
                   LEA      SV.TRNSP(A6),A2
                   ADDA.L   4(A2),A2
                   CMPA.L   SV.TRNSP(A6),A2
                   BNE.S    L02FF0
                   MOVE.L   4(A2),-(A7)
                   MOVE.L   (A2),D2
                   MOVE.L   D2,D1
                   JSR      MM_REBAS(PC)
                   ADD.L    D1,SV.TRNSP(A6)
                   SUB.L    D1,D2
                   BEQ.S    L02FE4
                   MOVEA.L  (A7)+,A1
                   ADDA.L   D1,A2
                   ADD.L    D1,SV.TRNFR(A6)
                   MOVE.L   D2,(A2)
                   CLR.L    8(A2)
                   MOVE.L   A1,4(A2)
                   BEQ.S    L02FF0
                   SUB.L    D1,4(A2)
                   BRA.S    L02FF0

2FE4 L02FE4        MOVE.L   (A7)+,D2
2FE6 L02FE6        BEQ.S    L02FEC
                   ADD.L    SV.TRNFR(A6),D2
2FEC L02FEC        MOVE.L   D2,SV.TRNFR(A6)
2FF0 L02FF0        RTS

Ú----------------------------------------------------------------------¿
³=MT_FREE         FIND AMOUNT OF FREE SPACE  (TRAP #1 WITH D0 = $06)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           none                                                         ³
³                                                                              ³
³EXIT:            D1.L     maximum free space                                  ³
³                 D2,D3,A0,A1,A2 and A3 corrupted                              ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

   This TRAP finds the maximum free space that could be allocated to a
   job. This will only occur if the free space in the transient program
   area (released by a previous job or jobs) is very much larger than the
   available free space in the slave block area or vice-versa. Otherwise
   the TRAP will only give half the amount which could be allocated.

2FF2 MT_FREE       MOVEQ    #1,D0                  ;signal "find maximum"
                   MOVEQ    #0,D1                  ;amount to find
                   LEA      SV.TRNFR(A6),A0        ;A0 points at start of TRNSP free space
                   JSR      MM_SRCH(PC)            ;find the largest free space in list

   The largest free space in the transient program area has been found so
   compare this with the current size of the slave block area. If it's not
   as large then the latter will be used if allocation is requested.

                   MOVEA.L  SV.BASIC(A6),A0        ;A0 points at end of the system free spa
                   SUBA.W   #512,A0                ;allow for one slave block at least
                   SUBA.L   SV.FREE(A6),A0         ;and subtract the start of free space
                   MOVE.L   A0,D1                  ;copy result for comparison
                   CMP.L    D1,D2                  ;greater than free space in TRNSP ?
                   BLE.S    L03012                 ;exit if so
                   MOVE.L   D2,D1                  ;otherwise use the latter value
3012 L03012        BRA      CLEANUP                ;to give maximum amount to job

Ú----------------------------------------------------------------------¿
³=MM_ALLOC        ALLOCATE HEAP SPACE                 (VECTOR $D8)             ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     length of space required                            ³
³                 A0.L     pointer to pointer to free space                    ³
³                                                                              ³
³EXIT:            D1.L     amount of space allocated                           ³
³                 A0.L     start of area allocated (relative to A6)            ³
³                 D2,D3,A1,A2 and A3 corrupted                                 ³
³                                                                              ³
³ERRORS:          ERR.OM   number free space large enough                      ³
À----------------------------------------------------------------------Ù

3016 MM_ALLOC      MOVEQ    #7,D2                  ;use an increment size of 8 bytes
3018 L03018        MOVEQ    #0,D0                  ;and search to end of list
                   JSR      MM_SRCH(PC)            ;search through the linked list
                   CMP.L    D1,D2                  ;end of list reached ?
                   BEQ.S    L03034                 ;jump forward if so or amount ok
                   BGT.S    L03028
                   MOVEQ    #ERR.OM,D0             ;signal "out of memory"
                   RTS

   The required amount has been found so set up the pointers.

3028 L03028        ADD.L    D1,4(A1)               ;form relative pointer to next block
302C L0302C        MOVEA.L  A0,A1                  ;A1 points at start of space allocated
                   ADDA.L   D1,A1
                   SUB.L    D1,D3
                   MOVE.L   D3,(A1)
3034 L03034        MOVE.L   4(A0),D2
                   BEQ.S    L0303E
                   ADD.L    A0,D2
                   SUB.L    A1,D2
303E L0303E        MOVE.L   D2,4(A1)
                   MOVE.L   D1,(A0)
                   RTS

Ú----------------------------------------------------------------------¿
³=MM_SRCH         SEARCH THROUGH A FREE SPACE LINKED LIST                      ³
Ã----------------------------------------------------------------------´
³ENTRY:           D0.B     search flag (0 = goto end of list)                  ³
³                 D1.L     length of space required                            ³
³                 D2.B     mask for block size increment                       ³
³                 A0.L     pointer to pointer to start of list                 ³
³                                                                              ³
³EXIT:            D1.L     amount of space allocated                           ³
³                 A0.L     start of area allocated (relative to A6)            ³
³                 D2,D3,A1,A2 and A3 corrupted                                 ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

3046 MM_SRCH       SUBQ.W   #4,A0                  ;A0 points at supposed length word at st
3048 L03048        ADD.L    D2,D1                  ;find nearest multiple of increment
                   NOT.B    D2
                   AND.B    D2,D1
                   MOVEQ    #0,D2                  ;initialise count and amount to find
                   MOVEA.L  D2,A2

   Search through the linked list of free space blocks until the required
   amount is found or until the end if the list is reached.

3052 L03052        MOVEA.L  A0,A1                  ;copy pointer to free space block
                   MOVE.L   4(A0),D3               ;get relative pointer to next block
                   BEQ.S    L0306E                 ;and exit if end of list (zero if so)
                   ADDA.L   D3,A0                  ;A0 points at next free space block
                   MOVE.L   (A0),D3                ;get length of next block
                   CMP.L    D1,D3                  ;amount ok ?
                   BLT.S    L03052                 ;try next block if not
                   MOVEA.L  A1,A2                  ;otherwise set A2 to this block
                   CMP.L    D2,D3                  ;block increment ok ?
                   BLE.S    L0306A                 ;jump forward if so otherwise use
                   MOVE.L   D3,D2                  ;length of next block as increment
306A L0306A        TST.B    D0                     ;stop here or find maximum ?
                   BNE.S    L03052                 ;continue to end of list if maximum
306E L0306E        RTS

Ú----------------------------------------------------------------------¿
³=MM_LNKFR        LINK FREE SPACE INTO HEAP           (VECTOR $DA)             ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     length to link in                                   ³
³                 A0.L     base of new space (relative to A6)                  ³
³                 A1.L     pointer to pointer to free space (relative)         ³
³                                                                              ³
³EXIT:            D1,D2,D3,A0,A1,A2 and A3 corrupted                           ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

3070 L03070        CLR.L    8(A0)
3074 MM_LNKFR      SUBQ.W   #4,A1
                   SUBA.L   A2,A2
3078 L03078        MOVEA.L  A2,A3
                   MOVEA.L  A1,A2
                   MOVE.L   4(A1),D2
                   BEQ.S    L0308C
                   ADDA.L   D2,A1
                   CMPA.L   A0,A1
                   BLE.S    L03078
                   SUBA.L   A0,A1
                   BRA.S    L0308E

308C L0308C        MOVEA.L  D2,A1
308E L0308E        MOVE.L   A0,D2
3090 L03090        SUB.L    A2,D2
                   MOVE.L   D2,4(A2)
                   MOVE.L   D1,(A0)+
                   MOVE.L   A1,(A0)
309A L0309A        MOVEA.L  A2,A1
                   MOVEA.L  A3,A2
309E L0309E        MOVE.L   4(A1),D2
                   BEQ.S    L030C8
                   MOVEA.L  A2,A3
                   MOVEA.L  A1,A2
                   ADDA.L   D2,A1
                   MOVE.L   A3,D2
                   BEQ.S    L0309E
                   MOVE.L   (A2),D2
                   ADD.L    A2,D2
                   CMP.L    A1,D2
                   BNE.S    L0309E
                   MOVE.L   4(A1),D2
                   BEQ.S    L030BE
                   ADD.L    (A2),D2
30BE L030BE        MOVE.L   D2,4(A2)
                   MOVE.L   (A1),D2
                   ADD.L    D2,(A2)
                   BRA.S    L0309A

30C8 L030C8        RTS

Ú----------------------------------------------------------------------¿
³=MM_ALBAS        ALLOCATE BASIC AREA                                          ³
Ã----------------------------------------------------------------------´
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À----------------------------------------------------------------------Ù

30CA MM_ALBAS      JSR      L0314C(PC)
30CE L030CE        BNE.S    L030F0
                   BSR.S    L030F2
30D2 L030D2        MOVE.L   (A1)+,(A0)+
                   SUBQ.L   #4,D0
                   BNE.S    L030D2
                   BRA.S    L030F0

Ú----------------------------------------------------------------------¿
³=MM_REBAS        RELEASE BASIC AREA                                           ³
Ã----------------------------------------------------------------------´
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À----------------------------------------------------------------------Ù

30DA MM_REBAS      JSR      L03188(PC)
30DE L030DE        NEG.L    D1
                   BEQ.S    L030F0
                   BSR.S    L030F2
                   NEG.L    D1
                   ADDA.L   D0,A0
                   ADDA.L   D0,A1
30EA L030EA        MOVE.L   -(A1),-(A0)
                   SUBQ.L   #4,D0
                   BNE.S    L030EA
30F0 L030F0        RTS

30F2 L030F2        MOVEA.L  SV.JBBAS(A6),A3
30F6 L030F6        MOVE.L   A0,(A3)
                   ADDA.L   D1,A0
                   SUB.L    D1,$58(A0)
                   SUB.L    D1,$5C(A0)
                   MOVEA.L  A0,A1
                   SUBA.L   D1,A0
                   MOVE.L   SV.TRNSP(A6),D0
                   SUB.L    A1,D0
                   CMPA.L   SV.JBPNT(A6),A3
                   BNE.S    L0311C
                   SUB.L    D1,8(A5)
                   MOVE.L   USP,A3
                   SUBA.L   D1,A3
                   MOVE.L   A3,USP
311C L0311C        RTS

311E L0311E        ADDI.L   #$1FF,D1
3124 L03124        ANDI.W   #$FE00,D1
3128 L03128        RTS

312A L0312A        MOVEA.L  SV.BASIC(A6),A0
312E L0312E        MOVEQ    #-8,D3
                   BRA.S    L03138

3132 L03132        MOVEA.L  SV.FREE(A6),A0
3136 L03136        MOVEQ    #8,D3
3138 L03138        MOVE.L   A0,D0
                   SUB.L    A6,D0
                   LSR.L    #6,D0
                   MOVEA.L  SV.BTBAS(A6),A1
                   ADDA.W   D0,A1
                   MOVE.L   D1,D0
                   LSR.L    #6,D0
                   LSR.L    #3,D0
                   RTS

314C L0314C        BSR.S    L0311E
314E L0314E        BSR.S    L0312A
                   SUBA.L   D1,A0
                   CMPA.L   SV.FREE(A6),A0
                   BLE.S    L031B0
                   MOVE.L   A0,SV.BASIC(A6)
                   ADDA.L   D3,A1
                   BRA.S    L03182

3160 L03160        BSR.S    L0311E
3162 L03162        BSR.S    L03132
                   ADDA.L   D1,A0
                   CMPA.L   SV.BASIC(A6),A0
                   BGE.S    L031B0
                   MOVE.L   A0,SV.FREE(A6)
                   BRA.S    L03182

3172 L03172        MOVEQ    #12,D2
3174 L03174        AND.B    (A1),D2
                   BEQ.S    L0317E
                   JSR      L03434(PC)
                   BRA.S    L03172

317E L0317E        CLR.B    (A1)
3180 L03180        ADDA.W   D3,A1
3182 L03182        DBF      D0,L03172
                   BRA.S    L031AC

3188 L03188        BSR.S    L03124
318A L0318A        BSR.S    L0312A
                   ADDA.L   D1,A0
                   MOVE.L   A0,SV.BASIC(A6)
                   BRA.S    L031A8

3194 L03194        BSR.S    L03124
3196 L03196        BSR.S    L03132
                   SUBA.L   D1,A0
                   MOVE.L   A0,SV.FREE(A6)
                   SUBA.W   D3,A1
                   BRA.S    L031A8

31A2 L031A2        MOVE.B   #1,(A1)
31A6 L031A6        SUBA.W   D3,A1
31A8 L031A8        DBF      D0,L031A2
31AC L031AC        MOVEQ    #0,D0
                   BRA.S    L031B2

31B0 L031B0        MOVEQ    #ERR.OM,D0             ;signal "out of memory"
31B2 L031B2        RTS

2.12 I/O sub-system TRAP #2 handler.

Ú----------------------------------------------------------------------¿
³=CHKTRP2         HANDLE TRAP #2 FUNCTIONS                                     ³
Ã----------------------------------------------------------------------´
³ENTRY:           D0.B     function number                                     ³
³                 D3.W     timeout                                             ³
³                 A0.L     channel ID or address of device name                ³
³                 A5.L     pointer to saved SuperBASIC registers               ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:          ERR.BP   invalid function                                    ³
À----------------------------------------------------------------------Ù

   TRAP handler alters registers so that A5 and A7 point at saved SuperBASIC
   registers, A6 points at system variables and D7 = D0.
   The registers are saved in the order:-

   1.     Long word for program counter       $0E(A5)
   2.     Word for status register            $0C(A5)
   3.     Long word for A6                    $08(A5)
   4.     Long word for A5                    $04(A5)
   5.     Long word for D7                    $00(A5)

   All the TRAP #2 calls deal with the  allocation of resources to channels
   , formatting directory device media and deleting files.

31B4 CHKTRP2       MOVEA.L  SV.JBPNT(A6),A1        ;A1 points at current job table entry an
                   MOVEA.L  (A1),A1                ;at the job header
                   BCLR     #7,JB.RELA6(A1)        ;absolute addresses to be used ?
                   BEQ.S    ABS_ADDR               ;jump forward if so otherwise
                   ADDA.L   8(A5),A0               ;make A0 absolute using saved A6
31C6 ABS_ADDR      SUBQ.B   #1,D0                  ;is it an IO.OPEN call ?
                   BEQ.S    IO_OPEN                ;jump forward to routine if so
                   SUBQ.B   #1,D0                  ;is it an IO.CLOSE call ?
                   BEQ      IO_CLOSE               ;jump forward to routine if so
                   SUBQ.W   #1,D0                  ;is it an IO.FORMT call ?
                   BEQ      IO_FORMT               ;jump forward to routine if so
                   SUBQ.W   #1,D0                  ;is it an IO.DELET call ?
                   BEQ      IO_DELET               ;jump forward if so otherwise
                   MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
                   BRA      CHKSBIT

Ú----------------------------------------------------------------------¿
³=IO_OPEN         OPEN A CHANNEL             (TRAP #2 WITH D0 = $01)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     job ID (-1 if current job)                          ³
³                 D3.W     open type (0 to 4)                                  ³
³                 A0.L     address of channel name string                      ³
³                 A5.L     pointer to saved super basic registers              ³
³                                                                              ³
³EXIT:            D1.L     job ID                                              ³
³                 A0.L     new channel ID                                      ³
³                 D2,D3,A1,A2 and A3 preserved                                 ³
³                                                                              ³
³ERRORS:          ERR.NJ   invalid job ID                                      ³
³                 ERR.OM   out of memory                                       ³
³                 ERR.NO   too many channels                                   ³
³                 ERR.NF   file or device not found                            ³
³                 ERR.EX   file already exists                                 ³
³                 ERR.IU   file or device in use                               ³
³                 ERR.BN   bad device name                                     ³
À----------------------------------------------------------------------Ù

   The value of D3 on entry determines the type of channel open for other
   than pipes as follows:-

   1.     0 = old exclusive device
   2.     1 = old shared device
   3.     2 = new exclusive device
   4.     3 = new overwrite file
   5.     4 = open directory

   For pipes, the value of D3 gives the output pipe ID for an input pipe.

   In practice types 0 to 3 are the same for simple device drivers and in
   fact type 2 is not supported for any device. Type 4 is only relevant for
   a directory device driver.

31E2 IO_OPEN       MOVEM.L  A1-4,-(A7)             ;save registers used to set up channel
                   MOVEA.L  A0,A1                  ;save address of device name
                   JSR      CHKJBID(PC)            ;check job ID,A0 points at header on exi
                   EXG      A0,A1                  ;swap address of name with channel

   Find the first free entry in the channel table.

                   MOVEA.L  SV.CHBAS(A6),A3        ;A3 points at start of channel table
31F2 SCAN_CT       TST.B    (A3)                   ;entry free ?
                   BLT.S    SCAN_DD                ;jump forward if so
                   ADDQ.W   #4,A3                  ;A3 points at next entry
                   CMPA.L   SV.CHTOP(A6),A3        ;end of channel table reached ?
                   BLT.S    SCAN_CT                ;check next entry if not otherwise
                   MOVEQ    #ERR.NO,D0             ;signal "channel not found" as the
                   BRA.S    END_OPEN               ;channel table is full

   Call all the device drivers in turn until no errors are returned.

3202 SCAN_DD       MOVEA.L  SV.DRLST(A6),A2        ;A2 points at simple device driver list
3206 NEXT_DD       MOVEM.L  D1-7/A1-6,-(A7)        ;save registers
                   LEA      -$18(A2),A3            ;A3 points at assumed start of linkage b
                   MOVEA.L  DEV.OPEN(A2),A4        ;get address of open routine
                   JSR      (A4)                   ;call it
                   MOVEM.L  (A7)+,D1-7/A1-6        ;restore the registers
                   TST.L    D0                     ;correct device driver found ?
                   BEQ.S    SET_CHAN               ;set up channel definition block if so
                   CMPI.W   #ERR.NF,D0             ;"device not found" error ?
                   BNE.S    END_OPEN               ;jump forward if not
                   MOVEA.L  (A2),A2                ;get link to next device driver
                   MOVE.L   A2,D0                  ;end of linked list ?
                   BGT.S    NEXT_DD                ;call next driver if not

   The device name did not match any of the simple device drivers so try
   the directory device driver linked list instead.

                   JSR      L03464(PC)
                   TST.L    D0                     ;any errors ?
                   BNE.S    END_OPEN               ;exit if so

   The correct device driver has been found so prepare the channel table.

3230 SET_CHAN      MOVE.L   A0,(A3)                ;set up entry in channel table
                   MOVE.W   SV.CHTAG(A6),D2        ;get current channel tag and set up
                   ADDQ.W   #1,SV.CHTAG(A6)        ;new one for next time
                   ADDQ.W   #4,A0                  ;A0 points at CH.DRIVR

   Set up the channel definition block.

                   MOVE.L   A2,(A0)+               ;pointer to driver linkage block
                   MOVE.L   D1,(A0)+               ;ID of owner job
                   MOVE.L   A3,(A0)+               ;location to be set when channel closed
                   MOVE.W   D2,(A0)+               ;channel tag
                   CLR.W    (A0)+                  ;signal "status ok,no action"
                   CLR.L    (A0)+                  ;ID of job waiting for I/O
                   SWAP     D2
                   SUBA.L   SV.CHBAS(A6),A3        ;A3 = offset into channel table
                   MOVE.W   A3,D2
                   LSR.W    #2,D2                  ;form channel ID from offset
                   MOVEA.L  D2,A0
                   CMP.W    SV.CHMAX(A6),D2        ;greater than maximum to date ?
                   BLS.S    END_OPEN               ;jump forward if not
                   MOVE.W   D2,SV.CHMAX(A6)        ;otherwise update the maximum
325E END_OPEN      MOVEM.L  (A7)+,A1-4
                   BRA.S    END_CLOS

Ú----------------------------------------------------------------------¿
³=IO_CLOSE        CLOSE A CHANNEL            (TRAP #2 WITH D0 = $02)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           A0.L     channel ID                                          ³
³                                                                              ³
³EXIT:            A0       corrupted                                           ³
³                 D1,D2,D3,A1,A2 and A3 preserved                              ³
³                                                                              ³
³ERRORS:          ERR.NC   channel not open                                    ³
À----------------------------------------------------------------------Ù

   When a channel is closed, an attempt is made to release all the space
   which was associated with that channel normally in the common heap.
   The actual routine in the device driver is used to free the channel and
   all this routine does is find the correct channel to close.

3264 IO_CLOSE      MOVE.L   A0,D7                  ;save channel ID for later
                   JSR      CHKCHID(PC)            ;check channel ID,A0 points at block on
                   MOVEM.L  D1-7/A1-6,-(A7)        ;save registers
                   MOVEA.L  CH.DRIVR(A0),A4        ;A4 points at link to next device driver
                   LEA      -$18(A4),A3            ;A3 points at assummed start of linkage
                   MOVEA.L  DEV.CLOS(A4),A4        ;get the close channel routine address
                   JSR      (A4)                   ;and call it
                   MOVEM.L  (A7)+,D1-7/A1-6        ;restore the registers
                   LSL.W    #2,D7                  ;form long word offset from channel ID
                   MOVEA.L  SV.CHBAS(A6),A0        ;A0 points at start of the channel table
                   ADDA.W   D7,A0                  ;then at required entry in table
                   ST       (A0)                   ;set entry to "unused"
328A END_CLOS      BRA      CHKSBIT

2.13 I/O sub-system TRAP #3 handler.

Ú----------------------------------------------------------------------¿
³=CHKTRP3         HANDLE TRAP #3 FUNCTIONS (START OF I/O SUB SYSTEM)           ³
Ã----------------------------------------------------------------------´
³ENTRY:           D0.B     function number                                     ³
³                 D3.W     timeout                                             ³
³                 A0.L     channel ID                                          ³
³                                                                              ³
³EXIT:            D2,D3,A0,A1,A2 and A3 preserved                              ³
³                                                                              ³
³ERRORS:          ERR.NC   not complete                                        ³
À----------------------------------------------------------------------Ù

   TRAP handler alters registers so that A5 and A7 point at saved SuperBASIC
   registers,A6 points at system variables and D7 = D0.
   The registers are saved in the order:-

   1.     Long word for program counter       $0E(A5)
   2.     Word for status register            $0C(A5)
   3.     Long word for A6                    $08(A5)
   4.     Long word for A5                    $04(A5)
   5.     Long word for D7                    $00(A5)

   All the TRAP #3 calls are concerned with aspects of actual device I/O
   graphics and file handling.

328E CHKTRP3       MOVE.L   A0,D7                  ;move channel ID to D7
                   JSR      CHKCHID(PC)            ;check channel ID,A0 points at header on

   A0 now points at the channel definition block.

                   TAS      CH.STAT(A0)            ;signal and test "job waiting for I/O"
                   BNE      L03326                 ;jump if job waiting already
                   MOVEM.L  D2-7/A2-6,-(A7)
                   CLR.L    -(A7)                  ;signal "use relative values"
                   ANDI.L   #$7F,D0                ;reduce to range 0 - 127
                   CMPI.B   #FS.SAVE,D0            ;is it a standard function ?
                   BGT.S    BYTE_IO                ;jump forward if not
                   CMPI.B   #FS.HEADS,D0           ;is it a file header command ?
                   BGE.S    IOSTRING               ;jump forward if so
                   CMPI.B   #IO.SSTRG,D0           ;is it a simple I/O TRAP ?
                   BGT.S    BYTE_IO                ;jump forward if not
                   BTST     #1,D0                  ;fetch line or byte ?
                   BEQ.S    BYTE_IO                ;jump forward if byte

   If a string of bytes is required, the cursor position (D1) is zeroed
   first.

32C0 IOSTRING      MOVEQ    #0,D1                  ;signal "string of bytes required"
32C2 BYTE_IO       MOVEA.L  SV.JBPNT(A6),A3        ;A3 points at current job table entry
                   MOVEA.L  (A3),A3                ;and then at job header
                   BCLR     #7,JB.RELA6(A3)        ;test and signal "not TRAP #4"
                   BEQ.S    A1_ABS                 ;jump forward if already absolute
                   MOVE.L   8(A5),(A7)             ;copy saved A6 to top of stack
                   ADDA.L   (A7),A1                ;make A1 absolute
32D6 A1_ABS        MOVEA.L  CH.DRIVR(A0),A4        ;A4 points at device driver
                   MOVE.B   D0,CH.ACTN(A0)         ;set to function number
                   MOVEQ    #0,D3                  ;set timeout to zero
                   LEA      -$18(A4),A3            ;A3 points at assumed start of linkage b
                   MOVEA.L  DEV.IO(A4),A4          ;and A4 at I/O routine

   On entry to the I/O routine the following conditions prevail:-

   1.     D2,A2 and D4 to D7 passed as on entry to TRAP handler.

   2.     D0.B = Action required.
   3.     D1.0 as on entry to TRAP unless string of bytes required where
          it is set to 0.
   4.     D3.L = 0 (do TRAP in one frame).
   5.     A0.L points at channel definition block.
   6.     A1.L = absolute value.
   7.     A3.L points at assumed start of linkage block.
   8.     A5.L points at saved SuperBASIC registers (see entry conditions above)
   9.     A6.L points at QDOS system variables.

                   JSR      (A4)                   ;call the routine
                   SUBA.L   (A7),A1                ;make A1 relative again
                   CMPI.W   #ERR.NC,D0             ;any errors ?
                   BNE.S    L03334                 ;jump if other than "not complete"
                   MOVE.W   10(A7),D3              ;timout expired ?
                   BEQ.S    L03334                 ;exit if so
                   MOVEA.L  $2C(A7),A6             ;restore saved A6 (in TRAP handler)
                   JSR      GETJBID(PC)            ;get ID of current job
                   MOVE.L   D0,CH.JOBWT(A0)        ;current job is waiting
                   LEA      CH.STAT(A0),A0         ;A0 points at this variable
                   TST.L    (A7)+                  ;absolute or relative values ?
                   BNE.S    L0330E                 ;jump if absolute
                   ST       (A0)                   ;signal "A1 passed absolute"
330E L0330E        MOVE.L   A0,JB.HOLD(A3)         ;set to address of {ch.stat}
                   MOVE.W   D3,JB.STAT(A3)         ;set to timeout given on entry
                   SF       JB.PRIOR(A3)           ;zero job priority
                   MOVEQ    #ERR.NC,D0             ;signal "not complete"
                   MOVEM.L  (A7)+,D2-7/A2-6        ;restore registers
3320 L03320        MOVEA.L  D7,A0                  ;and channel ID
                   BRA      SCHEDULER              ;then enter scheduler

3326 L03326        TST.W    D3                     ;check timeout
                   BEQ.S    L03330                 ;enter scheduler if zero
                   SUBQ.L   #2,$0E(A7)             ;otherwise reduce timeout suitably
                   BRA.S    L03320                 ;reset ID then enter scheduler

3330 L03330        MOVEQ    #ERR.NC,D0             ;signal "not complete"
                   BRA.S    L0333E

3334 L03334        ADDQ.W   #4,A7                  ;ignore top of stack
                   MOVEM.L  (A7)+,D2-7/A2-6        ;restore registers
                   SF       CH.STAT(A0)            ;clear status to "ok"
333E L0333E        MOVEA.L  D7,A0                  ;reset channel ID
                   BRA      CHKSBIT

Ú----------------------------------------------------------------------¿
³=CHKTRP4         CONVERT TO ABSOLUTE VALUES                                   ³
Ã----------------------------------------------------------------------´
³ENTRY:           none                                                         ³
³                                                                              ³
³EXIT:            none                                                         ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

   TRAP handler alters registers so that A6 now points at system variables.

3344 CHKTRP4       MOVE.L   A3,-(A7)               ;save address of job header
                   MOVEA.L  SV.JBPNT(A6),A3        ;A3 points at current job table entry
                   MOVEA.L  (A3),A3                ;and then at job header
                   TAS      JB.RELA6(A3)           ;test and signal "TRAP #4 issued"
                   MOVEA.L  (A7)+,A3               ;restore header address
                   BRA      CHKSBIT

Ú----------------------------------------------------------------------¿
³=CHKCHID         CHECK CHANNEL ID                                             ³
Ã----------------------------------------------------------------------´
³ENTRY:           A0.L     channel ID                                          ³
³                 A6.L     system variables                                    ³
³                                                                              ³
³EXIT:            A0.L     channel definition block                            ³
³                                                                              ³
³ERRORS:          ERR.NO   channel not open                                    ³
À----------------------------------------------------------------------Ù

3356 CHKCHID       MOVE.L   A0,-(A7)
                   MOVE.L   D0,-(A7)
                   MOVE.L   A0,D0                  ;copy ID
                   CMP.W    SV.CHMAX(A6),D0        ;> maximum to date ?
                   BHI.S    L0337E                 ;if yes then must be invalid
                   LSL.W    #2,D0                  ;form offset into channel table
                   MOVEA.L  SV.CHBAS(A6),A0        ;then add offset to base
                   ADDA.W   D0,A0
                   TST.B    (A0)                   ;entry free ?
                   BLT.S    L0337E                 ;error if not
                   MOVEA.L  (A0),A0                ;A0 points at channel definition block
                   SWAP     D0                     ;move channel tag into veiw
                   CMP.W    CH.TAG(A0),D0          ;tag ok ?
                   BNE.S    L0337E                 ;error if not
                   MOVE.L   (A7)+,D0               ;restore function number
                   ADDQ.W   #4,A7                  ;and ignore saved channel ID
                   RTS

337E L0337E        ADDQ.W   #4,A7                  ;ignore saved function number
                   MOVEQ    #ERR.NO,D0             ;signal "channel not open"
                   MOVEA.L  (A7)+,A0               ;restore channel ID
                   ADDQ.W   #4,A7                  ;ignore return address
                   BRA      CHKSBIT

Ú----------------------------------------------------------------------¿
³=DOWAITIO        DO WAITING I/O (END OF SCHEDULER LINKED LIST)                ³
Ã----------------------------------------------------------------------´
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À----------------------------------------------------------------------Ù

338A DOWAITIO      DC.L     0                      ;link to next entry (null)
                   DC.L     L03392                 ;pointer to routine

3392 L03392        MOVEA.L  SV.CHPNT(A6),A1
                   MOVEA.W  SV.CHMAX(A6),A2
                   ADDA.W   A2,A2
                   ADDA.W   A2,A2
                   ADDA.L   SV.CHBAS(A6),A2
                   MOVEA.L  A1,A3
33A4 L033A4        ADDQ.W   #4,A1
                   CMPA.L   A2,A1
                   BLE.S    L033AE
                   MOVEA.L  SV.CHBAS(A6),A1
33AE L033AE        TST.B    (A1)
                   BLT.S    L033BA
                   MOVEA.L  (A1),A0
                   MOVE.B   CH.STAT(A0),D4
                   BNE.S    L033C0
33BA L033BA        CMPA.L   A1,A3
                   BNE.S    L033A4
                   BRA.S    L0342C

33C0 L033C0        MOVE.L   A1,SV.CHPNT(A6)
                   MOVE.L   CH.JOBWT(A0),D1
                   LSL.W    #2,D1
                   MOVEA.L  SV.JBBAS(A6),A4
                   ADDA.W   D1,A4
                   TST.B    (A4)
                   BLT.S    L0342E
                   MOVEA.L  (A4),A4
                   SWAP     D1
                   CMP.W    JB.TAG(A4),D1
                   BLT.S    L0342E
                   MOVEQ    #0,D0
                   MOVE.B   CH.ACTN(A0),D0
                   MOVEQ    #-1,D3                 ;use an infinite timeout
                   MOVEM.L  JB.D1(A4),D1-2
                   MOVEM.L  JB.A1(A4),A1-2
                   MOVE.L   A4,-(A7)
                   CLR.L    -(A7)
                   ADDQ.B   #1,D4
                   BEQ.S    L03400
                   MOVE.L   JB.A6(A4),(A7)
                   ADDA.L   (A7),A1
3400 L03400        MOVEA.L  CH.DRIVR(A0),A4
                   LEA      -$18(A4),A3
                   MOVEA.L  DEV_IO(A4),A4
                   JSR      (A4)
                   SUBA.L   (A7)+,A1
                   MOVEA.L  (A7)+,A4
                   MOVE.L   D1,JB.D1(A4)
                   MOVE.L   A1,JB.A1(A4)
                   CMPI.B   #$FF,D0
                   BEQ.S    L0342C
                   MOVE.L   D0,JB.D0(A4)
                   CLR.B    CH.STAT(A0)
                   CLR.W    JB.STAT(A4)
342C L0342C        RTS

342E L0342E        CLR.B    CH.STAT(A0)
                   RTS

Ú----------------------------------------------------------------------¿
³=                                                                             ³
Ã----------------------------------------------------------------------´
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À----------------------------------------------------------------------Ù

3434 L03434        MOVEM.L  D0-3/A0-4,-(A7)
                   MOVEQ    #0,D1
                   MOVE.B   (A1),D1
                   LSR.B    #4,D1
                   LSL.B    #2,D1
                   LEA      $100(A6),A2
                   MOVEA.L  0(A2,D1.W),A2
                   MOVEA.L  $10(A2),A4
                   LEA      -$18(A4),A3
                   MOVEA.L  $10(A4),A4
                   JSR      (A4)
                   MOVEM.L  (A7)+,D0-3/A0-4
                   RTS

Ú----------------------------------------------------------------------¿
³=IO_DELET        DELETE A FILE                                                ³
³=IO_OPEN2        CHECK OPEN TYPE                                              ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     job ID (-1 for current job)                         ³
³                 A0.L     location of channel name                            ³
³                                                                              ³
³EXIT:            D1,D3,A0,A1 and A2 corrupted                                 ³
³                 D2 and A3  preserved                                         ³
³                                                                              ³
³ERRORS:          ERR.OM   out of memory                                       ³
³                 ERR.NO   file not deleted as channel table full              ³
³                 ERR.NF   file not found                                      ³
³                 ERR.BN   bad device name or not a directory device           ³
À----------------------------------------------------------------------Ù

   Removes the file from the specified device if it is a directory device.

345C IO_DELET      ST       D3                     ;signal "delete a file"
                   BSR.S    TYPE_OK
                   BRA      CHKSBIT

   This entry point is used by the IO.OPEN TRAP and checks the open type.

3464 IO_OPEN2      CMPI.B   #4,D3                  ;is it a valid open type ?
                   BLS.S    TYPE_OK                ;jump forward if so otherwise
                   MOVEQ    #ERR.BP,D0             ;signal "bad parameter" and exit
                   RTS

   The open type is ok so allocate memory for the channel defintion block.

346E TYPE_OK       MOVEM.L  D1-6/A3-6,-(A7)
                   MOVEA.L  A0,A5                  ;save address of channel name
                   MOVE.L   #$A0,D1                ;default size for a microdrive channel
                   JSR      MM_ALCHP(PC)           ;allocate the space,A0 points at area on
                   BNE      L03594                 ;and exit if out of memory

   All the channel definition blocks for the directory device drivers are
   connected together in a linked list for each drive.

                   ADDA.W   #FS.NEXT,A0            ;A0 points at link to next entry in list
                   LEA      SV.FSLST(A6),A1        ;A1 points at pointer to start of list
                   JSR      UT_LINK(PC)            ;link channel into list
                   LEA      (A5),A1                ;A1 points at channel name
                   JSR      CHK_DD(PC)             ;check the device name
                   BNE      L03578                 ;and exit if not found

   A2 now points at the start of the linkage block for this device driver and D1
   the drive number. Scan through all the physical definition blocks until
   the correct one has been found for this device.

                   MOVEQ    #15,D2                 ;16 pointers to physical definitions
                   MOVEQ    #-1,D0
                   LEA      SV.FSLST(A6),A4        ;A4 points at last pointer + 1
34A0 L034A0        MOVE.L   -(A4),D3               ;then D3 points at physical definition b
                   BNE.S    L034A8                 ;jump forward if there is a block
                   MOVE.W   D2,D0
                   BRA.S    L034B6

34A8 L034A8        MOVEA.L  D3,A1                  ;A1 points at start of list
                   CMP.B    FS.DRIVN(A1),D1        ;correct drive number ?
                   BNE.S    L034B6                 ;check next definition block if not
                   CMPA.L   FS.DRIVR(A1),A2        ;correct device driver ?
                   BEQ.S    L034E6                 ;jump forward if so otherwise check
34B6 L034B6        DBF      D2,L034A0              ;next physical definition block

   number physical definition block block exists so create one.

                   MOVE.W   D0,D2
                   BLT      L03576
                   MOVEM.L  D1-2/A0/A2,-(A7)
                   MOVE.L   DEV.PDLE(A2),D1        ;get length of physical definition
                   JSR      MM_ALCHP(PC)           ;find the space,A0 points at area on exi
                   MOVEM.L  (A7)+,D1-2/A1-2
                   EXG      A0,A1
                   BNE      L03578                 ;and exit if out of memory
                   MOVE.L   A2,FS.DRIVR(A1)        ;set the address of the device driver
                   MOVE.B   D1,FS.DRIVN(A1)        ;and of the drive number
                   MOVE.W   D2,D0                  ;then form the pointer number
                   LSL.W    #2,D0
                   ADDA.W   D0,A4
                   MOVE.L   A1,(A4)                ;and set pointer to new definition block

   The correct device driver has been found and a physical definition block
   exists.

34E6 L034E6        MOVE.B   D2,5(A0)
                   MOVE.B   11(A7),4(A0)
                   LEA      $1A(A0),A4
                   MOVE.W   (A5)+,D0
                   MOVE.W   $24(A2),D3
                   ADDQ.W   #2,D3
                   ADDA.W   D3,A5
                   SUB.W    D3,D0
                   BLT.S    L0356A
                   CMPI.W   #$24,D0
                   BGT.S    L0356A
                   MOVE.W   D0,(A4)+
                   BRA.S    L0350E

350C L0350C        MOVE.B   (A5)+,(A4)+
350E L0350E        DBF      D0,L0350C
                   MOVEA.L  A1,A5
                   MOVEA.L  A0,A1
3516 L03516        MOVEA.L  (A1),A1
                   MOVE.L   A1,D0
                   BEQ.S    L0355C
                   CMP.B    5(A1),D2
                   BNE.S    L03516
                   MOVEQ    #1,D0
                   MOVEA.W  #$1A,A6
                   JSR      UT_CSTR(PC)
                   MOVEA.L  $24(A7),A6
                   BNE.S    L03516
                   CMPI.B   #2,4(A0)
                   BEQ.S    L0356E
                   CMPI.B   #1,4(A0)
                   BNE.S    L03572
                   CMPI.B   #1,4(A1)
                   BNE.S    L03572
                   MOVE.W   6(A1),6(A0)
                   MOVE.L   12(A1),12(A0)
                   MOVE.W   #$40,10(A0)
355C L0355C        MOVEA.L  A5,A1
                   TST.W    6(A0)
                   BEQ.S    L0359A
                   SUBA.W   #$18,A0
                   BRA.S    L0358E

356A L0356A        MOVEQ    #-12,D0
                   BRA.S    L03578

356E L0356E        MOVEQ    #-8,D0
                   BRA.S    L03578

3572 L03572        MOVEQ    #-9,D0
                   BRA.S    L03578

3576 L03576        MOVEQ    #-6,D0
3578 L03578        LEA      $140(A6),A1
                   JSR      UT.UNLNK(PC)
                   SUBA.W   #$18,A0
                   MOVE.L   D0,D4
                   JSR      L02F70(PC)
                   MOVE.L   D4,D0
                   BRA.S    L03594

358E L0358E        ADDQ.B   #1,$22(A1)
                   MOVEQ    #0,D0
3594 L03594        MOVEM.L  (A7)+,D1-6/A3-6
                   RTS

359A L0359A        SUBA.W   #$18,A0
                   MOVE.L   A1,-(A7)
                   MOVE.L   A2,-(A7)
                   LEA      -$18(A2),A3
                   MOVEA.L  8(A2),A4
                   JSR      (A4)
                   MOVEA.L  (A7)+,A2
                   MOVEA.L  (A7)+,A1
                   TST.B    $1C(A0)
                   BLT.S    L035BA
                   TST.L    D0
                   BEQ.S    L0358E
35BA L035BA        ADDA.W   #$18,A0
                   BRA.S    L03578

Ú----------------------------------------------------------------------¿
³=IO_FORMT        FORMAT A MEDIUM                                              ³
Ã----------------------------------------------------------------------´
³ENTRY:           A0.L     pointer to medium name                              ³
³                                                                              ³
³EXIT:            D1.W     number of good sectors                              ³
³                 D2.W     total number of sectors on media                    ³
³                 A0       corrupted                                           ³
³                 D3,A1,A2 and A3 preserved                                    ³
³                                                                              ³
³ERRORS:          ERR.OM   out of memory                                       ³
³                 ERR.NF   device not found                                    ³
³                 ERR.IU   device in use                                       ³
³                 ERR.FF   format failed                                       ³
À----------------------------------------------------------------------Ù

   The actual formatting of the medium is done by the device driver and all
   this routine does is find the correct driver to use if any.
   TRAP handler alters registers so that A6 now points at QDOS system variables.

35C0 IO_FORMT      MOVEM.L  D3-7/A1-5,-(A7)        ;save the registers
                   MOVEA.L  A0,A1                  ;A1 points at medium name
                   JSR      CHK_DD(PC)             ;check the device name
                   BLT.S    L035D6                 ;and exit if device not found
                   LEA      -$18(A2),A3            ;A3 points at assumed start of linkage b
                   MOVEA.L  DEV.FORM(A2),A4        ;get the address of the format routine
                   JSR      (A4)                   ;and call it
35D6 L035D6        MOVEM.L  (A7)+,D3-7/A1-5        ;restore the registers
                   BRA      CHKSBIT

Ú----------------------------------------------------------------------¿
³=CHK_DD          CHECK DIRECTORY DEVICE DRIVERS LINKED LIST                   ³
Ã----------------------------------------------------------------------´
³ENTRY:           A1.L     pointer to medium name string                       ³
³                 A6.L     QDOS system variables                               ³
³                                                                              ³
³EXIT:            D1.B     Drive number from medium name in binary             ³
³                 A2.L     start of directory device linkage block             ³
³                                                                              ³
³ERRORS:          ERR.NF   device not found                                    ³
À----------------------------------------------------------------------Ù

   The medium name should be something along the lines of "MDV1_MEDIUMNAME"
   or maybe "FLP2_MEDIUMNAME" etc.

   Check through the directory device drivers linked list until the driver
   corresponding to the medium name has been found or the end of the list
   has been reached.

35DE CHK_DD        MOVEM.L  A1/A4,-(A7)
                   MOVEA.L  SV.DDLST(A6),A2        ;A2 points at directory device drivers l
35E6 NXT_DD        LEA      DEV.NAME(A2),A4        ;A4 points at device name string
                   MOVE.W   (A4)+,D0               ;get the device name length
                   MOVEA.L  (A7),A1                ;A1 points at medium name
                   ADDQ.W   #2,A1                  ;step over length word at start of name
35F0 CHK_NAME      MOVE.B   (A1)+,D1               ;get character of medium name proper
                   BCLR     #5,D1                  ;change to upper case
                   CMP.B    (A4)+,D1               ;same as equivalent in device name ?
                   BNE.S    BAD_DEV                ;exit if not as wrong device type
                   SUBQ.W   #1,D0                  ;reduce character count
                   BGT.S    CHK_NAME               ;check next character until end of name
                   BRA.S    DD_OK                  ;match found so jump forward

   Device name does not match the medium name so try the next driver in the
   linked list.

3600 BAD_DEV       MOVEA.L  (A2),A2                ;A2 points at next entry in list
                   MOVE.L   A2,D0
                   BNE.S    NXT_DD                 ;check this driver unless end of list
                   BRA.S    IO_ERRNF               ;in which case we have failed

   The correct device driver has been found and A1 now points at the character a
   the device name characters which should be the drive number.

3608 DD_OK         MOVEQ    #0,D1                  ;prepare D1
                   MOVE.B   (A1)+,D1               ;get the drive number
                   SUBI.B   #"0",D1                ;and convert it to binary
                   BLE.S    IO_ERRNF               ;exit if it was too small
                   CMPI.B   #9,D1                  ;only 8 drives are allowed
                   BGE.S    IO_ERRNF               ;exit if drive number to large
                   CMPI.B   #"_",(A1)              ;followed by underscore character ?
                   BNE.S    IO_ERRNF               ;exit if not
                   MOVEQ    #0,D0                  ;signal "no errors"
                   BRA.S    EXIT_DD

3622 IO_ERRNF      MOVEQ    #ERR.NF,D0             ;signal "device not found"
3624 EXIT_DD       MOVEM.L  (A7)+,A1/A4
                   RTS

362A L0362A        MOVE.L   A2,D2
                   ADDQ.L   #1,D2
                   BCLR     #0,D2
                   MOVEA.L  D2,A2
                   RTS

Ú----------------------------------------------------------------------¿
³=IO_NAME         DECODE DEVICE NAME                  (VECTOR $122)            ³
Ã----------------------------------------------------------------------´
³ENTRY:           A0.L     start of name                                       ³
³                 A3.L     pointer to parameter block for results              ³
³                                                                              ³
³EXIT:            D1,D2,D3,A1 and A2 corrupted                                 ³
³                 A0 and A3 preserved                                          ³
³                                                                              ³
³ERRORS:          ERR.NF   device not found                                    ³
³                 ERR.BN   bad device name parameters                          ³
À----------------------------------------------------------------------Ù

3636 IO_NAME       MOVEA.L  (A7),A2
                   ADDQ.W   #6,A2
                   MOVEM.L  D4/D7/A0/A3,-(A7)
                   MOVEQ    #0,D7
                   MOVE.W   (A0)+,D7
                   ADD.L    A0,D7
                   MOVE.W   (A2)+,D2
3646 L03646        BSR.S    L036C0
                   CMP.B    (A2)+,D1
                   BNE.S    L036B0
                   SUBQ.B   #1,D2
                   BNE.S    L03646
                   BSR.S    L0362A
                   MOVE.W   (A2)+,D4
                   BRA.S    L0369A

3656 L03656        BSR.S    L0362A
                   MOVE.B   (A2)+,D1
                   BEQ.S    L03682
                   BLT.S    L0366A
                   BSR.S    L036C0
                   CMP.B    (A2)+,D1
                   BEQ.S    L0366C
                   SUBQ.W   #1,A0
                   MOVE.W   (A2)+,(A3)+
                   BRA.S    L0369A

366A L0366A        ADDQ.W   #1,A2
366C L0366C        MOVEA.L  A7,A1
                   MOVE.W   (A2)+,-(A7)
                   SUBA.L   A6,A0
                   SUBA.L   A6,A1
                   SUB.L    A6,D7
                   JSR      CN_DTOI(PC)
                   ADDA.L   A6,A0
                   ADD.L    A6,D7
                   MOVE.W   (A7)+,(A3)+
                   BRA.S    L0369A

3682 L03682        MOVE.B   (A2)+,D2
                   EXT.W    D2
                   ADDA.W   D2,A2
                   MOVE.L   A2,-(A7)
                   BSR.S    L036C0
368C L0368C        CMP.B    -(A2),D1
                   BEQ.S    L03696
                   SUBQ.W   #1,D2
                   BNE.S    L0368C
                   SUBQ.W   #1,A0
3696 L03696        MOVE.W   D2,(A3)+
                   MOVEA.L  (A7)+,A2
369A L0369A        DBF      D4,L03656
                   CMP.L    A0,D7
                   BNE.S    L036A6
                   MOVEQ    #4,D1
                   BRA.S    L036B8

36A6 L036A6        MOVEM.L  (A7)+,D4/D7/A0/A3
                   ADDQ.L   #2,(A7)
                   MOVEQ    #ERR.BN,D0             ;signal "bad device name"
                   RTS

36B0 L036B0        MOVEM.L  (A7)+,D4/D7/A0/A3
                   MOVEQ    #ERR.NF,D0             ;signal "device not found"
                   RTS

36B8 L036B8        MOVEM.L  (A7)+,D4/D7/A0/A3
                   ADDQ.L   #4,(A7)
                   RTS

36C0 L036C0        MOVEQ    #0,D1
                   CMP.L    A0,D7
                   BEQ.S    L036D2
                   MOVE.B   (A0),D1
                   CMPI.B   #$60,D1
                   BLT.S    L036D2
                   SUBI.B   #$20,D1
36D2 L036D2        ADDQ.W   #1,A0
                   RTS

2.14 Queue handling.

Ú----------------------------------------------------------------------¿
³=IO_SERQ         DIRECT QUEUE HANDLING               (VECTOR $E8)             ³
Ã----------------------------------------------------------------------´
³ENTRY:           none                                                         ³
³                                                                              ³
³EXIT:            A0.L     channel definition block                            ³
³                 D4,D5,A2,A3 and A4 corrupted                                 ³
³                 D3 preserved                                                 ³
³                                                                              ³
³ERRORS:          ERR.BO   buffer overflow                                     ³
³                 ERR.BP   illegal operation                                   ³
À----------------------------------------------------------------------Ù

36D6 IO_SERQ       LEA      $18(A0),A2
                   CMPI.B   #3,D0
                   BLS.S    L036E2
                   ADDQ.W   #4,A2
36E2 L036E2        TST.L    (A2)
                   BEQ.S    L036FA
                   MOVEA.L  (A2),A2
                   JSR      IO_SERIO(PC)
                   DC.L     IO_QTEST
                   DC.L     IO_QOUT
                   DC.L     IO_QIN
                   RTS

36FA L036FA        MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
                   RTS

Ú----------------------------------------------------------------------¿
³=IO_QSET         SET UP A QUEUE HEADER               (VECTOR $DC)             ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     queue length                                        ³
³                 A2.L     location of queue header                            ³
³                                                                              ³
³EXIT:            A3.L     start of actual queue                               ³
³                 D1,D2,D3,A0,A1 and A2 preserved                              ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

36FE IO_QSET       LEA      16(A2,D1.W),A3
                   CLR.L    (A2)+
                   MOVE.L   A3,(A2)+
                   SUBQ.W   #1,A3
                   MOVE.L   A3,(A2)+
                   MOVE.L   A3,(A2)+
                   SUBA.L   #16,A2
                   RTS

Ú----------------------------------------------------------------------¿
³=IO_QTEST        TEST QUEUE STATUS                   (VECTOR $DE)             ³
Ã----------------------------------------------------------------------´
³ENTRY:           A2.L     location of queue header                            ³
³                                                                              ³
³EXIT:            D1.B     next byte to be read                                ³
³                 D2.L     free space in queue                                 ³
³                 A3.L     front of queue                                      ³
³                                                                              ³
³ERRORS:          ERR.NC   queue is empty                                      ³
³                 ERR.EF   queue is at EOF                                     ³
À----------------------------------------------------------------------Ù

3714 IO_QTEST      MOVEQ    #-$11,D2
                   ADD.L    4(A2),D2
                   SUB.L    A2,D2
                   MOVE.L   8(A2),D0
                   MOVEA.L  12(A2),A3
                   MOVE.B   (A3),D1
                   SUB.L    A3,D0
                   BGT.S    L0373C
                   BLT.S    L03738
                   TST.B    (A2)
                   BLT.S    L03734
                   MOVEQ    #ERR.NC,D0             ;signal "not complete"
                   RTS

3734 L03734        MOVEQ    #ERR.EF,D0             ;signal "end of file"
                   RTS

3738 L03738        ADD.L    D2,D0
                   ADDQ.L   #1,D0
373C L0373C        SUB.L    D0,D2
                   MOVEQ    #0,D0                  ;signal "no errors"
                   RTS

Ú----------------------------------------------------------------------¿
³=IO_QIN          PUT BYTE INTO QUEUE                 (VECTOR $E0)             ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.B     byte to insert in queue                             ³
³                 A2.L     pointer to queue header                             ³
³                                                                              ³
³EXIT:            A3       corrupted                                           ³
³                 D1,D2,D3,A0,A1 and A2 preserved                              ³
³                                                                              ³
³ERRORS:          ERR.NC   queue is full                                       ³
À----------------------------------------------------------------------Ù

3742 IO_QIN        TST.B    (A2)
                   BNE.S    L03764
                   MOVEA.L  8(A2),A3
                   MOVE.B   D1,(A3)+
                   CMPA.L   4(A2),A3
                   BLT.S    L03756
                   LEA      $10(A2),A3
3756 L03756        CMPA.L   12(A2),A3
                   BNE.S    L03760
                   MOVEQ    #ERR.NC,D0             ;signal "not complete"
                   RTS

3760 L03760        MOVE.L   A3,8(A2)
3764 L03764        MOVEQ    #0,D0                  ;signal "no errors"
                   RTS

Ú----------------------------------------------------------------------¿
³=IO_QOUT         GET BYTE FROM QUEUE                 (VECTOR $E2)             ³
Ã----------------------------------------------------------------------´
³ENTRY:           A2.L     pointer to queue header                             ³
³                                                                              ³
³EXIT:            D1.B     byte read                                           ³
³                 A3.L     corrupted                                           ³
³                 D2,D3,A0,A1 and A2 preserved                                 ³
³                                                                              ³
³ERRORS:          ERR.NC   queue is empty                                      ³
³                 ERR.EF   queue is full (end of file)                         ³
À----------------------------------------------------------------------Ù

3768 IO_QOUT       MOVEA.L  12(A2),A3
                   CMPA.L   8(A2),A3
                   BNE.S    L0377E
                   TST.B    (A2)
                   BLT.S    L0377A
                   MOVEQ    #ERR.NC,D0             ;signal "not complete"
                   RTS

377A L0377A        MOVEQ    #ERR.EF,D0             ;signal "end of file"
                   RTS

377E L0377E        MOVE.B   (A3)+,D1
                   CMPA.L   4(A2),A3
                   BLT.S    L0378A
                   LEA      16(A2),A3
378A L0378A        MOVE.L   A3,12(A2)
                   MOVEQ    #0,D0
                   RTS

Ú----------------------------------------------------------------------¿
³=IO_QEOF         PUT EOF MARKER IN QUEUE             (VECTOR $E4)             ³
Ã----------------------------------------------------------------------´
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À----------------------------------------------------------------------Ù

3792 IO_QEOF       TAS      (A2)
                   RTS

Ú----------------------------------------------------------------------¿
³=IO_QEOF         PUT EOF MARKER IN QUEUE             (VECTOR $E4)             ³
³=IO_SERIO        GENERAL I/O HANDLING                (VECTOR $EA)             ³
Ã----------------------------------------------------------------------´
³ENTRY:           D0       function number                                     ³
³                 D1.B     byte to be sent                                     ³
³                 D2.W     count or buffer length                              ³
³                 A0.L     channel definition block                            ³
³                 A1.L     Queue                                               ³
³                 A6.L     QDOS system variables                               ³
³                                                                              ³
³EXIT:            D3,D4,D5,A2,A3 and A4 corrupted                              ³
³                 A0 preserved                                                 ³
³                                                                              ³
³ERRORS:          ERR.BO   buffer overflow                                     ³
³                 ERR.BP   illegal operation                                   ³
À----------------------------------------------------------------------Ù

   Normally called by a sequence such as:

     "             JSR      (A?)
                   DC.L     test pending operation routine address
                   DC.L     fetch a byte routine address
                   DC.L     send a byte routine address
                   RTS                                              "

3796 IO_SERIO      ADDI.L   #12,(A7)               ;set up correct return address
                   MOVEA.L  (A7),A4                ;A4 points at "RTS" instruction or following code
                   MOVE.L   D2,D4
                   MOVE.L   D1,D5
                   CMPI.W   #FS.MDINF,D0           ;is it a file system operation ?
                   BHI.S    L037BC                 ;jump forward if so
                   CMPI.W   #IO.SSTRNG,D0          ;is it a simple I/O operation ? 
                   BHI.S    IO_EDLIN               ;jump forward if not
                   ANDI.L   #$FFFF,D4              ;clear top word of D4, D0 already clear by TRAP #3 handler
                   MOVE.B   IO_TABLE1 - IO.PEND(PC,D0.W),D0
                   JMP      IO_TABLE1(PC,D0.W)

37BC L037BC        CMPI.B   #FS.SAVE,D0            ;is it a valid function at all ?
                   BHI.S    IO_EDLIN               ;jump forward if not
                   MOVE.B   IO_TABLE2 - FS.HEADS(PC,D0.W),D0
                   JMP      IO_TABLE2(PC,D0.W)

37CA IO_TABLE1     DC.B     IO_PEND - IO_TABLE1    ;test pending input
                   DC.B     IO_FBYTE - IO_TABLE1   ;fetch a byte
                   DC.B     IO_FLINE - IO_TABLE1   ;fetch a line
                   DC.B     IO_FSTRG - IO_TABLE1   ;fetch a string of bytes
                   DC.B     IO_EDLIN - IO_TABLE1   ;edit a line (not implemented)
                   DC.B     IO_SBYTE - IO_TABLE1   ;send a byte
                   DC.B     IO_EDLIN - IO_TABLE1   ;(not implemented)
                   DC.B     IO_SSTRG - IO_TABLE1   ;send a string of bytes

37D2 IO_TABLE2     DC.B     IO_HEADS - IO_TABLE1   ;set file header
                   DC.B     IO_HEADR - IO_TABLE1   ;read file header
                   DC.B     IO_LOAD - IO_TABLE1    ;load a file
                   DC.B     IO_SSTRG - IO_TABLE1   ;save a file

Ú----------------------------------------------------------------------¿
³=IO_FLINE        FETCH A LINE                                                 ³
Ã----------------------------------------------------------------------´
³ENTRY:           D4.W     byte to be sent                                     ³
³                 D5.W     count or buffer length                              ³
³                 A0.L     channel definition block                            ³
³                 A1.L     Queue                                               ³
³                 A6.L     QDOS system variables                               ³
³                                                                              ³
³EXIT:            D3,D4,D5,A2,A3 and A4 corrupted                              ³
³                 A0 preserved                                                 ³
³                                                                              ³
³ERRORS:          ERR.BO   buffer overflow                                     ³
À----------------------------------------------------------------------Ù

37D6 IO_FLINE      MOVEA.L  -8(A4),A4              ;get "fetch" routine address
37DA IO_LNXTB      CMP.L    D5,D4                  ;room in buffer ?
                   BLS.S    IO_ERRBO               ;exit with error if not
                   BSR.S    IO_CALLF               ;otherwise call the function
                   BNE.S    IO_GEXIT               ;and exit if any error occured
                   MOVE.B   D1,(A1)+               ;copy byte to queue
                   ADDQ.L   #1,D5                  ;increment buffer byte count
                   CMPI.B   #10,D1                 ;line feed ?
                   BNE.S    IO_LNXTB               ;get another byte if not
                   BRA.S    IO_GEXIT               ;use general exit if so

Ú----------------------------------------------------------------------¿
³=IO_SSTRG        SEND A STRING OF BYTES (OR SAVE A FILE)                      ³
Ã----------------------------------------------------------------------´
³ENTRY:           D4.W     byte to be sent                                     ³
³                 D5.W     count or buffer length                              ³
³                 A0.L     channel definition block                            ³
³                 A1.L     Queue                                               ³
³                 A6.L     QDOS system variables                               ³
³                                                                              ³
³EXIT:            D3,D4,D5,A2,A3 and A4 corrupted                              ³
³                 A0 preserved                                                 ³
³                                                                              ³
³ERRORS:          ERR.BO   buffer overflow                                     ³
À----------------------------------------------------------------------Ù

37EE IO_SSTRG      MOVEA.L  -4(A4),A4              ;get "send" routine address
37F2 IO_SNXTB      CMP.L    D5,D4                  ;room in buffer ?
                   BLS.S    IO_ERROK
                   MOVE.B   (A1),D1                ;get a byte from the queue
                   BSR.S    IO_CALLF               ;call function
                   BNE.S    IO_GEXIT               ;and exit if the buffer was full
                   ADDQ.W   #1,A1                  ;increment buffer pointer
                   ADDQ.L   #1,D5                  ;and buffer byte count
                   BRA.S    IO_SNXTB               ;get another byte

Ú----------------------------------------------------------------------¿
³=IO_LOAD         LOAD A FILE                                                  ³
³=IO_FSTRG        FETCH A STRING OF BYTES                                      ³
Ã----------------------------------------------------------------------´
³ENTRY:           D4.W     byte to be sent                                     ³
³                 D5.W     count or buffer length                              ³
³                 A0.L     channel definition block                            ³
³                 A1.L     Queue                                               ³
³                 A6.L     QDOS system variables                               ³
³                                                                              ³
³EXIT:            D3,D4,D5,A2,A3 and A4 corrupted                              ³
³                 A0 preserved                                                 ³
³                                                                              ³
³ERRORS:          ERR.BO   buffer overflow                                     ³
À----------------------------------------------------------------------Ù

3802 IO_LOAD       MOVEA.L  -8(A4),A4              ;get "fetch" routine address
3806 IO_FNXTB      CMP.L    D5,D4                  ;room in buffer ?
3808 IO_FSTRG      BLS.S    IO_ERROK
                   BSR.S    IO_CALLF               ;call function
                   BNE.S    IO_GEXIT               ;and exit if the buffer was empty
                   MOVE.B   D1,(A1)+               ;put byte into the queue
                   ADDQ.L   #1,D5                  ;increment buffer byte count
                   BRA.S    IO_FNXTB               ;put next byte if room in queue

   It may not be immediately obvious what the next sequence of four instructions
   does but in fact the pointer, A4, is being adjusted at each entry point so
   that the third instruction extracts the correct address for each entry point.

Ú----------------------------------------------------------------------¿
³=IO_PEND         TEST PENDING INPUT                                           ³
³=IO_FBYTE        FETCH A BYTE                                                 ³
³=IO_SBYTE        SEND A BYTE                                                  ³
Ã----------------------------------------------------------------------´
³ENTRY:           D4.W     byte to be sent                                     ³
³                 D5.W     count or buffer length                              ³
³                 A0.L     channel definition block                            ³
³                 A1.L     Queue                                               ³
³                 A6.L     QDOS system variables                               ³
³                                                                              ³
³EXIT:            D3,D4,D5,A2,A3 and A4 corrupted                              ³
³                 A0 preserved                                                 ³
³                                                                              ³
³ERRORS:          ERR.BO   buffer overflow                                     ³
À----------------------------------------------------------------------Ù

3814 IO_PEND       SUBQ.W   #4,A4                  ;point at "send" routine address
3816 IO_FBYTE      SUBQ.W   #4,A4                  ;point at "send" or "fetch" routine address
3818 IO_SBYTE      MOVEA.L  -4(A4),A4              ;get the "previous" routine address
                   BRA.S    IO_CALLF               ;and do the function

381E IO_EDLIN      MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
                   BRA.S    IO_EEXIT               ;use the error exit

3822 IO_ERRBO      MOVEQ    #ERR.BO,D0             ;signal "buffer overflow"
                   BRA.S    IO_GEXIT               ;use the general exit

3826 IO_ERROK      MOVEQ    #0,D0                  ;signal "no errors"
3828 IO_GEXIT      MOVE.L   D5,D1
                   BRA.S    IO_EEXIT               ;use the error exit

382C IO_CALLF      MOVEM.L  D4-5/A1/A4,-(A7)       ;save the most used registers
                   JSR      (A4)                   ;call the I/O routine
                   MOVEM.L  (A7)+,D4-5/A1/A4       ;and restore the registers
3836 IO_EEXIT      TST.L    D0                     ;set the flags ready for testing on return
                   RTS

Ú----------------------------------------------------------------------¿
³=IO_HEADS        SET FILE HEADER                                              ³
Ã----------------------------------------------------------------------´
³ENTRY:           D4.W     byte to be sent                                     ³
³                 D5.W     count or buffer length                              ³
³                 A0.L     channel definition block                            ³
³                 A1.L     Queue                                               ³
³                 A6.L     QDOS system variables                               ³
³                                                                              ³
³EXIT:            D3,D4,D5,A2,A3 and A4 corrupted                              ³
³                 A0 preserved                                                 ³
³                                                                              ³
³ERRORS:          ERR.BO   buffer overflow                                     ³
À----------------------------------------------------------------------Ù

383A IO_HEADS      MOVEA.L  -4(A4),A4
                   MOVEQ    #15,D4
                   TST.W    D5
                   BGT.S    IO_SNXTB
                   ST       D1
                   BSR.S    IO_CALLF
                   BNE.S    IO_GEXIT
                   MOVEQ    #1,D5
                   BRA.S    IO_SNXTB

Ú----------------------------------------------------------------------¿
³=IO_HEADR        READ FILE HEADER                                             ³
Ã----------------------------------------------------------------------´
³ENTRY:           D4.W     byte to be sent                                     ³
³                 D5.W     count or buffer length                              ³
³                 A0.L     channel definition block                            ³
³                 A1.L     Queue                                               ³
³                 A6.L     QDOS system variables                               ³
³                                                                              ³
³EXIT:            D3,D4,D5,A2,A3 and A4 corrupted                              ³
³                 A0 preserved                                                 ³
³                                                                              ³
³ERRORS:          ERR.BO   buffer overflow                                     ³
À----------------------------------------------------------------------Ù

384E IO_HEADR      MOVEQ    #15,D4
                   TST.W    D5
                   BGT.S    IO_LOAD
                   MOVEA.L  -12(A4),A4
                   BSR.S    IO_CALLF
                   BNE.S    IO_GEXIT
                   ADDQ.B   #1,D1
                   BNE.S    IO_EDLIN
                   MOVEA.L  (A7),A4
                   BSR.S    IO_FBYTE
                   MOVEQ    #1,D5
                   BRA.S    IO_FNXTB

2.15 System utilities.

Ú----------------------------------------------------------------------¿
³=UT_ERR0         SEND ERROR MESSAGE TO CHANNEL 0     (VECTOR $CA)             ³
³=UT_ERR          SEND ERROR MESSAGE TO CHANNEL       (VECTOR $CC)             ³
Ã----------------------------------------------------------------------´
³ENTRY:           D0.L     error code                                          ³
³                 A0.L     channel ID if UT.ERR                                ³
³                                                                              ³
³EXIT:            D0-D3,A0-3 preserved                                         ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

3868 UT_ERR0       MOVE.L   A0,-(A7)               ;save and clear A0
                   SUBA.L   A0,A0
                   BSR.S    UT_ERR                 ;print to channel ID 0
                   MOVEA.L  (A7)+,A0
                   RTS

3872 UT_ERR        TST.L    D0                     ;valid error code ?
                   BGE.S    ERR_EXIT               ;exit if not
                   MOVEM.L  D0-3/A1,-(A7)
                   MOVEA.L  D0,A1                  ;save D0 temporarily
                   ADD.L    D0,D0                  ;form offset into first table
                   BVS.S    PRNT_ERR               ;jump forward if it's user defined
                   NEG.W    D0                     ;otherwise form address of message

   The address of the message is found by first finding the offset into
   the table of messages and then adding this to the address of the table.
   number check is made as to the validity of the -ve error code so if this is
   less than -21 the routine will print an erroneously long message.

                   MOVE.W   ERR_OFST - $02(PC,D0.W),D0
                   LEA      ERR_MSGE - $2A(PC,D0.W),A1

   Now print the message whose address is in A1.

388A PRNT_ERR      JSR      UT_MTEXT(PC)           ;print message
                   MOVEM.L  (A7)+,D0-3/A1
3892 ERR_EXIT      RTS

   The first table is a list of word offsets into the second table. The
   second table is a list of error messages normally used by SuperBASIC.

3894 ERR_OFST      DC.W     $2A,$3A,$48,$59,$68,$76,$8A,$96,$A8,$B2,$C0,$CE,$DA,$E8
                   DC.W     $F8,$108,$120,$136,$142,$154,$160

38BE ERR_MSGE      DC.B     0,13,'not complete',10,0
                   DC.B     0,12,'invalid Job',10
                   DC.B     0,14,'out of memory',10
                   DC.B     0,13,'out of range',10,0
                   DC.B     0,12,'buffer full',10
                   DC.B     0,17,'channel not open',10,0
                   DC.B     0,10,'not found',10
                   DC.B     0,15,'already exists',10,0
                   DC.B     0,7,'in use',10,0
                   DC.B     0,12,'end of file',10
                   DC.B     0,11,'drive full',10,0
                   DC.B     0,9,'bad name',10,0
                   DC.B     0,11,'Xmit error',10,0
                   DC.B     0,14,'format failed',10
                   DC.B     0,14,'bad parameter',10
                   DC.B     0,22.'bad or changed medium',10
                   DC.B     0,20,'error in expression',10
                   DC.B     0,9,'overflow',10,0
                   DC.B     0,16,'not implemented',10
                   DC.B     0,10,'read only',10
                   DC.B     0,9,'bad line',10,0

Ú----------------------------------------------------------------------¿
³=UT_MINT         PRINT DECIMAL NUMBER ON CHANNEL     (VECTOR $CE)             ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.W     value to print                                      ³
³                 A0.L     channel ID                                          ³
³                                                                              ³
³EXIT:            D1,D2,D3,A1,A2 and A3 corrupted                              ³
³                 A0       preserved                                           ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

3A00 UT_MINT       SUBA.L   A6,A6
                   MOVEA.L  A7,A1
                   SUBQ.W   #8,A7
                   MOVE.L   A0,-(A7)
                   LEA      4(A7),A0
                   MOVE.W   D1,-(A1)
3A10 L03A10        JSR      CN_ITOD(PC)
3A14 L03A14        MOVEA.L  (A7)+,A0
3A16 L03A16        MOVEA.L  A7,A1
                   MOVE.W   D1,D2
3A1A L03A1A        BSR.S    L03A24
                   ADDQ.W   #8,A7
                   MOVEA.L  (A7)+,A6
                   RTS

Ú----------------------------------------------------------------------¿
³=UT_MTEXT        SEND MESSAGE TO CHANNEL             (VECTOR $D0)             ³
Ã----------------------------------------------------------------------´
³ENTRY:           A0.L     channel ID                                          ³
³                 A1.L     start of message                                    ³
³                                                                              ³
³EXIT:            D1,D2,D3 and A1 corrupted                                    ³
³                 A0,A2 and A3 preserved                                       ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

3A22 UT_MTEXT      MOVE.W   (A1)+,D2
3A24 L03A24        MOVEQ    #IO.SSTRG,D0           ;TRAP to send a string of bytes
                   MOVE.L   A0,D3                  ;copy ID to set flags
                   BEQ.S    L03A2E                 ;jump forward if channel #0
                   MOVEQ    #-1,D3                 ;use an infinite timeout
                   BRA.S    L03A34                 ;send the message

3A2E L03A2E        SF       SV_SCRST               ;ensure screen enabled
3A34 L03A34        TRAP     #3                     ;do the TRAP
                   CMPI.W   #-1,D0                 ;not complete ?
                   BNE.S    L03A48                 ;exit if so
                   MOVEA.L  #$00010001,A0          ;channel ID for channel #1
                   MOVEQ    #IO.SSTRG,D0           ;TRAP to send a string of bytes
                   TRAP     #3                     ;send the message
                   SUBA.L   A0,A0                  ;clear A0
3A48 L03A48        RTS

Ú----------------------------------------------------------------------¿
³=UT_LINK         LINK ITEM INTO LIST                 (VECTOR $D2)             ³
³=UT_UNLNK        UNLINK ITEM FROM LIST               (VECTOR $D4)             ³
Ã----------------------------------------------------------------------´
³ENTRY:           A0.L     location of link                                    ³
³                 A1.L     location of pointer to list                         ³
³                                                                              ³
³EXIT:            A1       corrupted                                           ³
³                 D1,D2,D3,A0,A2 and A3 preserved                              ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

3A4A UT_LINK       MOVE.L   (A1),(A0)
                   MOVE.L   A0,(A1)
                   RTS

3A50 UT_UNLNK      CMPA.L   (A1),A0
                   BEQ.S    L03A5C
                   TST.L    (A1)
                   BEQ.S    L03A5E
                   MOVEA.L  (A1),A1
                   BRA.S    UT.UNLNK

3A5C L03A5C        MOVE.L   (A0),(A1)
3A5E L03A5E        RTS

Ú----------------------------------------------------------------------¿
³=UT_WINDW        CREATE WINDOW CHANNEL               (VECTOR $C4)             ³
³=UT_CON          CREATE CONSOLE CHANNEL              (VECTOR $C6)             ³
³=UT_SCR          CREATE SCREEN CHANNEL               (VECTOR $C8)             ³
Ã----------------------------------------------------------------------´
³ENTRY:           A0.L     pointer to name if UT.WINDW                         ³
³                 A1.L     pointer to parameter block                          ³
³                                                                              ³
³EXIT:            A0.L     channel ID                                          ³
³                 D1,D2,D3,A1,A2 and A3 corrupted                              ³
³                                                                              ³
³ERRORS:          ERR.OM   out of memory                                       ³
³                 ERR.OR   out of range                                        ³
³                 ERR.NO   too many channels                                   ³
³                 ERR.BN   bad name                                            ³
À----------------------------------------------------------------------Ù

3A60 UT_WINDW      BSR.S    L03A98
                   BRA.S    L03A7A

3A64 UT_CON        LEA      L03AB2(PC),A0
                   BRA.S    L03A6E

3A6A UT_SCR        LEA      L03AB8(PC),A0
3A6E L03A6E        BSR.S    L03A98
                   ADDQ.W   #4,A1
                   MOVEQ    #SD.WDEF,D0            ;TRAP to re-define window
                   MOVEQ    #0,D2                  ;use zero border width
                   BSR.S    L03AA4
                   SUBQ.W   #4,A1
3A7A L03A7A        MOVEQ    #SD.BORDR,D0           ;TRAP to set window border
                   MOVE.B   (A1)+,D1               ;get border colour and width from the
                   MOVE.B   (A1)+,D2               ;parameter block
                   BSR.S    L03AA4
                   MOVEQ    #SD.SETPA,D0           ;TRAP to set paper colour
                   MOVE.B   (A1),D1                ;get paper colour from parameter block
                   BSR.S    L03AA4
                   MOVEQ    #SD.SETST,D0           ;TRAP to set strip colour
                   MOVE.B   (A1)+,D1               ;get strip colour from parameter block
                   BSR.S    L03AA4
                   MOVEQ    #SD.SETIN,D0           ;TRAP to set ink colour
                   MOVE.B   (A1),D1                ;get ink colour from parameter block
                   BSR.S    L03AA4
                   MOVEQ    #SD.CLEAR,D0           ;TRAP to clear window
                   BRA.S    L03AA4

3A98 L03A98        MOVE.L   A1,-(A7)
3A9A L03A9A        MOVEQ    #IO.OPEN,D0            ;TRAP to open a channel
                   MOVEQ    #-1,D1
                   MOVEQ    #0,D3                  ;open type
                   TRAP     #2                     ;open the channel
                   BRA.S    L03AA8

3AA4 L03AA4        MOVE.L   A1,-(A7)
3AA6 L03AA6        TRAP     #3
3AA8 L03AA8        MOVEA.L  (A7)+,A1
                   TST.L    D0                     ;any errors ?
                   BEQ.S    L03AB0                 ;exit if not otherwise
                   ADDQ.W   #4,A7                  ;restore stack
3AB0 L03AB0        RTS

3AB2 L03AB2        DC.W     3,'CON'                ;console device name
                   DC.W     3,"SCR"                ;screen device name

3ABE L03ABE        MOVEQ    #0,D4
                   MOVE.B   D0,D4
                   ROR.L    #1,D4
                   SUBQ.B   #2,D4
                   MOVE.W   0(A6,A0.L),D0
                   ADDQ.W   #2,A0
                   LEA      0(A0,D0.W),A2
                   MOVE.W   0(A6,A1.L),D1
                   ADDQ.W   #2,A1
                   LEA      0(A1,D1.W),A3
                   RTS

3ADC L03ADC        MOVEM.L  D4/A0-4,-(A7)
                   BSR.S    L03ABE
                   LEA      0(A1,D0.W),A4
                   EXG      A4,A3
                   MOVEQ    #0,D1
3AEA L03AEA        CMPA.L   A4,A3
                   BGT.S    L03AFA
                   ADDQ.L   #1,D1
                   BSR.S    L03B04
                   BEQ.S    L03AFE
                   ADDQ.W   #1,A1
                   ADDQ.W   #1,A3
                   BRA.S    L03AEA

3AFA L03AFA        MOVEQ    #0,D1
3AFC L03AFC        MOVEQ    #0,D0
3AFE L03AFE        MOVEM.L  (A7)+,D4/A0-4
                   RTS

3B04 L03B04        MOVEM.L  D1-5/A0-3,-(A7)
3B08 L03B08        BRA.S    L03B10

Ú----------------------------------------------------------------------¿
³=UT_CSTR         STRING COMPARISON                   (VECTOR $E6)             ³
Ã----------------------------------------------------------------------´
³ENTRY:           D0.B     type of comparison                                  ³
³                 A0.L     start of first string (relative to A6)              ³
³                 A1.L     start of second string (relative to A6)             ³
³                                                                              ³
³EXIT:            D0.L     result of comparison                                ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

3B0A UT_CSTR       MOVEM.L  D1-5/A0-3,-(A7)
3B0E L03B0E        BSR.S    L03ABE
3B10 L03B10        CMPA.L   A2,A0
                   BNE.S    L03B1A
                   CMPA.L   A3,A1
                   BNE.S    L03B36
                   BRA.S    L03B3A

3B1A L03B1A        CMPA.L   A3,A1
3B1C L03B1C        BEQ.S    L03B3E
                   BSR.S    L03B56
                   CMP.B    D4,D0
                   BEQ.S    L03B9A
                   CMP.B    D3,D2
                   BNE.S    L03B34
                   TST.B    D0
                   BLE.S    L03B10
                   TST.L    D4
                   BLT.S    L03B10
                   CMPI.B   #2,D0
3B34 L03B34        BGT.S    L03B3E
3B36 L03B36        MOVEQ    #-1,D0
                   BRA.S    L03B40

3B3A L03B3A        MOVEQ    #0,D0
3B3C L03B3C        BRA.S    L03B40

3B3E L03B3E        MOVEQ    #1,D0
3B40 L03B40        MOVEM.L  (A7)+,D1-5/A0-3
3B44 L03B44        RTS

3B46 L03B46        DC.W     $0000
                   DC.W     $0000
                   DC.W     $00FF
                   DC.W     $0000
                   DC.W     $0000
                   DC.W     $0001
                   DC.W     $0000

3B54 L03B54        BTST     D1,D0
3B56 L03B56        EXG      A1,A0
                   EXG      A3,A2
                   BSR.S    L03B72
                   EXG      A1,A0
                   EXG      A3,A2
                   MOVE.B   D0,D1
                   MOVE.B   D2,D3
                   BSR.S    L03B72
                   LSL.B    #2,D0
                   ADD.B    D1,D0
                   EXT.W    D0
                   MOVE.B   L03B46(PC,D0.W),D0
                   RTS

3B72 L03B72        MOVE.B   0(A6,A0.L),D2
3B76 L03B76        ADDQ.W   #1,A0
                   BSR      L03C68
                   CMPI.B   #$CE,D2
                   BNE.S    L03B98
                   CMPA.L   A2,A0
                   BEQ.S    L03B96
                   CMPI.B   #$30,0(A6,A0.L)
                   BLT.S    L03B96
                   CMPI.B   #$39,0(A6,A0.L)
                   BLE.S    L03B98
3B96 L03B96        CLR.B    D0
3B98 L03B98        RTS

3B9A L03B9A        BSR.S    L03C04
3B9C L03B9C        MOVE.W   D3,D2
                   MOVE.W   D1,D3
                   EXG      A1,A0
                   EXG      A3,A2
                   BSR.S    L03C04
                   CMP.W    D1,D3
3BA8 L03BA8        BNE.S    L03B34
                   SUBA.W   D1,A0
                   SUBA.W   D1,A1
                   BRA.S    L03BBE

3BB0 L03BB0        MOVE.B   0(A6,A1.L),D5
3BB4 L03BB4        ADDQ.W   #1,A1
                   CMP.B    0(A6,A0.L),D5
                   ADDQ.W   #1,A0
                   BNE.S    L03BA8
3BBE L03BBE        DBF      D1,L03BB0
                   BSR.S    L03C3A
                   MOVE.W   D3,-(A7)
                   MOVE.W   D1,-(A7)
                   EXG      A1,A0
                   EXG      A3,A2
                   BSR.S    L03C3A
                   MOVE.W   (A7)+,D0
                   MOVE.W   (A7)+,D2
                   SUB.W    D2,D3
                   BGT.S    L03BD8
                   ADD.W    D3,D2
3BD8 L03BD8        TST.W    D2
                   BEQ.S    L03BFA
                   SUBA.W   D1,A0
                   SUBA.W   D0,A1
                   SUB.W    D2,D1
                   SUB.W    D2,D0
3BE4 L03BE4        MOVE.B   0(A6,A0.L),D5
                   ADDQ.W   #1,A0
                   CMP.B    0(A6,A1.L),D5
                   ADDQ.W   #1,A1
                   BNE.S    L03BA8
                   SUBQ.W   #1,D2
                   BNE.S    L03BE4
                   ADDA.W   D1,A0
                   ADDA.W   D0,A1
3BFA L03BFA        TST.W    D3
                   BNE      L03B34
                   BRA      L03B10

3C04 L03C04        MOVEQ    #0,D1
3C06 L03C06        CMPI.B   #$D0,D2
3C0A L03C0A        BNE.S    L03C1E
                   CMPA.L   A2,A0
                   BEQ.S    L03C38
                   MOVE.B   0(A6,A0.L),D2
                   ADDQ.W   #1,A0
                   BSR.S    L03C68
                   SUBQ.B   #1,D0
                   BNE.S    L03C36
                   BRA.S    L03C06

3C1E L03C1E        CMPI.B   #$CE,D2
3C22 L03C22        BEQ.S    L03C36
                   ADDQ.W   #1,D1
                   CMPA.L   A2,A0
                   BEQ.S    L03C38
                   MOVE.B   0(A6,A0.L),D2
                   ADDQ.W   #1,A0
                   BSR.S    L03C68
                   SUBQ.B   #1,D0
                   BEQ.S    L03C1E
3C36 L03C36        SUBQ.W   #1,A0
3C38 L03C38        RTS

3C3A L03C3A        MOVEQ    #0,D1
3C3C L03C3C        MOVEQ    #0,D3
3C3E L03C3E        CMPA.L   A2,A0
                   BEQ.S    L03C66
                   MOVE.B   0(A6,A0.L),D2
                   BSR.S    L03C68
                   SUBQ.B   #1,D0
                   BNE.S    L03C66
                   CMPI.B   #$CE,D2
                   BNE.S    L03C58
                   TST.L    D1
                   BNE.S    L03C66
                   MOVEQ    #-1,D1
3C58 L03C58        ADDQ.W   #1,A0
                   ADDQ.W   #1,D1
                   CMPI.B   #$D0,D2
                   BEQ.S    L03C3E
                   MOVE.W   D1,D3
                   BRA.S    L03C3E

3C66 L03C66        RTS

3C68 L03C68        MOVE.B   D2,D0
3C6A L03C6A        BLT.S    L03C82
                   CMPI.B   #$2E,D0
                   BEQ.S    L03C86
                   EXT.W    D0
                   ADDI.W   #$2E,D0
                   MOVE.B   L03C68(PC,D0.W),D0
                   BEQ.S    L03C82
                   SUBQ.B   #2,D0
                   BLE.S    L03C86
3C82 L03C82        CLR.B    D0
                   RTS

3C86 L03C86        MOVE.B   D2,D0
3C88 L03C88        ADDI.B   #$A0,D2
                   BCC.S    L03C92
                   SUBI.B   #$20,D2
3C92 L03C92        LSR.B    #5,D0
                   RTS

3C96 L03C96        DC.W     $0000,$0000
                   DC.W     $0000,$0000
                   DC.W     $0000,$0000
                   DC.W     $0000,$0000
                   DC.W     $0000,$0000
                   DC.W     $0000,$0000
                   DC.W     $0000,$0000
                   DC.W     $0000,$0000
                   DC.W     $2003,$0000
                   DC.W     $2425,$0003
                   DC.W     $0000,$0000
                   DC.W     $0300,$0000
                   DC.W     $0202,$0202
                   DC.W     $0202,$0202
                   DC.W     $0202,$0003
                   DC.W     $0000,$0000
                   DC.W     $0001,$0101
                   DC.W     $0101,$0101
                   DC.W     $0101,$0101
                   DC.W     $0101,$0101
                   DC.W     $0101,$0101
                   DC.W     $0101,$0101
                   DC.W     $0101,$0100
                   DC.W     $0000,$0001
                   DC.W     $0001,$0101
                   DC.W     $0101,$0101
                   DC.W     $0101,$0101
                   DC.W     $0101,$0101
                   DC.W     $0101,$0101
                   DC.W     $0101,$0101
                   DC.W     $0101,$0100
                   DC.W     $0000,$0000

3D16 L03D16        CMP.L    A0,D7
                   BEQ.S    L03D38
                   ADDQ.W   #1,A0
3D1C L03D1C        CMPI.B   #$20,0(A6,A0.L)
                   BEQ.S    L03D16
                   MOVEQ    #0,D5
                   MOVEQ    #$2B,D6
                   SUB.B    0(A6,A0.L),D6
                   BEQ.S    L03D36
                   ADDQ.B   #2,D6
                   BNE.S    L03D38
                   BSET     #$1F,D5
3D36 L03D36        ADDQ.W   #1,A0
3D38 L03D38        RTS

3D3A L03D3A        MOVEQ    #0,D6
3D3C L03D3C        CMP.L    A0,D7
                   BEQ.S    L03D58
                   MOVE.B   0(A6,A0.L),D6
                   SUBI.W   #$30,D6
                   BLT.S    L03D54
                   CMPI.W   #9,D6
                   BGT.S    L03D54
                   ADDQ.L   #2,(A7)
                   BRA.S    L03D58

3D54 L03D54        ADDI.W   #$30,D6
3D58 L03D58        ADDQ.W   #1,A0
3D5A L03D5A        RTS

3D5C L03D5C        BSR.S    L03D1C
3D5E L03D5E        BSR.S    L03D3A
                   BRA.S    L03D76

3D62 L03D62        MOVE.L   D6,D3
3D64 L03D64        BSR.S    L03D3A
                   BRA.S    L03D7A

3D68 L03D68        MULU     #10,D3
                   ADD.L    D6,D3
                   CMPI.L   #$7FFF,D3
                   BLE.S    L03D64
3D76 L03D76        MOVEQ    #-17,D0
                   RTS

3D7A L03D7A        TST.L    D5
3D7C L03D7C        BPL.S    L03D80
                   NEG.W    D3
3D80 L03D80        MOVEQ    #0,D0
                   RTS

2.16 Conversion routines.

Ú----------------------------------------------------------------------¿
³=CN_DTOF         CONVERT ASCII TO FLOATING POINT     (VECTOR $100)            ³
Ã----------------------------------------------------------------------´
³ENTRY:           D7.L     relative pointer to end of buffer + 1               ³
³                 A0.L     relative pointer to buffer of characters            ³
³                 A1.L     relative pointer to top of maths stack              ³
³                                                                              ³
³EXIT:            A1.L     new TOS                                             ³
³                 D1,D2,A2 and A3 corrupted                                    ³
³                 D3,D7 and A0 preserved                                       ³
³                                                                              ³
³ERRORS:          ERR.EX   error in expression                                 ³
À----------------------------------------------------------------------Ù

3D84 CN_DTOF       MOVEM.L  D3-6/A0-1,-(A7)
                   MOVEQ    #0,D4
                   BSR.S    L03D1C
                   SUBQ.W   #6,A1
                   CLR.L    2(A6,A1.L)
                   CLR.W    0(A6,A1.L)
3D96 L03D96        BSR.S    L03D3A
                   BRA.S    L03DB6

3D9A L03D9A        MOVE.B   #$DF,D5
                   TST.W    D4
                   BEQ.S    L03DA4
                   ADDQ.W   #1,D4
3DA4 L03DA4        BSR.S    L03E24
                   JSR      L04966(PC)
                   BNE.S    L03E1E
                   MOVE.L   D6,D1
                   BSR.S    L03E26
                   JSR      L048D2(PC)
                   BRA.S    L03D96

3DB6 L03DB6        CMPI.B   #$2E,D6
3DBA L03DBA        BNE.S    L03DC4
                   TST.W    D4
                   BNE.S    L03E1C
                   MOVEQ    #1,D4
                   BRA.S    L03D96

3DC4 L03DC4        TST.B    D5
3DC6 L03DC6        BEQ.S    L03E1C
                   TST.L    D5
                   BPL.S    L03DD0
                   JSR      L04A90(PC)
3DD0 L03DD0        MOVEQ    #0,D3
                   AND.B    D5,D6
                   CMPI.B   #$45,D6
                   BNE.S    L03DDE
                   BSR.S    L03D5C
                   BNE.S    L03E1E
3DDE L03DDE        TST.W    D4
                   BEQ.S    L03DE4
                   SUBQ.W   #1,D4
3DE4 L03DE4        SUB.W    D3,D4
                   BVS.S    L03E1C
                   BEQ.S    L03E10
                   SGE      D5
                   BGE.S    L03DF0
                   NEG.W    D4
3DF0 L03DF0        BSR.S    L03E24
                   SUBQ.W   #2,A1
                   MOVE.W   D4,0(A6,A1.L)
                   JSR      L04876(PC)
                   BNE.S    L03E1E
                   TST.B    D5
                   BEQ.S    L03E0A
                   JSR      L049FE(PC)
                   BNE.S    L03E1E
                   BRA.S    L03E10

3E0A L03E0A        JSR      L04966(PC)
3E0E L03E0E        BNE.S    L03E1E
3E10 L03E10        MOVEM.L  (A7)+,D3-6
                   SUBQ.W   #1,A0
                   ADDQ.W   #8,A7
                   MOVEQ    #0,D0
                   RTS

3E1C L03E1C        MOVEQ    #-17,D0
3E1E L03E1E        MOVEM.L  (A7)+,D3-6/A0-1
3E22 L03E22        RTS

3E24 L03E24        MOVEQ    #10,D1
3E26 L03E26        MOVE.L   #$81F,D0
3E2C L03E2C        JMP      L048CC(PC)

Ú----------------------------------------------------------------------¿
³=CN_DTOI         CONVERT ASCII TO INTEGER            (VECTOR $102)            ³
Ã----------------------------------------------------------------------´
³ENTRY:           D7.L     relative pointer to end of buffer + 1               ³
³                 A0.L     relative pointer to buffer of characters            ³
³                 A1.L     relative pointer to top of maths stack              ³
³                                                                              ³
³EXIT:            A1.L     new TOS                                             ³
³                 D1,D2,A2 and A3 corrupted                                    ³
³                 D3,D7 and A0 preserved                                       ³
³                                                                              ³
³ERRORS:          ERR.EX   error in expression                                 ³
À----------------------------------------------------------------------Ù

3E30 CN_DTOI       MOVEM.L  D3-6/A0-1,-(A7)
3E34 L03E34        BSR      L03D5C
                   BNE.S    L03E1E
                   SUBQ.W   #2,A1
                   MOVE.W   D3,0(A6,A1.L)
                   BRA.S    L03E10

Ú----------------------------------------------------------------------¿
³=CN_HTOIB        CONVERT ASCII TO HEX BYTE           (VECTOR $10A)            ³
³=CN_HTOIW        CONVERT ASCII TO HEX WORD           (VECTOR $10C)            ³
³=CN_HTOIL        CONVERT ASCII TO HEX LONG           (VECTOR $10E)            ³
Ã----------------------------------------------------------------------´
³ENTRY:           D7.L     relative pointer to end of buffer or 0              ³
³                 A0.L     relative pointer to buffer of characters            ³
³                 A1.L     relative pointer to top of maths stack              ³
³                                                                              ³
³EXIT:            A1.L     new TOS                                             ³
³                 D1,D2,A2 and A3 corrupted                                    ³
³                 D3,D7 and A0 preserved                                       ³
³                                                                              ³
³ERRORS:          ERR.EX   error in expression                                 ³
À----------------------------------------------------------------------Ù

3E42 CN_HTOIB      MOVEQ    #2,D0
                   BRA.S    L03E4C

3E46 CN_HTOIW      MOVEQ    #4,D0
                   BRA.S    L03E4C

3E4A CN_HTOIL      MOVEQ    #8,D0
3E4C L03E4C        MOVEM.L  D3-6/A0-1,-(A7)
                   MOVE.L   D0,D4
                   LSR.B    #1,D4
                   SUBQ.W   #2,A1
                   MOVE.B   D4,1(A6,A1.L)
                   MOVE.B   #15,0(A6,A1.L)
                   MOVEQ    #4,D4
3E62 L03E62        MOVE.L   D0,D6
                   MOVE.L   D0,D5
                   MOVEQ    #0,D3
3E68 L03E68        BSR      L03D3A
                   BRA.S    L03E70

3E6E L03E6E        BRA.S    L03E7E

3E70 L03E70        ANDI.B   #$DF,D0
3E74 L03E74        SUBI.B   #$41,D0
                   BLT.S    L03E8E
                   ADDI.B   #10,D0
3E7E L03E7E        CMP.B    0(A6,A1.L),D0
                   BHI.S    L03E8E
                   LSL.L    D4,D3
                   ADD.L    D0,D3
                   DBF      D5,L03E68
                   BRA.S    L03EA0

3E8E L03E8E        MOVE.B   1(A6,A1.L),D4
3E92 L03E92        ADDQ.L   #2,A1
                   MOVE.L   D3,-4(A6,A1.L)
                   SUBA.L   D4,A1
                   CMP.W    D5,D6
                   BGT      L03E10
3EA0 L03EA0        BRA      L03E1E

Ú----------------------------------------------------------------------¿
³=CN_BTOIB        CONVERT ASCII TO BINARY BYTE        (VECTOR $104)            ³
³=CN_BTOIW        CONVERT ASCII TO BINARY WORD        (VECTOR $106)            ³
³=CN_BTOIL        CONVERT ASCII TO BINARY LONG        (VECTOR $108)            ³
Ã----------------------------------------------------------------------´
³ENTRY:           D7.L     relative pointer to end of buffer or 0              ³
³                 A0.L     relative pointer to buffer of characters            ³
³                 A1.L     relative pointer to top of maths stack              ³
³                                                                              ³
³EXIT:            A1.L     new TOS                                             ³
³                 D1,D2,A2 and A3 corrupted                                    ³
³                 D3,D7 and A0 preserved                                       ³
³                                                                              ³
³ERRORS:          ERR.EX   error in expression                                 ³
À----------------------------------------------------------------------Ù

3EA4 CN_BTOIB      MOVEQ    #8,D0
                   BRA.S    L03EAE

3EA8 CN_BTOIW      MOVEQ    #16,D0
                   BRA.S    L03EAE

3EAC CN_BTOIL      MOVEQ    #32,D0
3EAE L03EAE        MOVEM.L  D3-6/A0-1,-(A7)
                   MOVE.L   D0,D4
                   LSR.B    #4,D4
                   SUBQ.W   #2,A1
                   MOVE.B   D4,1(A6,A1.L)
                   MOVEQ    #1,D4
                   MOVE.B   D4,0(A6,A1.L)
                   BRA.S    L03E62

Ú----------------------------------------------------------------------¿
³=CN_ITOD         CONVERT INTEGER TO ASCII            (VECTOR $F2)             ³
Ã----------------------------------------------------------------------´
³ENTRY:           A0.L     relative pointer to buffer for result               ³
³                 A1.L     relative pointer to top of maths stack              ³
³                                                                              ³
³EXIT:            D1.L     length of result                                    ³
³                 A0.L     end of buffer + 1 (relative)                        ³
³                 A1.L     new TOS                                             ³
³                 D2,D3,A2 and A3 preserved                                    ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

3EC4 CN_ITOD       MOVE.L   A2,-(A7)
3EC6 L03EC6        MOVE.L   A0,-(A7)
                   MOVEQ    #0,D0
                   MOVE.W   0(A6,A1.L),D0
                   ADDQ.W   #2,A1
                   BGE.S    L03EDC
                   MOVE.B   #$2D,0(A6,A0.L)
                   ADDQ.W   #1,A0
                   NEG.W    D0
3EDC L03EDC        MOVE.L   A0,-(A7)
                   ADDQ.W   #5,A0
3EE0 L03EE0        DIVU     #10,D0
                   SWAP     D0
                   ADDI.B   #$30,D0
                   SUBQ.W   #1,A0
                   MOVE.B   D0,0(A6,A0.L)
                   CLR.W    D0
                   SWAP     D0
                   BNE.S    L03EE0
                   MOVE.L   (A7)+,D1
                   SUB.L    A0,D1
                   MOVE.W   D1,D0
                   ADDQ.W   #4,D0
3EFE L03EFE        LEA      0(A0,D1.W),A2
                   MOVE.B   0(A6,A0.L),0(A6,A2.L)
                   ADDQ.W   #1,A0
                   DBF      D0,L03EFE
                   ADD.L    A0,D1
                   MOVEA.L  D1,A0
                   SUB.L    (A7)+,D1
                   MOVEA.L  (A7)+,A2
                   RTS

Ú----------------------------------------------------------------------¿
³=CN_ITOHL        CONVERT HEX LONG TO ASCII           (VECTOR $FE)             ³
³=CN_ITOHW        CONVERT HEX WORD TO ASCII           (VECTOR $FC)             ³
³=CN_ITOIB        CONVERT HEX BYTE TO ASCII           (VECTOR $FA)             ³
Ã----------------------------------------------------------------------´
³ENTRY:           A0.L     relative pointer to buffer for result               ³
³                 A1.L     relative pointer to top of maths stack              ³
³                                                                              ³
³EXIT:            A0.L     end of buffer + 1 (relative)                        ³
³                 A1.L     new TOS                                             ³
³                 D1,D2,D3 and A2  preserved                                   ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

3F18 CN_ITOHL      BSR      CN_ITOHW
3F1C CN_ITOHW      BSR      CN_ITOHB
3F20 CN_ITOHB      MOVE.B   0(A6,A1.L),D0
                   LSR.B    #4,D0
                   BSR.S    L03F30
                   MOVEQ    #15,D0
                   AND.B    0(A6,A1.L),D0
                   ADDQ.W   #1,A1
3F30 L03F30        ADDI.B   #$30,D0
                   CMPI.B   #$39,D0
                   BLS.S    L03F3C
                   ADDQ.B   #7,D0
3F3C L03F3C        MOVE.B   D0,0(A6,A0.L)
                   ADDQ.W   #1,A0
                   RTS

Ú----------------------------------------------------------------------¿
³=CN_ITOBL        CONVERT BINARY LONG TO ASCII        (VECTOR $F8)             ³
³=CN_ITOBW        CONVERT BINARY WORD TO ASCII        (VECTOR $F6)             ³
³=CN_ITOBB        CONVERT BINARY BYTE TO ASCII        (VECTOR $F4)             ³
Ã----------------------------------------------------------------------´
³ENTRY:           A0.L     relative pointer to buffer for result               ³
³                 A1.L     relative pointer to top of maths stack              ³
³                                                                              ³
³EXIT:            A0.L     end of buffer + 1 (relative)                        ³
³                 A1.L     new TOS                                             ³
³                 D1,D2,D3 and A2 preserved                                    ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

3F44 CN_ITOBL      BSR      CN_ITOBW
3F48 CN_ITOBW      BSR      CN_ITOBB
3F4C CN_ITOBB      MOVEQ    #7,D0
3F4E L03F4E        BTST     D0,0(A6,A1.L)
                   SEQ      0(A6,A0.L)
                   ADDI.B   #$31,0(A6,A0.L)
                   ADDQ.W   #1,A0
                   DBF      D0,L03F4E
                   ADDQ.W   #1,A1
                   RTS

Ú----------------------------------------------------------------------¿
³=CN_FTOD         CONVERT FLOATING POINT TO ASCII     (VECTOR $F0)             ³
Ã----------------------------------------------------------------------´
³ENTRY:           A0.L     relative pointer to buffer for result               ³
³                 A1.L     relative pointer to top of maths stack              ³
³                                                                              ³
³EXIT:            D1.L     length of result                                    ³
³                 A0.L     end of buffer + 1 (relative)                        ³
³                 A1.L     new TOS                                             ³
³                 D2,D3,A2 and A3 preserved                                    ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

3F66 CN_FTOD       MOVEM.L  D2-5,-(A7)
                   MOVE.L   A0,-(A7)
                   TST.L    2(A6,A1.L)
                   BEQ      L04070
                   MOVEQ    #6,D4
                   TST.B    2(A6,A1.L)
                   BGE.S    L03F88
                   MOVE.B   #$2D,0(A6,A0.L)
                   ADDQ.W   #1,A0
                   JSR      L04A90(PC)
3F88 L03F88        CMPI.L   #$081B5F60,0(A6,A1.L)
                   BLT.S    L03F9C
                   ADDQ.W   #1,D4
                   BSR.S    L03FB0
                   JSR      L049FE(PC)
                   BRA.S    L03F88

3F9C L03F9C        CMPI.L   #$08184C4C,0(A6,A1.L)
3FA4 L03FA4        BGE.S    L03FDC
                   SUBQ.W   #1,D4
                   BSR.S    L03FB0
                   JSR      L04966(PC)
                   BRA.S    L03F9C

3FB0 L03FB0        SUBQ.W   #6,A1
3FB2 L03FB2        MOVE.L   #$08045000,0(A6,A1.L)
                   CLR.W    4(A6,A1.L)
                   RTS

3FC0 L03FC0        MOVEQ    #0,D0
3FC2 L03FC2        SWAP     D1
                   MOVE.W   D1,D0
                   DIVU     #10,D0
                   SWAP     D0
                   MOVE.W   D0,D1
                   SWAP     D1
                   DIVU     #10,D1
                   MOVE.W   D1,D0
                   SWAP     D1
                   EXG      D0,D1
                   RTS

3FDC L03FDC        MOVEQ    #$1F,D0
3FDE L03FDE        SUB.W    0(A6,A1.L),D0
                   MOVE.L   2(A6,A1.L),D1
                   LSR.L    D0,D1
                   ADDQ.W   #6,A1
3FEA L03FEA        ADDQ.L   #5,D1
                   BSR.S    L03FC0
                   ADDQ.W   #1,D4
                   CMPI.L   #$00989680,D1
                   BGE.S    L03FEA
                   ADDQ.W   #8,A0
                   MOVEQ    #6,D2
3FFC L03FFC        BSR.S    L03FC0
                   ADDI.B   #$30,D0
                   SUBQ.W   #1,A0
                   MOVE.B   D0,0(A6,A0.L)
                   DBF      D2,L03FFC
                   CMPI.W   #5,D4
                   BGT.S    L0401C
                   CMPI.W   #$FFFF,D4
                   BLT.S    L0401C
                   MOVEQ    #0,D5
                   BRA.S    L04020

401C L0401C        MOVE.L   D4,D5
401E L0401E        MOVEQ    #0,D4
4020 L04020        ADDQ.W   #1,D4
                   MOVE.L   A0,D2
                   BRA.S    L0402E

4026 L04026        MOVE.B   0(A6,A0.L),-1(A6,A0.L)
402C L0402C        ADDQ.W   #1,A0
402E L0402E        DBF      D4,L04026
                   MOVE.B   #$2E,-1(A6,A0.L)
                   MOVEA.L  D2,A0
                   ADDQ.W   #7,A0
403C L0403C        SUBQ.W   #1,A0
                   CMPI.B   #$30,0(A6,A0.L)
                   BEQ.S    L0403C
                   CMPI.B   #$2E,0(A6,A0.L)
                   BEQ.S    L04050
                   ADDQ.W   #1,A0
4050 L04050        TST.W    D5
                   BEQ.S    L04066
                   MOVE.B   #$45,0(A6,A0.L)
                   ADDQ.W   #1,A0
                   SUBQ.W   #2,A1
                   MOVE.W   D5,0(A6,A1.L)
                   JSR      CN_ITOD(PC)
4066 L04066        MOVE.L   A0,D1
                   SUB.L    (A7)+,D1
                   MOVEM.L  (A7)+,D2-5
                   RTS

4070 L04070        MOVE.B   #$30,0(A6,A0.L)
4076 L04076        ADDQ.W   #1,A0
                   ADDQ.W   #6,A1
                   BRA.S    L04066

407C L0407C        MOVEM.L  D0/D5,-(A7)
4080 L04080        CMPI.W   #10,D0
                   BGE.S    L040A4
4086 L04086        SUBQ.W   #1,D5
                   BLE.S    L04094
                   MOVE.B   #$30,0(A6,A1.L)
                   ADDQ.L   #1,A1
                   BRA.S    L04086

4094 L04094        ADDI.W   #$30,D0
4098 L04098        MOVE.B   D0,0(A6,A1.L)
                   ADDQ.L   #1,A1
                   MOVEM.L  (A7)+,D0/D5
                   RTS

40A4 L040A4        ANDI.L   #$FFFF,D0
40AA L040AA        DIVU     #10,D0
                   SUBQ.W   #1,D5
                   BSR.S    L0407C
                   SWAP     D0
                   BRA.S    L04094

40B6 L040B6        BSR.S    L0407C
40B8 L040B8        MOVE.B   #$20,0(A6,A1.L)
                   ADDQ.L   #1,A1
                   RTS

40C2 L040C2        BSR.S    L0407C
40C4 L040C4        MOVE.B   #$3A,0(A6,A1.L)
                   ADDQ.L   #1,A1
                   RTS

Ú----------------------------------------------------------------------¿
³=CN_DATE         GET DATE STRING                     (VECTOR $EC)             ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     time in seconds                                     ³
³                 A1.L     pointer to maths stack (relative to A6)             ³
³                                                                              ³
³EXIT:            A1.L     new stack                                           ³
³                 D1,D2,D3,A0,A2 and A3 preserved                              ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

40CE CN_DATE       MOVEM.L  D1-5/A2,-(A7)
                   BSR      L04188
                   SUBA.L   #$16,A1
                   MOVE.W   #$14,0(A6,A1.L)
                   ADDQ.L   #2,A1
                   MOVE.W   D2,D0
                   MOVEQ    #4,D5
                   BSR.S    L040B6
                   MULU     #3,D4
                   LEA      L04163(PC,D4.W),A2
                   BSR.S    L04140
                   MOVE.B   #$20,0(A6,A1.L)
                   ADDQ.L   #1,A1
                   MOVEQ    #2,D5
                   MOVE.W   D1,D0
                   BSR.S    L040B6
                   SWAP     D2
                   MOVE.W   D2,D0
                   BSR.S    L040C2
                   MOVE.W   D3,D0
                   BSR.S    L040C2
                   SWAP     D3
                   MOVE.W   D3,D0
                   BSR      L0407C
                   SUBA.L   #$16,A1
411A L0411A        MOVEM.L  (A7)+,D1-5/A2
                   MOVEQ    #0,D0
                   RTS

Ú----------------------------------------------------------------------¿
³=CN_DAY          GET DAY STRING                      (VECTOR $EE)             ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     time in seconds                                     ³
³                 A1.L     pointer to maths stack (relative to A6)             ³
³                                                                              ³
³EXIT:            A1.L     new stack (position of NOS)                         ³
³                 D1,D2,D3,A0,A2 and A3 preserved                              ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

4122 CN_DAY        MOVEM.L  D1-5/A2,-(A7)
                   BSR.S    L04188
                   SUBQ.L   #6,A1
                   MOVE.W   #3,0(A6,A1.L)
                   ADDQ.L   #2,A1
                   MULU     #3,D0
                   LEA      L0414E(PC,D0.W),A2
                   BSR.S    L04140
                   SUBQ.L   #5,A1
                   BRA.S    L0411A

4140 L04140        MOVEQ    #2,D0
4142 L04142        MOVE.B   (A2)+,0(A6,A1.L)
4146 L04146        ADDQ.L   #1,A1
                   DBF      D0,L04142
                   RTS

414E L0414E        DC.B     'Sun','Mon','Tue','Wed','Thu','Fri','Sat'
                   DC.B     'Jan','Feb','Mar','Apr','May','Jun','Jul'
                   DC.B     'Aug','Sep','Oct','Nov','Dec',0

4188 L04188        MOVE.W   #$3C,D2
                   BSR      L04210
                   MOVE.W   D0,D3
                   SWAP     D3
                   BSR.S    L04210
                   MOVE.W   D0,D3
                   DIVU     #$18,D1
                   MOVE.L   D1,D2
                   ANDI.L   #$FFFF,D1
                   MOVE.L   D1,D0
                   DIVU     #7,D0
                   SWAP     D0
                   DIVU     #$5B5,D1
                   MOVE.W   D1,D2
                   ASL.W    #2,D2
                   ADDI.W   #$7A9,D2
                   CLR.W    D1
                   SWAP     D1
                   DIVU     #$16D,D1
41C0 L041C0        MOVEQ    #0,D4
41C2 L041C2        CMPI.W   #4,D1
                   BNE.S    L041CE
                   SUBQ.W   #1,D1
                   MOVE.W   #$16D,D4
41CE L041CE        ADD.W    D1,D2
                   SWAP     D1
                   ADD.W    D4,D1
41D4 L041D4        MOVEQ    #0,D5
                   MOVE.W   D2,D4
                   ANDI.W   #3,D4
                   BNE.S    L041E0
41DE L041DE        MOVEQ    #1,D5
41E0 L041E0        MOVE.W   D5,D4
                   ADDI.W   #$3A,D4
                   CMP.W    D4,D1
                   BLE.S    L041EE
                   ADDQ.W   #2,D1
                   SUB.W    D5,D1
41EE L041EE        MOVE.W   D1,D5
                   ADDI.W   #$5C,D5
                   MULU     #$64,D5
                   DIVU     #$BEF,D5
                   MOVE.W   D5,D4
                   ADDI.W   #$5C,D1
                   MULU     #$BEF,D5
                   DIVU     #$64,D5
                   SUB.W    D5,D1
                   SUBQ.W   #3,D4
                   RTS

4210 L04210        MOVEQ    #0,D0
4212 L04212        SWAP     D1
                   MOVE.W   D1,D0
                   DIVU     D2,D0
                   SWAP     D0
                   MOVE.W   D0,D1
                   SWAP     D1
                   DIVU     D2,D1
                   MOVE.W   D1,D0
                   SWAP     D1
                   EXG      D0,D1
                   RTS


;part 13
2.17 The floating point maths package.

Ú----------------------------------------------------------------------¿
³=RI_SINGL         DO SINGLE MATHS OPERATION PRESERVING A6                     ³
Ã----------------------------------------------------------------------´
³ENTRY:            D0.W     opcode                                             ³
³                  D7.L     = 0 for reliable operation                         ³
³                  A1.L     relative pointer to top of maths stack             ³
³                  A4.L     relative pointer to base of variables area         ³
³                                                                              ³
³EXIT:             A1.L     new pointer to top of maths stack                  ³
³                  D1,D2,D3,A0,A2,A3,A4 preserved                              ³
³                                                                              ³
³ERRORS:           ERR.OV   arithmetic overflow                                ³
À----------------------------------------------------------------------Ù

4228 RI_SINGL      MOVE.L   A6,-(A7)               ;save A6
                   SUBA.L   A6,A6                  ;and set it to zero so that relative values can be used
                   BSR.S    RI_EXEC                ;do the maths operation
                   BRA.S    L04236                 ;and check for any errors

Ú----------------------------------------------------------------------¿
³=RI_LIST          DO LIST OF MATHS OPERATIONS PRESERVING A6                   ³
Ã----------------------------------------------------------------------´
³ENTRY:            D0.W     opcode                                             ³
³                  D7.L     = 0 for reliable operation                         ³
³                  A1.L     relative pointer to top of maths stack             ³
³                  A3.L     address of list of maths operations                ³
³                  A4.L     relative pointer to base of variables area         ³
³                                                                              ³
³EXIT:             A1.L     new pointer to top of maths stack                  ³
³                  D1,D2,D3,A0,A2,A3,A4 preserved                              ³
³                                                                              ³
³ERRORS:           ERR.OV   arithmetic overflow                                ³
À----------------------------------------------------------------------Ù

4230 RI_LIST       MOVE.L   A6,-(A7)               ;save A6
                   SUBA.L   A6,A6                  ;and set it to zero so that relative values can be used
                   BSR.S    RI_EXECB               ;do the list of operations
4236 L04236        BEQ.S    L0423A                 ;jump forward if there were no errors
                   MOVEQ    #0,D2                  ;otherwise signal "error in maths operation"
423A L0423A        MOVEA.L  (A7)+,A6               ;restore saved A6
                   RTS

Ú----------------------------------------------------------------------¿
³=RI_EXEC          DO A MATHS OPERATION                (VECTOR $11C)           ³
Ã----------------------------------------------------------------------´
³ENTRY:            D0.W     opcode                                             ³
³                  D7.L     = 0 for reliable operation                         ³
³                  A1.L     relative pointer to top of maths stack             ³
³                  A4.L     relative pointer to base of variables area         ³
³                                                                              ³
³EXIT:             A1.L     new pointer to top of maths stack                  ³
³                  D1,D2,D3,A0,A2,A3,A4 preserved                              ³
³                                                                              ³
³ERRORS:           ERR.OV   arithmetic overflow                                ³
À----------------------------------------------------------------------Ù

423E RI_EXEC       MOVEM.L  D1-3/A0/A2-3/A5,-(A7)  ;save the normal parameter registers
                   SUBA.L   A5,A5                  ;clear A5 to signal "no maths list"

   This relies on the fact that the first byte in memory (ROM address 0) has
   the value zero which corresponds to the RI.TERM maths operation. 

                   BRA.S    RI_TEST                ;jump forward to do the maths operation

Ú----------------------------------------------------------------------¿
³=RI_EXECB         DO A LIST OF MATHS OPERATIONS       (VECTOR $11E)           ³
Ã----------------------------------------------------------------------´
³ENTRY:            D0.W     opcode                                             ³
³                  D7.L     = 0 for reliable operation                         ³
³                  A1.L     relative pointer to top of maths stack             ³
³                  A3.L     address of list of maths operations                ³
³                  A4.L     relative pointer to base of variables area         ³
³                                                                              ³
³EXIT:             A1.L     new pointer to top of maths stack                  ³
³                  D1,D2,D3,A0,A2,A3,A4 preserved                              ³
³                                                                              ³
³ERRORS:           ERR.OV   arithmetic overflow                                ³
À----------------------------------------------------------------------Ù

4246 RI_EXECB      MOVEM.L  D1-3/A0/A2-3/A5,-(A7)  ;save the normal parameter registers
                   MOVEA.L  A3,A5                  ;and set A5 to address of maths list
424C RI_GET        MOVEQ    #0,D0                  ;clear all of D0
                   MOVE.B   (A5)+,D0               ;get maths operation and exit if it was RI.TERM
                   BEQ.S    RI_EXIT                ;or there was only one maths operation to be done
4252 RI_TEST       CMPI.B   #RI.POWFP,D0           ;normal operation ?
                   BHI.S    RI_LOAD                ;jump forward to do load/store if not
                   BSR.S    RI_JUMP                ;otherwise do the operation
                   BNE.S    RI_EXIT                ;exit if arithmetic overflow occured
                   BRA.S    RI_GET                 ;otherwise get the next operation

   At this point, the value of D0 must have been greater than #30 which signifies
   that a load/store operation is required. Odd values of D0 are used for STORE
   operations which copy a value from the top of the stack to the variables area
   pointed to by the A4 register. Even values are used for LOAD operations which
   copy a value from the variables area to the top of the stack.

425E RI_LOAD       ORI.W    #$FF00,D0              ;make D0.W negative for use as an offset
                   BCLR     #0,D0                  ;and make it even, after testing for odd or even
                   ADDA.W   D0,A4                  ;effectively subtract the offset
                   BNE.S    RI_STORE               ;and jump forward if it was a STORE operation
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the stack for the new number
                   BSR.S    RI_MOVE                ;copy the value from the variables area
                   BRA.S    RI_RESET               ;and check if another operation is required

4270 RI_STORE      EXG      A4,A1                  ;exchange the source and destination pointers
                   BSR.S    RI_MOVE                ;copy the value from the stack
                   EXG      A1,A4                  ;restore the pointers again
                   ADDQ.W   #FP.LENGTH,A1          ;and "remove" the old value from the stack
4278 RI_RESET      SUBA.W   D0,A4                  ;reset the variables area pointer
                   BRA.S    RI_GET                 ;and check if another operation is required

   Copy the floating point number pointed to by the A4 register to the location
   pointed to by the A1 register, exponent first, then mantissa.

427C RI_MOVE       MOVE.W   FP.EXPNT(A6,A4.L),FP.EXPNT(A6,A1.L)
                   MOVE.L   FP.MNTSA(A6,A4.L),FP.MNTSA(A6,A1.L)
                   RTS

428A RI_EXIT       MOVEM.L  (A7)+,D1-3/A0/A2-3/A5  ;restore the normal parameter registers
                   RTS

   Get the offset to the routine to handle the maths operation and jump to it.

4290 RI_JUMP       MOVE.W   MATHTBL - RI.NINT(PC,D0.W),D0
                   JMP      MATHTBL(PC,D0.W)

   Table of offsets for the maths operations.

4298 MATHTBL       DC.W     RI_NINT - MATHTBL      ;integer floating point into word integer
                   DC.W     RI_INT  - MATHTBL      ;truncate floating point into word integer
                   DC.W     RI_NLINT- MATHTBL      ;integer floating point into long word integer
                   DC.W     RI_LINT - MATHTBL      ;convert integer word into floating point form
                   DC.W     RI_ADD  - MATHTBL      ;add TOS to NOS
                   DC.W     RI_SUB  - MATHTBL      ;subtract TOS from NOS
                   DC.W     RI_MULT - MATHTBL      ;multiply TOS by NOS
                   DC.W     RI_DIV  - MATHTBL      ;divide TOS into NOS
                   DC.W     RI_ABS  - MATHTBL      ;take positive value
                   DC.W     RI_NEG  - MATHTBL      ;negate TOS
                   DC.W     RI_DUP  - MATHTBL      ;duplicate TOS
                   DC.W     RI_COS  - MATHTBL      ;cosine of TOS
                   DC.W     RI_SIN  - MATHTBL      ;sin of TOS
                   DC.W     RI_TAN  - MATHTBL      ;tangent of TOS
                   DC.W     RI_COT  - MATHTBL      ;cotangent of TOS
                   DC.W     RI_ASIN - MATHTBL      ;arcsine of TOS
                   DC.W     RI_ACOS - MATHTBL      ;arccosine of TOS
                   DC.W     RI_ATAN - MATHTBL      ;arctangent of TOS
                   DC.W     RI_ACOT - MATHTBL      ;arccotangent of TOS
                   DC.W     RI_SQRT - MATHTBL      ;square root of TOS
                   DC.W     RI_LN   - MATHTBL      ;natural logarithm of TOS (to base e)
                   DC.W     RI_LOG10- MATHTBL      ;common logarithm of TOS (to base 10)
                   DC.W     RI_EXP  - MATHTBL      ;exponential of TOS (to power e)
                   DC.W     RI_POWFP- MATHTBL      ;raise NOS to power of TOS

Ú----------------------------------------------------------------------¿
³=RI_SIN           SIN OF TOS                                                  ³
Ã----------------------------------------------------------------------´
³RANGE:            -10,000 .. +10,000 radians                                  ³
³                                                                              ³
³ENTRY:            D7.L     should be 0 for reliability                        ³
³                  A1.L     relative pointer to top of maths stack             ³
³                                                                              ³
³EXIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          ³
³                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       ³
³                                                                              ³
³ERRORS:           ERR.OV   arithmetic overflow                                ³
À----------------------------------------------------------------------Ù

42C8 RI_SIN        MOVEM.L  D4-7/A4,-(A7)          ;save the remaining registers
                   MOVEQ    #0,D7                  ;signal "sin required"
                   BRA.S    RI_TRIG                ;compute the sin

Ú----------------------------------------------------------------------¿
³=RI_COS           COSINE OF TOS                                               ³
Ã----------------------------------------------------------------------´
³RANGE:            -10,000 .. +10,000 radians                                  ³
³                                                                              ³
³ENTRY:            D7.L     should be 0 for reliability                        ³
³                  A1.L     relative pointer to top of maths stack             ³
³                                                                              ³
³EXIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          ³
³                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       ³
³                                                                              ³
³ERRORS:           ERR.OV   arithmetic overflow                                ³
À----------------------------------------------------------------------Ù

   Cos(A) is equal to Cos(-A).

42D0 RI_COS        MOVEM.L  D4-7/A4,-(A7)          ;save the remaining registers
                   JSR      RI_ABS(PC)             ;take the absolute value to form Cos(³n³)
                   MOVEQ    #-1,D7                 ;and signal "cos required"
42DA RI_TRIG       JSR      L0471A(PC)
                   BNE.S    L04342
                   BSR.S    L04348
                   LEA      L04644(PC),A4
                   BSR.S    L0435A
                   BTST     #0,D7
                   BEQ.S    L04342
                   JSR      RI_NEG(PC)
                   BRA.S    L04342

Ú----------------------------------------------------------------------¿
³=RI_TAN           TANGENT OF TOS                                              ³
Ã----------------------------------------------------------------------´
³RANGE:            -30,000 .. +30,000 radians                                  ³
³                                                                              ³
³ENTRY:            D7.L     should be 0 for reliability                        ³
³                  A1.L     relative pointer to top of maths stack             ³
³                                                                              ³
³EXIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          ³
³                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       ³
³                                                                              ³
³ERRORS:           ERR.OV   arithmetic overflow                                ³
À----------------------------------------------------------------------Ù

42F4 RI_TAN        MOVEM.L  D4-7/A4,-(A7)          ;save the remaining registers
                   MOVEQ    #0,D6
                   BRA.S    L04306

Ú----------------------------------------------------------------------¿
³=RI_COT           COTANGENT OF TOS                                            ³
Ã----------------------------------------------------------------------´
³RANGE:            -30,000 .. +30,000 radians                                  ³
³                                                                              ³
³ENTRY:            D7.L     should be 0 for reliability                        ³
³                  A1.L     relative pointer to top of maths stack             ³
³                                                                              ³
³EXIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          ³
³                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       ³
³                                                                              ³
³ERRORS:           ERR.OV   arithmetic overflow                                ³
À----------------------------------------------------------------------Ù

42FC RI_COT        MOVEM.L  D4-7/A4,-(A7)          ;save the remaining registers
                   MOVEQ    #-1,D6
                   JSR      RI_NEG(PC)
4306 L04306        MOVEQ    #0,D7
                   JSR      L0470A(PC)
                   BNE.S    L04342
                   EOR.B    D6,D7
                   BSR.S    L04348
                   LEA      L0466C(PC),A4
                   JSR      L047C0(PC)
                   ADDQ.W   #FP.LENGTH,A1
                   BSR.S    L0435E
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   MOVE.L   -2*FP.LENGTH+FP.MNTSA(A6,A1.L),FP.MNTSA(A6,A1.L)
                   MOVE.W   -2*FP.LENGTH+FP.EXPNT(A6,A1.L),FP.EXPNT(A6,A1.L)
                   BTST     #0,D7
                   BEQ.S    L0433C
                   JSR      L04AE0(PC)
                   JSR      RI_NEG
433C L0433C        JSR      RI_DIV(PC)
4340 L04340        MOVEQ    #0,D0
4342 L04342        MOVEM.L  (A7)+,D4-7/A4          ;partially restore the registers
                   RTS

4348 L04348        JSR      RI_DUP(PC)
434C L0434C        JSR      RI_DUP(PC)
                   JSR      RI_DUP(PC)
                   JSR      RI_MULT(PC)
                   RTS

435A L0435A        JSR      L047C6(PC)
435E L0435E        JSR      RI_MULT(PC)
                   JSR      RI_ADD(PC)
                   RTS

4368 L04368        SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   CLR.W    4(A6,A1.L)
                   MOVE.L   #$08014000,FP.EXPNT(A6,A1.L)
                   JSR      L04AE0(PC)
                   RTS

Ú----------------------------------------------------------------------¿
³=RI_ACOS          ARCCOSINE OF TOS                                            ³
Ã----------------------------------------------------------------------´
³RANGE:                                                                        ³
³                                                                              ³
³ENTRY:            D7.L     should be 0 for reliability                        ³
³                  A1.L     relative pointer to top of maths stack             ³
³                                                                              ³
³EXIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          ³
³                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       ³
³                                                                              ³
³ERRORS:           ERR.OV   arithmetic overflow                                ³
À----------------------------------------------------------------------Ù

437C RI_ACOS       JSR      RI_NEG(PC)
                   BSR.S    RI_ASIN
                   BNE.S    L043B4
                   BSR.S    L043A4
                   JMP      RI_ADD(PC)

Ú----------------------------------------------------------------------¿
³=RI_ASIN          ARCSIN OF TOS                                               ³
Ã----------------------------------------------------------------------´
³RANGE:                                                                        ³
³                                                                              ³
³ENTRY:            D7.L     should be 0 for reliability                        ³
³                  A1.L     relative pointer to top of maths stack             ³
³                                                                              ³
³EXIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          ³
³                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       ³
³                                                                              ³
³ERRORS:           ERR.OV   arithmetic overflow                                ³
À----------------------------------------------------------------------Ù

438A RI_ASIN       BSR.S    L0434C
                   BSR.S    L04368
                   JSR      RI_SUB(PC)
                   BSR      RI_SQRT
                   BNE.S    L043B4
                   JSR      RI_DIV(PC)
                   BEQ.S    RI_ATAN
                   BSR.S    L043A4
                   JMP      RI_MULT(PC)

43A4 L043A4        SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   MOVE.L   #$6487ED51,FP.MNTSA(A6,A1.L)
                   MOVE.W   #$0801,FP.EXPNT(A6,A1.L)
43B4 L043B4        RTS

Ú----------------------------------------------------------------------¿
³=RI_ACOT          ARCCOTANGENT OF TOS                                         ³
Ã----------------------------------------------------------------------´
³RANGE:                                                                        ³
³                                                                              ³
³ENTRY:            D7.L     should be 0 for reliability                        ³
³                  A1.L     relative pointer to top of maths stack             ³
³                                                                              ³
³EXIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          ³
³                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       ³
³                                                                              ³
³ERRORS:           ERR.OV   arithmetic overflow                                ³
À----------------------------------------------------------------------Ù

43B6 RI_ACOT       MOVEM.L  D4-7/A4,-(A7)          ;save the remaining registers
                   MOVEQ    #2,D7
                   BRA.S    L043C4

Ú----------------------------------------------------------------------¿
³=RI_ATAN          ARCTANGENT OF TOS                                           ³
Ã----------------------------------------------------------------------´
³RANGE:                                                                        ³
³                                                                              ³
³ENTRY:            D7.L     should be 0 for reliability                        ³
³                  A1.L     relative pointer to top of maths stack             ³
³                                                                              ³
³EXIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          ³
³                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       ³
³                                                                              ³
³ERRORS:           ERR.OV   arithmetic overflow                                ³
À----------------------------------------------------------------------Ù

43BE RI_ATAN       MOVEM.L  D4-7/A4,-(A7)          ;save the remaining registers
                   MOVEQ    #0,D7
43C4 L043C4        TST.B    FP.MNTSA(A6,A1.L)
                   BGE.S    L043D0
                   ADDQ.B   #4,D7
                   JSR      RI_NEG(PC)
43D0 L043D0        CMPI.W   #$0800,FP.EXPNT(A6,A1.L)
                   BLE.S    L043E2
                   BSR.S    L04368
                   JSR      RI_DIV(PC)
                   BCHG     #1,D7
43E2 L043E2        JSR      RI_DUP(PC)
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   MOVE.L   #$4498517A,FP.MNTSA(A6,A1.W)
                   MOVE.W   #$07FF,FP.EXPNT(A6,A1.L)
                   JSR      RI_SUB(PC)
                   ADDQ.W   #FP.LENGTH,A1
                   TST.B    -FP.LENGTH+FP.MNTSA(A6,A1.L)
                   BLE.S    L04410
                   LEA      L04688(PC),A4
                   JSR      L047C0(PC)
                   JSR      RI_DIV(PC)
                   ADDQ.B   #1,D7
4410 L04410        BSR      L04348
                   LEA      L046B0(PC),A4
                   JSR      L047C0(PC)
                   JSR      RI_DIV(PC)
                   BSR      L0435E
                   LSR.B    #1,D7
                   BCC.S    L0443C
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   MOVE.L   #$430548E1,FP.MNTSA(A6,A1.L)
                   MOVE.W   #$0800,FP.EXPNT(A6,A1.L)
                   JSR      RI_ADD(PC)
443C L0443C        LSR.B    #1,D7
                   BCC.S    L0444C
                   JSR      RI_NEG(PC)
                   BSR      L043A4
                   JSR      RI_ADD(PC)
444C L0444C        LSR.B    #1,D7
                   BCC      L04340
                   JSR      RI_NEG(PC)
                   BRA      L04342

445A L0445A        MOVE.W   FP.EXPNT(A6,A1.L),D1
                   BEQ.S    L0447E
                   MOVE.W   #$080F,D0
                   SUB.W    D1,D0
                   BLT.S    L04488
                   CMPI.W   #15,D0
                   BGT.S    L04488
                   MOVE.L   FP.MNTSA(A6,A1.L),D1
                   TST.W    D1
                   BNE.S    L04488
                   ASR.L    D0,D1
                   TST.W    D1

Ú----------------------------------------------------------------------¿
³=RI_POWFP         TOS RAISED TO POWER OF NOS                                  ³
Ã----------------------------------------------------------------------´
³RANGE:                                                                        ³
³                                                                              ³
³ENTRY:            D7.L     should be 0 for reliability                        ³
³                  A1.L     relative pointer to top of maths stack             ³
³                                                                              ³
³EXIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          ³
³                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       ³
³                                                                              ³
³ERRORS:           ERR.OV   arithmetic overflow                                ³
À----------------------------------------------------------------------Ù

447A RI_POWFP      BNE.S    L04488
                   SWAP     D1
447E L0447E        ADDQ.W   #4,A1
                   MOVE.W   D1,FP.EXPNT(A6,A1.L)
                   JMP      L04876(PC)

4488 L04488        MOVEM.L  D4-7/A4,-(A7)          ;save the remaining registers
                   MOVE.W   FP.EXPNT(A6,A1.L),D4
                   MOVE.L   FP.MNTSA(A6,A1.L),D5
                   ADDQ.W   #FP.LENGTH,A1
                   TST.B    FP.MNTSA(A6,A1.L)
                   BEQ.S    L044B8
                   BSR.S    RI_LN
                   BNE      L04342
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   MOVE.L   D5,FP.MNTSA(A6,A1.L)
                   MOVE.W   D4,FP.EXPNT(A6,A1.L)
                   JSR      RI_MULT(PC)
                   BNE      L04342
                   BRA      L0457A

44B8 L044B8        TST.B    -FP.LENGTH+FP.MNTSA(6,A1.L)
                   BGE      L04340
                   BRA      ERR_OV_1

Ú----------------------------------------------------------------------¿
³=RI_LOG10         COMMON LOGARITHM OF TOS                                     ³
Ã----------------------------------------------------------------------´
³RANGE:                                                                        ³
³                                                                              ³
³ENTRY:            D7.L     should be 0 for reliability                        ³
³                  A1.L     relative pointer to top of maths stack             ³
³                                                                              ³
³EXIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          ³
³                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       ³
³                                                                              ³
³ERRORS:           ERR.OV   arithmetic overflow                                ³
À----------------------------------------------------------------------Ù

44C4 RI_LOG10      BSR.S    RI_LN
                   BNE.S    L044DC
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   MOVE.L   #$6F2DEC55,FP.MNTSA(A6,A1.L)
                   MOVE.W   #$07FF,FP.EXPNT(A6,A1.L)
                   JSR      RI_MULT(PC)
44DC L044DC        RTS

Ú----------------------------------------------------------------------¿
³=RI_LN            NATURAL LOGARITHM OF TOS                                    ³
Ã----------------------------------------------------------------------´
³RANGE:                                                                        ³
³                                                                              ³
³ENTRY:            D7.L     should be 0 for reliability                        ³
³                  A1.L     relative pointer to top of maths stack             ³
³                                                                              ³
³EXIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          ³
³                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       ³
³                                                                              ³
³ERRORS:           ERR.OV   arithmetic overflow                                ³
À----------------------------------------------------------------------Ù

44DE RI_LN         MOVEM.L  D4-7/A4,-(A7)          ;save the remaining registers
                   MOVE.W   FP.EXPNT(A6,A1.L),D4
                   MOVE.L   FP.MNTSA(A6,A1.L),D5
                   ADDQ.W   #FP.LENGTH,A1
                   BLE      ERR_OV_1
                   MOVE.W   #$0800,D0
                   MOVE.L   D5,D1
                   LSR.L    #1,D5
                   CMPI.L   #$5A82799A,D1
                   BGT.S    L0450E
                   SUBQ.W   #1,D4
                   ADDI.L   #$20000000,D5
                   BCLR     #30,D1
                   BRA.S    L04516

450E L0450E        BSET     #30,D5
                   BSET     #31,D1
4516 L04516        TST.L    D1
                   JSR      L048CC(PC)
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   MOVE.L   D5,FP.MNTSA(A6,A1.L)
                   MOVE.W   #$0800,FP.EXPNT(A6,A1.L)
                   JSR      RI_DIV(PC)
                   BSR      L04348
                   JSR      RI_DUP(PC)
                   LEA      L046CC(PC),A4
                   MOVE.W   D4,D7
                   JSR      L047C0(PC)
                   JSR      RI_DIV(PC)
                   JSR      RI_MULT(PC)
                   BSR      L0435E
                   SUBI.W   #$0800,D7
                   SUBQ.W   #2,A1
                   MOVE.W   D7,FP.EXPNT(A6,A1.L)
                   JSR      RI_LINT(PC)
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   MOVE.L   #$58B90BFC,FP.MNTSA(A6,A1.L)
                   MOVE.W   #$0800,FP.EXPNT(A6,A1.L)
                   BSR      L0435E
                   BRA      L04340

4570 ERR_OV_1      MOVEQ    #ERR_OV,D0             ;signal "arithmetic overflow"
4572 L04572        BRA      L04342

Ú----------------------------------------------------------------------¿
³=RI_EXP           EXPONENTIAL OF TOS                                          ³
Ã----------------------------------------------------------------------´
³RANGE:            -500 .. +500                                                ³
³                                                                              ³
³ENTRY:            D7.L     should be 0 for reliability                        ³
³                  A1.L     relative pointer to top of maths stack             ³
³                                                                              ³
³EXIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          ³
³                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       ³
³                                                                              ³
³ERRORS:           ERR.OV   arithmetic overflow                                ³
À----------------------------------------------------------------------Ù

4576 RI_EXP        MOVEM.L  D4-7/A4,-(A7)          ;save the remaining registers
457A L0457A        JSR      L04728(PC)
                   BNE.S    L04572
                   BSR      L0434C
                   LEA      L046EE(PC),A4
                   JSR      L047C0(PC)
                   ADDQ.W   #FP.LENGTH,A1
                   JSR      RI_MULT(PC)
                   JSR      RI_DUP(PC)
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   JSR      L04AE0(PC)
                   JSR      RI_SUB(PC)
                   JSR      RI_DIV(PC)
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   MOVE.L   #$40000000,FP.MNTSA(A6,A1.L)
                   MOVE.W   #$0800,FP.EXPNT(A6,A1.L)
                   JSR      RI_ADD(PC)
                   ADDQ.W   #1,D7
                   ADD.W    D7,FP.EXPNT(A6,A1.L)
                   BRA      L04340

Ú----------------------------------------------------------------------¿
³=RI_SQRT          SQUARE ROOT OF TOS                                          ³
Ã----------------------------------------------------------------------´
³RANGE:                                                                        ³
³                                                                              ³
³ENTRY:            D7.L     should be 0 for reliability                        ³
³                  A1.L     relative pointer to top of maths stack             ³
³                                                                              ³
³EXIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          ³
³                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       ³
³                                                                              ³
³ERRORS:           ERR.OV   arithmetic overflow                                ³
À----------------------------------------------------------------------Ù

45C2 RI_SQRT       MOVEM.L  D4-7/A4,-(A7)          ;save the remaining registers
                   MOVE.W   FP.EXPNT(A6,A1.L),D6
                   TST.L    FP.MNTSA(A6,A1.L)
                   BEQ      L04340
                   BLT.S    ERR_OV_1
                   LEA      L046FC(PC),A4
                   MOVE.W   D6,D7
                   SUBI.W   #$0800,D7
                   SUB.W    D7,FP.EXPNT(A6,A1.L)
                   ASR.W    #1,D7
                   BCC.S    L045EA
                   LEA      L0470A(PC),A4
45EA L045EA        SWAP     D6
                   JSR      L047C6(PC)
                   SWAP     D6
                   ADD.W    D7,FP.EXPNT(A6,A1.L)
                   MOVEQ    #1,D7
45F8 L045F8        JSR      RI_DUP(PC)
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   MOVE.L   D5,FP.MNTSA(A6,A1.L)
                   MOVE.W   D6,FP.EXPNT(A6,A1.L)
                   JSR      L04AE0(PC)
                   JSR      RI_DIV(PC)
                   JSR      RI_ADD(PC)
                   SUBQ.W   #1,FP.EXPNT(A6,A1.L)
                   DBF      D7,L045F8
                   BRA      L04340

                   DC.W    $0000,$0000,$0000       ; 0
                   DC.W    $07FE,$AAAA,$AAB0       ; -1.666667 x 10 -1
                   DC.W    $07FA,$4444,$42DD       ; +8.333333 x 10 -3
                   DC.W    $07F4,$97FA,$15C1       ; -1.984083 x 10 -4
                   DC.W    $07EE,$5C5A,$E940       ; +2.752397 x 10 -6
                   DC.W    $07E7,$997C,$79C0       ; -2.386835 x 10 -8
4642 L04642        DC.W    5

                   DC.W    $0801,$4000,$0000       ; +1
                   DC.W    $07FF,$8E28,$7BC1       ; -4.446948 x 10 -1
                   DC.W    $07FB,$416D,$50CD       ; +1.597339 x 10 -2
4656 L04656        DC.W    2

                   DC.W    $0000,$0000,$0000       ; 0
                   DC.W    $07FD,$8DF7,$443E       ; -1.113614 x 10 -1
                   DC.W    $07F7,$4676,$1A70       ; +1.075155 x 10 -3
466A L0466A        DC.W    2

                   DC.W    $0801,$6ED9,$EBA1       ; +1.732051
                   DC.W    $0801,$4000,$0000       ; +1
4678 L04678        DC.W    1

                   DC.W    $0800,$8000,$0000       ; -1
                   DC.W    $0801,$6ED9,$EBA1       ; +1.732051
4686 L04686        DC.W    1

                   DC.W    $0803,$451F,$BEDF       ; +4.320250
                   DC.W    $0803,$4C09,$1DF8       ; +4.752226
                   DC.W    $0801,$4000,$0000       ; +1
469A L0469A        DC.W    2

                   DC.W    $0000,$0000,$0000       ; 0
                   DC.W    $0801,$A3D5,$AC3B       ; -1.440083
                   DC.W    $0800,$A3D6,$2904       ; -7.200268 x 10 -1
46AE L046AE        DC.W    2

                   DC.W    $0803,$A6BC,$EEE1       ; -5.578874
                   DC.W    $0801,$4000,$0000       ; +1
46BC L046BC        DC.W    1

                   DC.W    $07FF,$88FB,$E7C1       ; -4.649062 x 10 -1
                   DC.W    $07FA,$6F6B,$44F3       ; +1.360095
46CA L046CA        DC.W    1

                   DC.W    $0800,$4000,$0000       ; +1
                   DC.W    $07FC,$6DB4,$CE83       ; +5.356752 x 10 -2
                   DC.W    $07F5,$4DEF,$09CA       ; +2.972936 x 10 -4
46DE L046DE        DC.W    2

                   DC.W    $07FF,$4000,$0000       ; +2.500000 x 10 -1
                   DC.W    $07F9,$617D,$E4BA       ; +5.950425 x 10 -3
46EC L046EC        DC.W    1

                   DC.W    $07FF,$6AD4,$D402       ; +4.173100 x 10 -1
                   DC.W    $0800,$4B8A,$5CE6       ; +5.901600 x 10 -1
46FA L046FA        DC.W    1

                   DC.W    $0800,$4B8A,$5CE6       ; +5.901600 x 10 -1
                   DC.W    $0800,$6AD4,$D402       ; +4.173100 x 10 -1
4708 L04708        DC.W    1

470A L0470A        ADDQ.W  #1,0(A6,A1.L)
                   BSR.S   L0471A
                   BNE.S   L04786
                   SUBQ.W  #1,0(A6,A1.L)
                   MOVEQ   #0,D0
                   RTS

471A L0471A        LEA      L047AE(PC),A4
                   CMPI.W   #$0810,FP.EXPNT(A6,A1.L)
                   BGT.S    ERR_OV_2
                   BRA.S    L04734

4728 L04728        LEA      L047C0(PC),A4
                   CMPI.W   #$0809,FP.EXPNT(A6,A1.L)
                   BGT.S    ERR_OV_2
4734 L04734        JSR      RI_DUP(PC)             ; x,x
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number

   Copy the floating point co-efficient pointed to by the A4 register to the top
   of the maths stack.

                   MOVE.L   -(A4),FP.MNTSA(A6,A1.L)
                   MOVE.W   -(A4),FP.EXPNT(A6,A1.L)
                   JSR      RI_MULT(PC)            ; x,ax
                   TST.B    D7                     ; "sin" or "cos" ?
                   BNE.S    L04756                 ;jump forward if "cos"
                   JSR      RI_NINT(PC)            ;convert to an integer
                   MOVE.W   D1,D7                  ;
                   JSR      RI_LINT(PC)
                   BRA.S    L0476C

4756 L04756        JSR      RI_INT(PC)
                   ADD.W    D1,D7
                   ADD.W    D1,FP.EXPNT(A6,A1.L)
                   ADDQ.W   #1,FP.EXPNT(A6,A1.L)
                   JSR      RI_LINT(PC)
                   SUBQ.W   #1,FP.EXPNT(A6,A1.L)
476C L0476C        MOVE.W   FP.EXPNT(A6,A1.L),D4
                   MOVE.L   FP.MNTSA(A6,A1.L),D5
                   BSR.S    L04788
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   MOVE.L   D5,FP.MNTSA(A6,A1.L)
                   MOVE.W   D4,FP.EXPNT(A6,A1.L)
                   BSR.S    L04788
                   RTS

4784 ERR_OV_2      MOVEQ    #ERR_OV,D0             ;signal "arithmetic overflow"
                   RTS

4788 L04788        SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   MOVE.L   -(A4),FP.MNTSA(A6,A1.L)
                   MOVE.W   -(A4),FP.EXPNT(A6,A1.L)
                   JSR      RI_MULT(PC)
                   JSR      RI_SUB(PC)
                   RTS

479C L0479C        DC.W     $07F0,$B544,$42D1      ; -8.908910 x 10 -6
                   DC.W     $0802,$6488,$0000      ; +3.141602
                   DC.W     $07FF,$517C,$C1B7      ; +3.183099 x 10 -1
                   DC.W     $07F4,$90BF,$BE8F      ; -2.121944 x 10 -4
                   DC.W     $0800,$58C0,$0000      ; +6.933594 x 10 -1
                   DC.W     $0801,$5C55,$1D95      ; +1.442695

47C0 L047C0        BSR.S    L047C6
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   BRA.S    L047CE

47C6 L047C6        MOVE.W   FP.EXPNT(A6,A1.L),D4
                   MOVE.L   FP.MNTSA(A6,A1.L),D5
47CE L047CE        MOVE.W   -(A4),D6
                   MOVE.L   -(A4),FP.MNTSA(A6,A1.L)
                   MOVE.W   -(A4),FP.EXPNT(A6,A1.L)
47D8 L047D8        SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   MOVE.L   D5,FP.MNTSA(A6,A1.L)
                   MOVE.W   D4,FP.EXPNT(A6,A1.L)
                   JSR      RI_MULT(PC)
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   MOVE.L   -(A4),FP.MNTSA(A6,A1.L)
                   MOVE.W   -(A4),FP.EXPNT(A6,A1.L)
                   JSR      RI_ADD(PC)
                   SUBQ.W   #1,D6
                   BGT.S    L047D8
                   RTS

Ú----------------------------------------------------------------------¿
³=RI_TRUNC         TRUNCATE FLOATING POINT FORM INTO LONG WORD INTEGER         ³
³=RI_NORND         AS ABOVE WITH NO ROUNDING PRIOR TO TRUNCATION               ³
Ã----------------------------------------------------------------------´
³ENTRY:            D7.L     should be 0 for reliability                        ³
³                  A1.L     relative pointer to top of maths stack             ³
³                                                                              ³
³EXIT:             D0.L     amount of truncation in bits                       ³
³                  D1.L     truncated TOS                                      ³
³                  D2,D3,A0,A2 and A3 corrupted                                ³
³                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       ³
³                                                                              ³
³ERRORS:           ERR.OV   arithmetic overflow                                ³
À----------------------------------------------------------------------Ù

47FA RI_TRUNC      SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   CLR.W    4(A6,A1.L)             ;and set it to 0.5
                   MOVE.L   #$08004000,0(A6,A1.L)
                   JSR      RI_ADD(PC)             ;round TOS up to nearest integer
480C RI_NORND      MOVE.W   FP.EXPNT(A6,A1.L),D0
                   MOVE.L   FP.MNTSA(A6,A1.L),D1
                   ADDQ.W   #2,A1                  ;re-adjust stack pointer for a long word
                   CLR.L    FP.EXPNT(A6,A1.L)      ;and set it to zero

   Subtracting $0800 from the exponent will give the power of two of the
   mantissa. If this is greater than zero then this means that the absolute
   value of the number represented is greater than 1. If it is less than zero
   then the number represented is fractional.

                   SUBI.W   #$0800,D0              ;number greater than or less than one ?
                   BGE.S    L04822                 ;and jump forward if greater than or equal to 1
                   MOVEQ    #0,D0                  ;if less than one then just use one
4822 L04822        SUBI.W   #31,D0                 ;find amount of actual shift from power of two
                   NEG.W    D0                     ;and negate it as we're moving right
                   ASR.L    D0,D1                  ;do shift right (left if D0 is negative)
                   MOVE.L   D1,FP.EXPNT(A6,A1.L)   ;and copy result to the top of the stack
                   RTS

Ú----------------------------------------------------------------------¿
³=RI_NINT          INTEGER FLOATING POINT FORM INTO WORD INTEGER               ³
³=RI_INT           TRUNCATE FLOATING POINT FORM INTO WORD INTEGER              ³
³=RI_NLINT         INTEGER FLOATING POINT FORM INTO LONG INTEGER               ³
³=RI_LINT          CONVERT INTEGER WORD INTO FLOATING POINT FORM               ³
Ã----------------------------------------------------------------------´
³RANGE:                                                                        ³
³                                                                              ³
³ENTRY:            D7.L     should be 0 for reliability                        ³
³                  A1.L     relative pointer to top of maths stack             ³
³                                                                              ³
³EXIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          ³
³                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       ³
³                                                                              ³
³ERRORS:           ERR.OV   arithmetic overflow                                ³
À----------------------------------------------------------------------Ù

4830 RI_NINT       BSR.S    RI_TRUNC               ;get long word equivalent of TOS after rounding up
                   BRA.S    L04836                 ;and convert it if possible to a word

4834 RI_INT        BSR.S    RI_NORND               ;as above but with no rounding during the conversion
4836 L04836        ADDQ.L   #2,A1                  ;re-adjust stack pointer for a word
                   CMPI.W   #16,D0                 ;number greater than 65536 ?
                   BLT.S    ERR_OV_3               ;exit if so as the conversion cannot be made
                   BRA.S    L0484A                 ;otherwise exit normally

4840 RI_NLINT      BSR.S    RI_TRUNC               ;get long word equivalent of TOS after rounding up
                   BRA.S    L04846                 ;check for truncation

4844 L04844        BSR.S    RI_NORND               ;as above but with no rounding during the conversion
4846 L04846        TST.W    D0                     ;was the origonal number truncated to fit ?
                   BLT.S    ERR_OV_3               ;exit with error if so
484A L0484A        MOVEQ    #0,D0                  ;otherwise signal "no errors"
                   RTS

484E ERR_OV_3      MOVEQ    #ERR.OV,D0             ;signal "arithmetic overflow"
                   RTS

4852 RI_LINT       MOVE.W   #$081F,D0
                   MOVE.W   FP.EXPNT(A6,A1.L),D1
                   ADDQ.W   #2,A1
                   EXT.L    D1
                   JMP      L048CC(PC)

4862 L04862        SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   CLR.W    $04(A6,A1.L)
                   MOVE.L   #$08014000,0(A6,A1.L)
                   JSR      L04AE0(PC)
                   RTS

4876 L04876        MOVEM.L  D4-6,-(A7)             ;save the remaining registers
                   MOVE.W   FP.EXPNT(A6,A1.L),D6
                   ADDQ.W   #2,A1
                   BGE.S    L0488C
                   NEG.W    D6
                   BSR.S    L04862
                   JSR      RI_DIV(PC)
                   BNE.S    L048BE
488C L0488C        BSR.S    L04862
488E L0488E        LSR.W    #1,D6
                   BCC.S    L048AA
                   MOVE.W   FP.EXPNT(A6,A1.L),D5
                   MOVE.L   FP.MNTSA(A6,A1.L),D4
                   JSR      RI_MULT(PC)
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   BNE.S    L048BC
                   MOVE.L   D4,FP.MNTSA(A6,A1.L)
                   MOVE.W   D5,FP.EXPNT(A6,A1.L)
48AA L048AA        TST.W    D6
                   BEQ.S    L048BA
                   JSR      RI_DUP(PC)
                   JSR      RI_MULT(PC)
                   BNE.S    L048BC
                   BRA.S    L0488E

48BA L048BA        MOVEQ    #0,D0
48BC L048BC        ADDQ.W   #FP.LENGTH,A1
48BE L048BE        MOVEM.L  (A7)+,D4-6
                   RTS

Ú----------------------------------------------------------------------¿
³=RI_SUB           SUBTRACT TOS FROM NOS                                       ³
³=RI_ADD           ADD TOS TO NOS                                              ³
Ã----------------------------------------------------------------------´
³RANGE:                                                                        ³
³                                                                              ³
³ENTRY:            D7.L     should be 0 for reliability                        ³
³                  A1.L     relative pointer to top of maths stack             ³
³                                                                              ³
³EXIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          ³
³                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       ³
³                                                                              ³
³ERRORS:           ERR.OV   arithmetic overflow                                ³
À----------------------------------------------------------------------Ù

   On entry the maths stack should contain two floating point numbers as shown
   below:-

        ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
        ³  subtrahend  ³ NOS
        ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
        ³  subtractor  ³ TOS
   A1 ->ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´

   where the subtrahend is the number being subtracted from and the subtractor
   is what is being subtracted. The difference is left on the top of the stack.


48C4 RI_SUB        JSR      RI_NEG(PC)             ;negate TOS first then
                   JMP      RI_ADD(PC)             ;add it to the NOS

48CC L048CC        SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   TST.L    D1
                   BRA.S    L0490A

   On entry the maths stack should contain two floating point numbers as shown
   below:-

        ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
        ³    addend    ³ NOS
        ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
        ³    adder     ³ TOS
   A1 ->ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´

   where the addend is the number being added to and the adder is what is being
   added. The sum is left on the top of the stack. The addition can only be
   performed when the exponents of the two numbers are the same so one of them
   will be readjusted to have the same expoent as the other.

48D2 RI_ADD        ADDQ.W   #FP.LENGTH,A1          ;point A1 at the addend
                   MOVE.W   FP.EXPNT(A6,A1.L),D0   ;get exponent of addend

   conmpare the two exponents of the two numbers and find which is the lesser
   then normalise this to have the same expoent as the other.

                   SUB.W    -FP.LENGTH+FP.EXPNT(A6,A1.L),D0
                   BGE.S    L048F6                 ;jump forward if addend greater than adder

   the addend was less than the adder so check the addend to see how much less
   it actually is.

                   NEG.W    D0                     ;negate difference as this is less than zero
                   CMPI.W   #32,D0                 ;is the adder very much greater than the addend ?
                   BGE.S    L0493E                 ;then exit with the adder as the sum if so
                   MOVE.L   FP.MNTSA(A6,A1.L),D1   ;otherwise get mantissa for addend from adder and
                   BSR.S    L04952                 ;adjust the addend

   copy the exponent into the result and add the mantissas then check the result
   for arithmetic overflow.

                   MOVE.W   -FP.LENGTH+FP.EXPNT(6,A1.L),D0
                   ADD.L    -FP.LENGTH+FP.MNTSA(6,A1.L),D1
                   BRA.S    L0490A

   the addend was greater than the adder so again check by how much.

48F6 L048F6        CMPI.W   #32,D0                 ;is the addend very much greater than the adder ?
                   BGE.S    L0494E                 ;then exit with the addend as the sum if so

   get the mantissa for the adder from addend and adjust the adder.

                   MOVE.L   -FP.LENGTH+FP.MNTSA(6,A1.L),D1
                   BSR.S    L04952

   copy the exponent into the result and add the mantissas then check the result
   for arithmetic overflow.

                   MOVE.W   FP.EXPNT(A6,A1.L),D0
                   ADD.L    FP.MNTSA(A6,A1.L),D1
490A L0490A        BVS.S    L04928                 ;jump forward if overflow occured

   if the answer is zero then use the correct floating point representation for
   zero.

                   BEQ.S    L0493A                 ;form floating point zero
                   MOVE.L   D1,D3
                   ADD.L    D3,D3
                   BVS.S    L04946
                   MOVEQ    #$10,D2
4916 L04916        MOVE.L   D1,D3
                   ASL.L    D2,D3
                   BVS.S    L04922
                   MOVE.L   D3,D1
                   SUB.W    D2,D0
                   BLT.S    L04936
4922 L04922        ASR.L    #1,D2
                   BNE.S    L04916
                   BRA.S    L04946

4928 L04928        ROXR.L   #1,D1                  ;shift mantissa down 
                   ADDQ.W   #1,D0                  ;and increment exponent correspondingly
                   BTST     #12,D0                 ;overflow of exponent ?
                   BEQ.S    L04946                 ;exit if not otherwise
                   MOVEQ    #ERR_OV,D0             ;signal "arithmetic overflow"
                   RTS

4936 L04936        NEG.W    D0
                   ASR.L    D0,D1
493A L0493A        CLR.W    D0                     ;clear the exponent, the mantissa is already zero
                   BRA.S    L04946                 ;and store the result

   get the adder as the result prior to storing.

493E L0493E        MOVE.W   -FP.LENGTH+FP.EXPNT(6,A1.L),D0
                   MOVE.L   -FP.LENGTH+FP.MNTSA(6,A1.L),D1

   store the result into the new top of the stack exponent first then mantissa.

4946 L04946        MOVE.L   D1,FP.MNTSA(A6,A1.L)
                   MOVE.W   D0,FP.EXPNT(A6,A1.L)
494E L0494E        MOVEQ    #0,D0                  ;signal "no errors"
                   RTS

4952 L04952        TST.W    D0                     ;amount of normalisation zero ?
                   BEQ.S    L04964                 ;exit if so
                   ASR.L    D0,D1                  ;normalise mantissa by shifting down

   each downwards shift will result in the loss of accuraccy.

                   BCC.S    L04964                 ;exit if no carry 
                   ADDQ.L   #1,D1                  ;otherwise round up
                   SUBQ.W   #1,D0                  ;
                   BGT.S    L04964
                   BCLR     #0,D1
4964 L04964        RTS

Ú----------------------------------------------------------------------¿
³=RI_MULT          MULTIPLY NOS BY TOS                                         ³
Ã----------------------------------------------------------------------´
³ENTRY:            D7.L     should be 0 for reliability                        ³
³                  A1.L     relative pointer to top of maths stack             ³
³                                                                              ³
³EXIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          ³
³                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       ³
³                                                                              ³
³ERRORS:           ERR.OV   arithmetic overflow                                ³
À----------------------------------------------------------------------Ù

   On entry the maths stack should contain two floating point numbers as shown
   below:-

        ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
        ³ multiplicand ³ NOS
        ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
        ³  multiplier  ³ TOS
   A1 ->ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´

   where the multiplicand is the number being multiplied and the multiplier is
   what it is being multiplied by. The product is left on the top of the stack.

4966 RI_MULT       MOVEM.L  D4-6,-(A7)             ;save the remaining registers
                   SF       D5
                   SF       D6
                   MOVE.L   FP.MNTSA(A6,A1.L),D3
                   BGE.S    L0497C
                   JSR      RI_NEG(PC)
                   MOVE.L   D1,D3
                   ST       D6
497C L0497C        ADDQ.W   #FP.LENGTH,A1
                   MOVE.L   FP.MNTSA(A6,A1.L),D1
                   BGT.S    L0498C
                   BEQ.S    L049EA
                   JSR      RI_NEG(PC)
                   ST       D5
498C L0498C        LSL.L    #1,D1
                   MOVE.L   D1,D0
                   SWAP     D0
                   LSL.L    #1,D3
                   MOVE.L   D3,D2
                   SWAP     D2
                   MOVE.W   D3,D4
                   MULU     D1,D4
                   CLR.W    D4
                   SWAP     D4
                   MULU     D0,D3
                   MULU     D2,D1
                   ADD.L    D4,D3
                   ADD.L    D3,D1
                   MOVE.W   D1,D4
                   CLR.W    D1
                   SWAP     D1
                   ROXR.W   #1,D1
                   ROXL.L   #1,D1
                   MULU     D0,D2
                   MOVE.W   FP.EXPNT(A6,A1.L),D0
                   ADD.W    -FP.LENGTH+FP.EXPNT(6,A1.L),D0
                   SUBI.W   #$0800,D0
                   BLT.S    L049CE
                   ADD.L    D2,D1
                   BMI.S    L049D4
                   BEQ.S    L049CE
                   ASL.L    #1,D4
                   SUBQ.W   #1,D0
                   BGE.S    L049D6
49CE L049CE        CLR.W    D0
                   CLR.L    D1
                   BRA.S    L049DA

49D4 L049D4        LSR.L    #1,D1
49D6 L049D6        MOVEQ    #0,D4
                   ADDX.L   D4D1
49DA L049DA        MOVE.L   D1,FP.MNTSA(A6,A1.L)
                   MOVE.W   D0,FP.EXPNT(A6,A1.L)
                   CMP.B    D5,D6
                   BEQ.S    L049EA
                   JSR      RI_NEG(PC)
49EA L049EA        MOVEM.L  (A7)+,D4-6
                   BTST     #4,FP.EXPNT(A6,A1.L)
                   BNE.S    ERR_OV_4
                   MOVEQ    #0,D0                  ;signal "no errors"
                   RTS

49FA ERR_OV_4      MOVEQ    #ERR_OV,D0             ;signal "arithmetic overflow"
                   RTS

Ú----------------------------------------------------------------------¿
³=RI_DIV           DIVIDE NOS BY TOS                                           ³
Ã----------------------------------------------------------------------´
³ENTRY:            D7.L     should be 0 for reliability                        ³
³                  A1.L     relative pointer to top of maths stack             ³
³                                                                              ³
³EXIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          ³
³                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       ³
³                                                                              ³
³ERRORS:           ERR.OV   arithmetic overflow                                ³
À----------------------------------------------------------------------Ù

   On entry the maths stack should contain two floating point numbers as shown
   below:-

        ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
        ³   dividend   ³ NOS
        ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
        ³   divisor    ³ TOS
   A1 ->ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´

   where the dividend is the number being divided and the divisor is what it is
   being divided by. The quotient is left on the top of the stack.

49FE RI_DIV        MOVEM.L  D4-5,-(A7)             ;save the remaining registers
                   SF       D5
                   MOVE.L   FP.MNTSA(A6,A1.L),D2
                   BGT.S    L04A14
                   BEQ.S    L04A84
                   JSR      RI_NEG(PC)
                   MOVE.L   D1,D2
                   ST       D5
4A14 L04A14        ADDQ.W   #FP.LENGTH,A1
                   MOVE.L   FP.MNTSA(A6,A1.L),D1
                   BGT.S    L04A24
                   BEQ.S    L04A7C
                   JSR      RI_NEG(PC)
                   NOT.B    D5
4A24 L04A24        MOVE.W   FP.EXPNT(A6,A1.L),D0
                   ADDI.W   #$0800,D0
                   SUB.W    -FP.LENGTH+FP.EXPNT(6,A1.L),D0
                   BGE.S    L04A38
                   CLR.W    D0
                   CLR.L    D3
                   BRA.S    L04A6C

4A38 L04A38        BTST     #12,D0
                   BNE.S    ERR_OV_5
                   MOVEQ    #31,D4
                   MOVEQ    #0,D3
4A42 L04A42        SUB.L    D2,D1
                   BCS.S    L04A50
                   BSET     D4,D3
                   ADD.L    D1,D1
                   DBEQ     D4,L04A42
                   BRA.S    L04A58

4A50 L04A50        ADD.L    D2,D1
                   ADD.L    D1,D1
                   DBEQ     D4,L04A42
4A58 L04A58        TST.L    D3
                   BLT.S    L04A64
                   SUB.L    D1,D2
                   BHI.S    L04A6C
                   ADDQ.L   #1,D3
                   BVC.S    L04A6C
4A64 L04A64        ADDQ.W   #1,D0
                   LSR.L    #1,D3
                   MOVEQ    #0,D1
                   ADDX.L   D1,D3
4A6C L04A6C        MOVE.L   D3,FP.MNTSA(A6,A1.L)
                   MOVE.W   D0,FP.EXPNT(A6,A1.L)
                   TST.B    D5
                   BEQ.S    L04A7C
                   JSR      RI_NEG(PC)
4A7C L04A7C        MOVEQ    #0,D0                  ;signal "no errors"
4A7E L04A7E        MOVEM.L  (A7)+,D4-5
                   RTS

4A84 L04A84        ADDQ.W   #FP.LENGTH,A1
4A86 ERR_OV_5      MOVEQ    #ERR_OV,D0             ;signal "arithmetic overflow"
                   BRA.S    L04A7E

Ú----------------------------------------------------------------------¿
³=RI_ABS           TAKE ABSOLUTE VALUE OF TOS                                  ³
³=RI_NEG           NEGATE TOS                                                  ³
Ã----------------------------------------------------------------------´
³ENTRY:            D7.L     should be 0 for reliability                        ³
³                  A1.L     relative pointer to top of maths stack             ³
³                                                                              ³
³EXIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          ³
³                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       ³
³                                                                              ³
³ERRORS:           ERR.OV   arithmetic overflow                                ³
À----------------------------------------------------------------------Ù

4A8A RI_ABS        TST.B    FP.MNTSA(A6,A1.L)      ;mantissa positive or negative ?
                   BGE.S    L04ACA                 ;exit if already positive
4A90 RI_NEG        MOVE.L   FP.MNTSA(A6,A1.L),D1   ;get mantissa
                   NEG.L    D1                     ;and negate it
                   BVS.S    L04AB0                 ;jump forward if overflow occured
                   CMPI.L   #$C0000000,D1          ;sign bit and most significant bit the same ?
                   BNE.S    L04AC6                 ;exit if not as this is the natural state
                   LSL.L    #1,D1                  ;otherwise make them the same
                   SUBQ.W   #1,FP.EXPNT(A6,A1.L)   ;and decrement exponent accordingly
                   BGE.S    L04AC6                 ;exit if exponent ok
                   ASR.L    #1,D1                  ;otherwise reset mantissa
                   CLR.W    FP.EXPNT(A6,A1.L)      ;and clear exponent
                   BRA.S    L04AC6

4AB0 L04AB0        LSR.L    #1,D1                  ;move mantissa up one to ensure bits different
                   ADDQ.W   #1,FP.EXPNT(A6,A1.L)   ;and increment exponent accordingly
                   BTST     #4,FP.EXPNT(A6,A1.L)   ;overflow of exponent ?
                   BEQ.S    L04AC6                 ;exit if not
                   SUBQ.W   #1,FP.EXPNT(A6,A1.L)   ;otherwise restore exponent
                   MOVEQ    #-1,D1                 ;and set mantissa to -1
                   LSR.L    #1,D1                  ;and then +1 with carry taken into account
4AC6 L04AC6        MOVE.L   D1,FP.MNTSA(A6,A1.L)   ;update mantissa
4ACA L04ACA        MOVEQ    #0,D0                  ;signal "no errors"
                   RTS

Ú----------------------------------------------------------------------¿
³=RI_DUP           DUPLICATE TOS                                               ³
Ã----------------------------------------------------------------------´
³ENTRY:            D7.L     should be 0 for reliability                        ³
³                  A1.L     relative pointer to top of maths stack             ³
³                                                                              ³
³EXIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          ³
³                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       ³
³                                                                              ³
³ERRORS:           ERR.OV   arithmetic overflow                                ³
À----------------------------------------------------------------------Ù

4ACE RI_DUP        SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number

   Copy the exponent and the mantissa from the old TOS to the new TOS.

4AD0 L04AD0        MOVE.W   FP.LENGTH+FP.EXPNT(A6,A1.L),FP.EXPNT(A6,A1.L)
                   MOVE.L   FP.LENGTH+FP.MNTSA(A6,A1.L),FP.MNTSA(A6,A1.L)
                   MOVEQ    #0,D0                  ;signal "no errors"
                   RTS

4AE0 L04AE0        MOVE.W   FP.EXPNT(A6,A1.L),D2
                   MOVE.L   FP.MNTSA(A6,A1.L),D1
                   JSR      L04AD0(PC)
                   MOVE.W   D2,FP.LENGTH+FP.EXPNT(A6,A1.L)
                   MOVE.L   D1,FP.LENGTH+FP.MNTSA(A6,A1.L)
                   MOVEQ    #0,D0                  ;signal "no errors"
                   RTS


;part14
2.18 Peripheral and SuperBASIC initialisation.

Ú----------------------------------------------------------------------¿
³=CHKPROMS         CHECK FOR PERIPHERAL ROMS                                   ³
Ã----------------------------------------------------------------------´
³JOB:                                                                          ³
Ã----------------------------------------------------------------------´
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³                                                                              ³
³ERRORS:                                                                       ³
À----------------------------------------------------------------------Ù

4AF8 CHKPROMS      BRA.S    L04B2E

4AFA L04AFA        CMPI.L   #$4AFB0001,(A3)        ;any ROMS ?
                   BNE.S    L04B22                 ;exit if no ROM exists in the first ROM slot
                   LEA      ROM.NAME(A3),A1        ;point at the start of the ROM name
                   JSR      UT_MTEXT(PC)           ;and print it
                   MOVE.W   ROM.PROC(A3),D0        ;get word offset to procedures and functions list
                   BEQ.S    L04B18                 ;and jump forward if no list otherwise
                   LEA      0(A3,D0.W),A1          ;point at the procedures and functions list
                   JSR      BP_INIT(PC)            ;and add them to SuperBASIC if any present
4B18 L04B18        MOVE.W   ROM.INIT(A3),D0        ;get word offset to initialisation routine
                   BEQ.S    L04B22                 ;and exit if there isn't one
                   JSR      0(A3,D0.W)             ;otherwise call it
4B22 L04B22        RTS

4B24 L04B24        JSR      UT_CON(PC)
4B28 L04B28        MOVE.L   D4,D1
                   JMP      L060A0(PC)

4B2E L04B2E        JSR      L050F6(PC)             ;initialise the SuperBASIC data structures
4B32 L04B32        LEA      CON_I_0(PC),A1         ;point at definition block for ROM messages window
                   MOVEQ    #0,D4
                   BSR.S    L04B24                 ;open the window
                   MOVEA.L  #$C000,A3              ;A3 points at start of external ROM slot in memory
                   BSR.S    L04AFA                 ;check for the presence of an external ROM here
                   MOVEA.L  #$C0000,A3             ;A3 points at start of first peripheral ROM slot
4B48 L04B48        BSR.S    L04AFA                 ;check for the presence of a peripheral ROM here
    a               ADDA.W   #$4000,A3              ;point at next slot 
    e               CMPA.L   #$100000,A3            ;after last slot ?

   The following instruction should have been BLT.S because the code is only
   excecuted once with the BGE.S instruction and this prevents any further
   peripheral ROM's being searched for and initialised. 

    54               BGE.S    L04B48                 ;no check for more ROM's

   The procedures and functions which are used to extend the interpreter are
   added during the initialisation stage. The external ROM and the peripheral
   ROM's are allowed to add their definitions first so that their definitions
   take precedence over the SuperBASIC ones. They take precedence because the
   interpreter searches through the name list from the beginning when parsing
   a line or command and so it will come across and use the first definition 
   it finds and will therfore ignore any further ones.

    4b56               JSR      SB_INIT(PC)            ;add in the SuperBASIC procedures and functions
    5a               LEA      CON_I_1(PC),A1         ;point at definition block for copyright message
                   MOVEQ    #1,D4
                   BSR.S    L04B24                 ;open the window
                   LEA      COPYRIGHT(PC),A1       ;point at copyright message
                   JSR      UT_MTEXT(PC)           ;and print it
                   LEA      CON_I_2(PC),A1         ;point at definition block for "F1/F2" prompt window
                   MOVEQ    #2,D4
                   BSR.S    L04B24                 ;open the window
                   LEA      F1F2_MESS(PC),A1       ;point at "F1/F2" prompt message
                   JSR      UT_MTEXT(PC)           ;and print it
4B7A L04B7A        MOVEQ    #IO.FBYTE,D0           ;TRAP to fetch a byte
                   MOVEQ    #-1,D3                 ;use an infinite timeout
                   TRAP     #3                     ;wait for a single key press
                   MOVEQ    #0,D6                  ;set display mode to 0 giving 4 colours
                   MOVEQ    #0,D7                  ;in monitor mode
                   MOVEQ    #$20,D5
                   SUBI.B   #$E8,D1                ;subtract code for F1 key
                   BEQ.S    L04B96                 ;and jump forward if the F1 key was pressed
                   SUBQ.B   #4,D1                  ;check for the F4 key
                   BNE.S    L04B7A                 ;get another key press if it wasn't F2 either
                   MOVEQ    #8,D6                  ;set display mode to 8 giving 8 colours
                   MOVEQ    #1,D7                  ;in tv mode
                   MOVEQ    #$44,D5
4B96 L04B96        MOVE.B   D6,D1                  ;get display mode
                   MOVE.B   D7,D2                  ;and display type
                   MOVEQ    #MT.DMODE,D0           ;TRAP to read or set the display mode
                   TRAP     #1                     ;set it

   If thee F1 key was pressed then the following instructions will open the
   windows defined in the parameter blocks for the mode 4 windows. If the F2
   key was pressed instead then the windows defined in the parameter blocks
   for the mode 8 windows will be opened in their place.

                   LEA      CONM4_2-32(PC,D5.W),A1 ;point at definition block for channel 2
                   BSR.S    L04BF6                 ;open the window
                   MOVEA.L  #$00010001,A0          ;channel ID for channel 1
                   LEA      CONM4_1-32(PC,D5.W),A1 ;point at definition block for channel 1
                   BSR.S    L04BF6                 ;open the window
                   SUBA.L   A0,A0                  ;form channel ID for channel ($00000000)
                   LEA      CONM4_0-32(PC,D5.W),A1 ;point at definition block for channel 0
                   BSR.S    L04BF6                 ;open the window

                   LEA      L04C9E(PC),A0          ;point at "BOOT" device name
                   BSR.S    L04BCE                 ;try and open a channel to a device with this name
                   BEQ.S    L04BC8                 ;jump forward if successful otherwise
                   LEA      L04CA4(PC),A0          ;point at microdrive one boot file name
                   BSR.S    L04BCE                 ;and try and open a channel to this instead
                   BNE.S    L04BDA                 ;and jump forward if unsuccessful
4BC8 L04BC8        CLR.W    BV,NXLIN(A6)           ;signal "no program"
                   BRA.S    L04BDC                 ;jump forward to interpreter

4BCE L04BCE        MOVEQ    #IO.OPEN,D0            ;TRAP to open a channel
4BD0 L04BD0        MOVEQ    #-1,D1                 ;for this job
                   MOVEQ    #0,D3                  ;to an old exclusive file
                   TRAP     #2                     ;open it
                   TST.L    D0                     ;set flags to signal any errors
                   RTS

4BDA L04BDA        SUBA.L   A0,A0
4BDC L04BDC        MOVE.L   (A6),BV.BFP(A6)        ;empty out any existing basic program
4BE0 L04BE0        MOVEQ    #0,D7
                   MOVEQ    #$7E,D1
                   JSR      CA_ALBFP(PC)
                   MOVE.L   A0,BV.COMCH(A6)        ;set SuperBASIC command channel ID
                   LEA      L04CB0(PC),A5
                   MOVE.L   A5,-(A7)
4BF2 L04BF2        JMP      L04CC4(PC)

4BF6 L04BF6        JMP      L03A70(PC)

   The following data blocks define the three mode 4 windows which will become
   channels #0,#1 and #2 respectively.

4BFA CONM4_0       DC.B     0                      ;no border
                   DC.B     0
                   DC.B     0                      ;black paper
                   DC.B     7                      ;green ink
                   DC.W     512                    ;512 pixels wide and
                   DC.W     50                     ;50 pixels high
                   DC.W     0                      ;at 2,206
                   DC.W     206

4C06 CONM4_1       DC.B     $FF                    ;black and white checkerboard border
                   DC.B     1                      ;one pixel wide
                   DC.B     2                      ;red paper
                   DC.B     7                      ;white ink
                   DC.W     256                    ;256 pixels wide and
                   DC.W     202                    ;202 pixels high
                   DC.W     256                    ;at 256,0
                   DC.W     0

4C12 CONM4_2       DC.B     $FF                    ;black and white checkerboard border
                   DC.B     1                      ;one pixel wide
                   DC.B     7                      ;white paper
                   DC.B     2                      ;red ink
                   DC.W     256                    ;256 pixels wide and
                   DC.W     202                    ;202 pixels high
                   DC.W     0                      ;at 0,0
                   DC.W     0

   The following data blocks define the three mode 8 windows which will become
   channels #0,#1 and #2 respectively.

4C1E CONM8_0       DC.B     0                      ;no border
                   DC.B     0
                   DC.B     0                      ;black paper
                   DC.B     7                      ;green ink
                   DC.W     448                    ;448 pixels wide and
                   DC.W     40                     ;40 pixels high
                   DC.W     32                     ;at 32,216
                   DC.W     216

4C2A CONM8_1       DC.B     0                      ;no border
                   DC.B     0
                   DC.B     2                      ;red paper
                   DC.B     7                      ;white ink
                   DC.W     448                    ;448 pixels wide and
                   DC.W     216                    ;216 pixels high
                   DC.W     32                     ;at 32,16
                   DC.W     16

4C36 CONM8_2       DC.B     0                      ;no border
                   DC.B     0
                   DC.B     1                      ;blue paper
                   DC.B     7                      ;white ink
                   DC.W     448                    ;448 pixels wide and
                   DC.W     216                    ;216 pixels high
                   DC.W     32                     ;at 32,16
                   DC.W     16

   The following data blocks define the three mode 8 windows which are printed
   at initialisation for the external ROM names, the Sinclair copyright message
   and the "F1/F2" prompt respectively.

4C42 CON_I_0       DC.B     0                      ;no border
                   DC.B     0
                   DC.B     0                      ;black paper
                   DC.B     4                      ;green ink
                   DC.W     448                    ;448 pixels wide and
                   DC.W     170                    ;170 pixels high
                   DC.W     32                     ;at 32,32
                   DC.W     32

4C4E CON_I_1       DC.B     7                      ;white border
                   DC.B     2                      ;two pixels wide
                   DC.B     2                      ;red paper
                   DC.B     7                      ;white ink
                   DC.W     368                    ;368 pixels wide and
                   DC.W     14                     ;14 pixels high
                   DC.W     72                     ;at 72,238
                   DC.W     238

4C5A CON_I_2       DC.B     4                      ;green border
                   DC.B     4                      ;four pixels wide
                   DC.B     7                      ;white paper
                   DC.B     2                      ;red ink
                   DC.W     168                    ;168 pixels wide and
                   DC.W     28                     ;28 pixels high
                   DC.W     174                    ;at 174,206
                   DC.W     206

4C66 COPYRIGHT     DC.B     0,29,'  1983 Sinclair Research Ltd',0
4C86 F1F2_MESS     DC.B     0,21,'F1...monitor',10,'F2...TV',10,0
4C9E L04C9E        DC.B     0,4,'BOOT'
4CA4 L04CA4        DC.B     0,9,'MDV1_BOOT',10

4CB0 L04CB0        JSR      L09F92(PC)
                   LEA      L04CB0(PC),A5	;push the address of this routine on the stack
                   MOVE.L   A5,-(A7)            ;so that it is always executed on restarting
4CBA L04CBA        MOVE.L   D7,BV.COMCH(A6)     ;set SuperBASIC command channel ID
                   MOVEQ    #0,D1               ;SuperBASIC channel number equals zero
                   JSR      GETCHID(PC)         ;get the QDOS channel ID for this channel
4CC4 L04CC4        CLR.L    BV.SSSAV(A6)
                   MOVE.L   (A6),BV.BFP(A6)
                   TST.B    BV.AUTO(A6)
                   BEQ.S    L04CEC
                   MOVE.W   BV.EDLIN(A6),D4
                   MOVE.W   D4,D6
                   SF       BV.PRINT(A6)
                   JSR      L06E68(PC)
                   MOVE.W   BV.EDINC(A6),D0
                   SNE      BV.AUTO(A6)
                   ADD.W    D0,BV.EDLIN(A6)				aspetta riga comando... forse...
4CEC L04CEC        MOVEQ    #0,D4
4CEE L04CEE        MOVEQ    #4,D0
                   TRAP     #4
                   MOVEQ    #-1,D3                 ;use an infinite timeout
                   MOVEA.L  BV.BFP(A6),A1
                   MOVE.L   BV.TKBAS(A6),D2
                   SUB.L    (A6),D2
4CFE L04CFE        MOVE.L   A1,D1
                   SUB.L    (A6),D1
                   MOVE.W   D1,D4
                   MOVE.L   D4,D1
4D06 L04D06        CMP.L    A0,D7
                   BEQ.S    L04D0E
                   MOVEQ    #2,D0
                   SUB.W    D1,D2
4D0E L04D0E        TRAP     #3
                   TST.L    D0					esce con 0 dopo comando LIST
                   BEQ.S    L04D5E
                   BGT.S    L04D34
                   CMPI.B   #$F6,D0
                   BEQ.S    L04D4A
                   CMPI.B   #$FB,D0
                   BNE.S    L04D34
                   MOVE.L   D1,D4
                   MOVE.L   A1,BV.BFP(A6)
                   MOVE.L   A0,-(A7)
                   MOVEQ    #$7E,D1
                   JSR      CA_ALBFP(PC)
                   MOVEA.L  (A7)+,A0
                   BRA.S    L04CEE

4D34 L04D34        SF       BV.AUTO(A6)
4D38 L04D38        JSR      L092EC(PC)
4D3C L04D3C        BSR      L04DF4
                   BEQ.S    L04D46
                   MOVEQ    #2,D0
                   TRAP     #2
4D46 L04D46        BRA      L04CBA

4D4A L04D4A        MOVEQ    #2,D0
4D4C L04D4C        TRAP     #2
                   MOVE.L   D7,BV.COMCH(A6)
                   TST.W    BV.NXLIN(A6)
                   BLT      L04E64
                   BRA      L04E98

4D5E L04D5E        TAS      BV.BRK(A6)
4D62 L04D62        MOVE.L   A1,D1
                   SUB.L    (A6),D1
                   SF       BV.ARROW(A6)
                   MOVE.B   -1(A6,A1.L),D0
                   SUBI.B   #$D0,D0
                   BCS.S    L04D80
                   ST       BV.ARROW(A6)
                   BEQ.S    L04D80
                   MOVE.B   #1,BV.ARROW(A6)
4D80 L04D80        SUBQ.W   #1,D1
                   BLE      L04CC4
                   CMPI.B   #$20,-2(A6,A1.L)
                   BNE.S    L04D92
                   SUBQ.W   #1,A1
                   BRA.S    L04D80

4D92 L04D92        MOVE.B   #10,-1(A6,A1.L)
4D98 L04D98        MOVE.L   A1,BV.BFP(A6)
4D9C L04D9C        JSR      L080EE(PC)
                   LEA      L0833C(PC),A2
                   JSR      L07FB6(PC)
                   BEQ.S    L04DCA
                   BLT.S    L04DB2
                   JSR      L08F9A(PC)
                   BRA.S    L04D9C

4DB2 L04DB2        TST.L    BV.COMCH(A6)
4DB6 L04DB6        BNE.S    L04DC6
                   MOVEQ    #-$15,D0
                   JSR      L092EC(PC)
                   SUBQ.L   #1,BV.BFP(A6)
                   BRA      L04CEC

4DC6 L04DC6        JSR      L08230(PC)
4DCA L04DCA        JSR      L08296(PC)
4DCE L04DCE        JSR      L08674(PC)
                   BRA.S    L04DFC

4DD4 L04DD4        SF       BV.SING(A6)
                   ST       BV.EDIT(A6)
                   MOVE.L   D0,D5
                   BSR.S    L04DF4
                   BNE      L04CC4
                   MOVEQ    #2,D1
                   JSR      GETCHID(PC)
                   BLT.S    L04DF0
                   JSR      L087D2(PC)
4DF0 L04DF0        BRA      L04CBA

4DF4 L04DF4        MOVEA.L  BV.COMCH(A6),A0
4DF8 L04DF8        MOVE.L   A0,D0
                   RTS

4DFC L04DFC        MOVEA.L  BV.TKBAS(A6),A4
4E00 L04E00        MOVE.B   #1,BV.STMNT(A6)
                   SF       BV.INLIN(A6)
                   ST       BV.CONT(A6)
4E0E L04E0E        ST       BV.SING(A6)
                   MOVE.L   D7,BV.LINUM(A6)
                   JSR      L09AE0(PC)
                   JSR      L09EC8(PC)
                   BNE      L04D3C
                   TST.B    BV.COMLN(A6)
                   BEQ.S    L04E58
                   SUBQ.W   #4,BV.STOPN(A6)
                   BEQ.S    L04DF0
                   BLT.S    L04E0E
                   MOVEA.L  BV.TKBAS(A6),A0
                   MOVE.L   BV.TKP(A6),D0
                   SUBA.L   A0,A4
                   SUB.L    A0,D0
                   MOVE.L   D0,D1
                   SUBA.L   D0,A7
4E40 L04E40        MOVE.W   0(A6,A0.L),(A7)+
                   ADDQ.W   #2,A0
                   SUBQ.W   #2,D1
                   BGT.S    L04E40
                   SUBA.L   D0,A7
                   MOVE.W   D0,-(A7)
                   MOVE.W   A4,-(A7)
                   MOVE.B   BV.STMNT(A6),-(A7)
                   MOVE.L   BV.INLIN(A6),-(A7)
4E58 L04E58        TST.W    BV.NXLIN(A6)
                   BGE.S    L04E92
                   BSR.S    L04DF4
4E60 L04E60        BNE      L04CC4
4E64 L04E64        TST.B    BV.COMLN(A6)
                   BEQ.S    L04DF0
                   SF       BV.COMLN(A6)
                   MOVE.L   (A7)+,BV.INLIN(A6)
                   MOVE.B   (A7)+,BV.STMNT(A6)
                   MOVEA.L  BV.TKBAS(A6),A0
                   MOVEA.L  A0,A4
                   ADDA.W   (A7)+,A4
                   MOVE.W   (A7)+,D0
4E80 L04E80        MOVE.W   (A7)+,0(A6,A0.L)
                   ADDQ.W   #2,A0
                   SUBQ.W   #2,D0
                   BGT.S    L04E80
                   MOVE.L   A0,BV.TKP(A6)
                   BRA      L04E0E

4E92 L04E92        BSR      L04DF4
4E96 L04E96        BNE.S    L04E60
4E98 L04E98        JSR      L09AE0(PC)
                   MOVEA.L  BV.PFBAS(A6),A4
                   SF       BV.SING(A6)
                   MOVE.L   D7,BV.LINUM(A6)
                   MOVE.B   #1,BV.STMNT(A6)
                   MOVE.W   BV.NXLIN(A6),D4
                   BEQ.S    L04ED0
                   JSR      L096B0(PC)
                   BNE      L04CBA
                   MOVE.B   BV.NXSTM(A6),D4
                   BEQ.S    L04ED0
                   JSR      L09F46(PC)
                   JSR      L096FC(PC)
4ECA L04ECA        JSR      L09F1C(PC)
                   BRA.S    L04ED4

4ED0 L04ED0        JSR      L09EBA(PC)
4ED4 L04ED4        BNE      L04CBA
4ED8 L04ED8        TST.W    BV.STOPN(A6)
                   BNE      L04E58
                   BRA.S    L04ECA

4EE2 L04EE2        JSR      CA_ALNTP(PC)
                   MOVEA.L  BV.NTP(A6),A2
                   ADDQ.L   #8,BV.NTP(A6)
                   RTS

4EF0 L04EF0        MOVE.L   D1,-(A7)
4EF2 L04EF2        ADDQ.L   #7,D1
                   ANDI.W   #$FFF8,D1
4EF8 L04EF8        MOVEA.W  #$72,A0
                   MOVEQ    #12,D0
                   TRAP     #1
                   TST.L    D0
                   BLT.S    L04F06
                   BRA.S    L04F20

4F06 L04F06        MOVE.L   D1,-(A7)
4F08 L04F08        JSR      CA_ALVVP(PC)
                   MOVEA.L  BV.VVP(A6),A0
                   ADD.L    D1,BV.VVP(A6)
                   MOVEA.W  #$72,A1
                   MOVEQ    #13,D0
                   TRAP     #1
                   MOVE.L   (A7)+,D1
                   BRA.S    L04EF8

4F20 L04F20        MOVE.L   (A7)+,D1
4F22 L04F22        RTS

4F24 L04F24        DC.W     $0100,$0100
                   DC.W     $0100,$0100

4F2C L04F2C        LEA      L04F24(PC),A1
                   ADD.W    D0,D0
                   MOVEQ    #0,D1
                   MOVE.W   0(A1,D0.W),D1
                   MOVEQ    #$60,D2
                   MOVE.L   A7,BV.SSP(A6)
                   MOVE.L   A6,D0
                   SUB.L    D0,BV.SSP(A6)
                   BRA.S    CA_ALSBS               ;allocate space on basic stack

2.19 SuperBASIC stack management.

Ú----------------------------------------------------------------------¿
³=CA_ALRIP         RESERVE SPACE ON MATHS STACK 2                              ³
³=BV_CHRIX         RESERVE SPACE ON MATHS STACK                                ³
³=BV_ALBTP         ALLOCATE SPACE ON BACKTRACK STACK                           ³
³=BV_ALTGP         ALLOCATE SPACE ON TEMPORARY GRAPH STACK                     ³
Ã----------------------------------------------------------------------´
³JOB:                                                                          ³
Ã----------------------------------------------------------------------´
³ENTRY:           D1.L     the number of bytes required if BV_CHRIX            ³
³                                                                              ³
³EXIT:            A0,A1,A2,A3 preserved                                        ³
³                 D1,D2,D3 corrupted                                           ³
³                                                                              ³
³ERRORS:          none                                                         ³
À----------------------------------------------------------------------Ù

   Each call to the following routines allocates enough space on the appropriate
   stack for one element or record of the type which normally exists on that
   stack. 

4F46 CA_ALRIP      MOVEQ    #32,D1                 ;reserve 32 bytes
4F48 BV_CHRIX      MOVEQ    #BV.RIP,D2             ;on the maths stack
                   BRA.S    CA_ALSBS

4F4C CA_ALBTP      MOVEQ    #12,D1                 ;reserve 12 bytes
                   MOVEQ    #BV.BTP,D2             ;on the back track stack
                   BRA.S    CA_ALSBS

4F52 CA_ALTGP      MOVEQ    #4,D1                  ;reserve 4 bytes
                   MOVEQ    #BV.TGP,D2             ;on the temporary graph stack
                   BRA.S    CA_ALSBS

Ú----------------------------------------------------------------------¿
³=CA_ALNTP         ALLOCATE SPACE IN NAME TABLE                                ³
³=CA_ALRTP         ALLOCATE SPACE IN RETURN STACK                              ³
³=CA_ALBFP         ALLOCATE SPACE IN BUFFER                                    ³
³=CA_ALTKP         ALLOCATE SPACE IN TOKEN TABLE                               ³
³=CA_ALNLP         ALLOCATE SPACE IN NAME LIST                                 ³
³=CA_ALVVP         ALLOCATE SPACE IN VARIABLE VALUES                           ³
³=CA_ALCHB         RESERVE SPACE IN SUPERBASIC CHANNEL TABLE                   ³
³=CA_ALLNP         ALLOCATE SPACE IN LINE NUMBER TABLE                         ³                                  ³
³=CA_ALPFP         ALLOCATE SPACE IN PROGRAM FILE                              ³
³=CA_ALSBT         ALLOCATE SPACE IN SUPERBASIC TABLE                          ³
Ã----------------------------------------------------------------------´
³JOB:                                                                          ³
Ã----------------------------------------------------------------------´
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³                                                                              ³
³ERRORS:                                                                       ³
À----------------------------------------------------------------------Ù

4F58 CA_ALNTP      MOVEQ    #8,D1                  ;reserve 8 bytes
                   MOVEQ    #BV.NTP,D2             ;in the name table
                   BRA.S    CA_ALSBT

4F5E CA_ALRTP      MOVEQ    #22,D1                 ;reserve 22 bytes
                   MOVEQ    #BV.RTP,D2             ;in the return stack
                   BRA.S    CA_ALSBT

4F64 CA_ALBFP      MOVEQ    #BV.BFP,D2             ;reserve D1.L bytes
                   BRA.S    CA_ALSBT               ;in the buffer

4F68 CA_ALTKP      MOVEQ    #BV.TKP,D2             ;reserve D1.L bytes
                   BRA.S    CA_ALSBT               ;in the token table

4F6C CA_ALNLP      MOVEQ    #BV.NLP,D2             ;reserve D1.L bytes
                   BRA.S    CA_ALSBT               ;in the name list

4F70 CA_ALVVP      MOVEQ    #BV.VVP,D2             ;reserve D1.L bytes
                   BRA.S    CA_ALSBT               ;in the variable values area

4F74 CA_ALCHB      MOVEQ    #BV.CHP,D2             ;reserve D1.L bytes
                   BRA.S    CA_ALSBT               ;in the SuperBASIC channel table

4F78 CA_ALLNP      MOVEQ    #BV.LNP,D2             ;reserve D1.L bytes
                   BRA.S    CA_ALSBT               ;in the line number table

4F7C CA_ALPFP      MOVEQ    #BV.PFP,D2             ;reserve D1.L bytes in the program file
4F7E CA_ALSBT      MOVEQ    #0,D0                  ;
   4f80                MOVE.L   4(A6,D2.L),D3          ;get the address of the start of the area above
   4f84                SUB.L    0(A6,D2.L),D3          ;and form the length of the area to move
   4f88                BRA.S    L04F94

4F8A CA_ALSBS      MOVEQ    #-1,D0
4F8C L04F8C        MOVE.L   0(A6,D2.L),D3
                   SUB.L    -4(A6,D2.L),D3
4F94 L04F94        CMP.L    D1,D3
                   BGE.S    L04FDC
                   MOVEM.L  A0-3,-(A7)
  4f9c                 ADDI.L   #15,D1
                   ANDI.W   #$FFF0,D1
4FA6 L04FA6        MOVE.L   BV.CHANG(A6),D3
                   SUB.L    BV.LNBAS(A6),D3
                   CMP.L    D1,D3
  4fb0                 BGT.S    L0500E
                   MOVEM.L  D0-2,-(A7)
                   MOVEQ    #$16,D0
                   TRAP     #1
                   TST.L    D0
                   BEQ.S    L04FDE
  4fbe                 MOVE.W   #$12,BV.STOPN(A6)
                   TRAP     #0
                   MOVEA.L  BV.SSBAS(A6),A5
                   ADDA.L   A6,A5
  4fcc                 SUBA.L   BV.SSSAV(A6),A5
                   SUBQ.W   #4,A5
                   MOVE.L   A5,USP
                   MOVE.W   #4,SR
                   SF       BV.CONT(A6)
4FDC L04FDC        RTS

4FDE L04FDE        MOVEA.L  BV.CHANG(A6),A0
4FE2 L04FE2        MOVEA.L  BV.SSBAS(A6),A1
                   LEA      0(A1,D1.L),A2
4FEA L04FEA        SUBQ.W   #4,A2
                   SUBQ.W   #4,A1
                   MOVE.L   0(A6,A1.L),0(A6,A2.L)
                   CMPA.L   A0,A1
                   BGT.S    L04FEA
                   MOVEQ    #$48,D0
                   MOVEQ    #$64,D2
4FFC L04FFC        ADD.L    D1,0(A6,D0.L)
                   ADDQ.W   #4,D0
                   CMP.L    D2,D0
                   BLE.S    L04FFC
                   ADDA.L   D1,A7
                   MOVEM.L  (A7)+,D0-2
                   BRA.S    L04FA6

500E L0500E        TST.B    D0
5010 L05010        BMI.S    L0504E
                   CMPI.L   #$44,D2
                   BEQ.S    L0507E
                   MOVEA.L  BV.LNBAS(A6),A1
                   MOVEA.L  4(A6,D2.L),A0
                   LEA      0(A1,D1.L),A2
5026 L05026        SUBQ.W   #4,A1
                   SUBQ.W   #4,A2
                   MOVE.L   0(A6,A1.L),0(A6,A2.L)
                   CMPA.L   A0,A1
                   BGT.S    L05026
                   MOVEQ    #4,D0
                   ADD.W    D2,D0
                   MOVEQ    #$48,D2
                   TST.L    BV.VVFRE(A6)
                   BEQ.S    L05074
                   CMPI.L   #$28,D0
                   BGT.S    L05074
                   ADD.L    D1,BV.VVFRE(A6)
                   BRA.S    L05074

504E L0504E        CMPI.L   #$48,D2
5054 L05054        BEQ.S    L0507E
                   MOVEA.L  -4(A6,D2.L),A1
                   MOVEA.L  BV.CHANG(A6),A0
                   NEG.L    D1
                   LEA      0(A0,D1.L),A2
5064 L05064        MOVE.L   0(A6,A0.L),0(A6,A2.L)
                   ADDQ.W   #4,A0
                   ADDQ.W   #4,A2
                   CMPA.L   A1,A0
                   BLE.S    L05064
                   MOVEQ    #$48,D0
5074 L05074        ADD.L    D1,0(A6,D0.L)
                   ADDQ.W   #4,D0
                   CMP.L    D2,D0
                   BLT.S    L05074
507E L0507E        MOVEM.L  (A7)+,A0-3
                   RTS

5084 CA_REPFP      MOVEQ    #BV.PFP,D2
                   BRA.S    CA_RESBT

5088 CA_RENLP      MOVEQ    #BV.NLP,D2
                   BRA.S    CA_RESBT

508C CA_RENTP      MOVEQ    #BV.NTP,D2
                   BRA.S    CA_RESBT

5090 CA_REVVP      MOVEQ    #BV.VVP,D2
                   BRA.S    CA_RESBT

5094 CA_RECHP      MOVEQ    #BV.CHP,D2
                   BRA.S    CA_RESBT

5098 CA_RERTP      MOVEQ    #BV.RTP,D2
509A CA_RESBT      MOVEA.L  4(A6,D2.L),A1          ;get base of area above
                   MOVE.L   A1,D1
                   MOVE.L   0(A6,D2.L),D0          ;get running pointer
                   ADDQ.W   #1,D0
                   BCLR     #0,D0
                   MOVEA.L  D0,A0
                   SUB.L    A0,D1                  ;find length
                   BEQ.S    L050E0                 ;and exit if zero

   Shift area above location pointed to by A1.L to location pointed to by A0.L.

50B0 L050B0        MOVE.L   0(A6,A1.L),0(A6,A0.L)  ;move area down
                   ADDQ.W   #4,A1                  ;increment pointers
                   ADDQ.W   #4,A0
                   CMPA.L   BV.LNBAS(A6),A1        ;last long word ?
                   BLT.S    L050B0                 ;move more if not

                   MOVEQ    #4,D0
                   ADD.B    D2,D0
                   TST.L    BV.VVFRE(A6)
                   BEQ.S    L050D4
                   CMPI.B   #$28,D2
                   BGE.S    L050D4
                   SUB.L    D1,BV.VVFRE(A6)
50D4 L050D4        MOVEQ    #$48,D2
50D6 L050D6        SUB.L    D1,0(A6,D0.L)
                   ADDQ.B   #4,D0
                   CMP.B    D2,D0
                   BLT.S    L050D6
50E0 L050E0        RTS

50E2 L050E2        ADDQ.L   #7,D1
50E4 L050E4        ANDI.L   #$FFFFFFF8,D1
                   BEQ.S    L050F4
                   MOVEA.W  #$72,A1
                   MOVEQ    #13,D0
                   TRAP     #1
50F4 L050F4        RTS

50F6 L050F6        SUBA.L   A3,A3
50F8 L050F8        MOVEQ    #$48,D0
50FA L050FA        MOVE.L   #$100,0(A6,A3.L)
                   ADDQ.W   #4,A3
                   CMPA.W   D0,A3
                   BLT.S    L050FA
                   MOVEQ    #$64,D0
510A L0510A        MOVE.L   A5,0(A6,A3.L)
                   ADDQ.W   #4,A3
                   CMPA.W   D0,A3
                   BLE.S    L0510A
                   DC.W     $51EE,$006E
                   DC.W     $50EE,$006D
                   DC.W     $50EE,$0082
                   DC.W     $51EE,$00AA
                   DC.W     $50EE,$00AB
                   MOVE.W   #$FFFF,BV.NXLIN(A6)
                   CLR.L    BV.COMCH(A6)
                   MOVEQ    #0,D0
                   MOVE.L   D0,BV.VVFRE(A6)
                   JMP      L04F2C(PC)

513C L0513C        MOVEA.L  BV.CHANG(A6),A1
                   MOVE.L   A1,D1
                   SUB.L    BV.LNBAS(A6),D1
                   ANDI.L   #$FFFFFE00,D1
                   BEQ.S    L05176
                   MOVEA.L  A1,A0
                   SUBA.L   D1,A0
5152 L05152        MOVE.L   0(A6,A1.L),0(A6,A0.L)
                   ADDQ.W   #4,A1
                   ADDQ.W   #4,A0
                   CMPA.L   BV.SSBAS(A6),A1
                   BLT.S    L05152
                   MOVEQ    #$48,D0
                   MOVEQ    #$64,D2
5166 L05166        SUB.L    D1,0(A6,D0.L)
                   ADDQ.B   #4,D0
                   CMP.B    D2,D0
                   BLE.S    L05166
                   SUBA.L   D1,A7
                   MOVEQ    #$17,D0
                   TRAP     #1
5176 L05176        RTS

5178 L05178        CMPA.L   BV.NTP(A6),A5
517C L0517C        BNE.S    L05182
                   MOVE.L   A3,BV.NTP(A6)
5182 L05182        CMPA.L   A5,A3
                   BGE      L05264
                   ANDI.B   #%00001111,1(A6,A3.L)
                   BEQ.S    L051EE
                   CMPI.W   #-1,2(A6,A3.L)
                   BNE.S    L0519E
                   MOVEA.L  A3,A2
                   BSR.S    L051FA
                   BRA.S    L051EE

519E L0519E        MOVEQ    #1,D0
51A0 L051A0        SUB.B    0(A6,A3.L),D0
                   BGE.S    L051EE
                   MOVE.W   2(A6,A3.L),D0
                   LSL.L    #3,D0
                   MOVEA.L  BV.NTBAS(A6),A2
                   ADDA.L   D0,A2
                   CMPI.B   #3,0(A6,A2.L)
                   BNE.S    L051E2
                   CMPI.B   #2,0(A6,A3.L)
                   BEQ.S    L051EE
                   MOVEA.L  BV.BFP(A6,A3.L),A0
                   ADDA.L   BV.VVBAS(A6),A0
                   MOVEQ    #0,D1
                   MOVE.W   BV.BFP(A6,A0.L),D1
                   LSL.W    #2,D1
                   ADDQ.W   #6,D1
                   MOVEM.L  D2/A1-3,-(A7)
                   JSR      L050E2(PC)
                   MOVEM.L  (A7)+,D2/A1-3
                   BRA.S    L051EE

51E2 L051E2        MOVE.L   4(A6,A3.L),4(A6,A2.L)
51E8 L051E8        MOVE.B   0(A6,A3.L),0(A6,A2.L)
51EE L051EE        MOVE.L   D7,0(A6,A3.L)
                   MOVE.L   D7,4(A6,A3.L)
                   ADDQ.W   #8,A3
                   BRA.S    L05182

51FA L051FA        MOVEM.L  D2/D4/D6/A1-3,-(A7)
51FE L051FE        MOVEA.L  BV.VVBAS(A6),A0
                   MOVE.L   4(A6,A2.L),D1
                   BLT.S    L0525E
                   ADDA.L   D1,A0
                   MOVE.B   0(A6,A2.L),D0
                   SUBQ.B   #2,D0
                   BLE.S    L05236
                   SUBQ.B   #1,D0
                   BNE.S    L05222
                   MOVE.L   D1,D4
                   MOVE.B   1(A6,A2.L),D6
                   JSR      L091CC(PC)
                   BRA.S    L0525E

5222 L05222        SUBQ.B   #3,D0
5224 L05224        BEQ.S    L05232
                   SUBQ.B   #1,D0
                   BEQ.S    L0522E
                   MOVEQ    #-12,D0
                   BRA.S    L05260

522E L0522E        MOVEQ    #$1A,D1
5230 L05230        BRA.S    L05252

5232 L05232        MOVEQ    #12,D1
5234 L05234        BRA.S    L05252

5236 L05236        MOVE.B   1(A6,A2.L),D0
523A L0523A        SUBQ.B   #2,D0
                   BLT.S    L05248
                   BEQ.S    L05244
                   MOVEQ    #2,D1
                   BRA.S    L05252

5244 L05244        MOVEQ    #6,D1
5246 L05246        BRA.S    L05252

5248 L05248        MOVEQ    #3,D1
524A L0524A        ADD.W    0(A6,A0.L),D1
                   BCLR     #0,D1
5252 L05252        MOVE.L   #-1,4(A6,A2.L)
                   JSR      L050E2(PC)
525E L0525E        MOVEQ    #0,D0
5260 L05260        MOVEM.L  (A7)+,D2/D4/D6/A1-3
5264 L05264        RTS

5266 L05266        MOVE.L   A0,-(A7)
                   MOVE.W   0(A6,A1.L),D0
                   ADDQ.W   #2,A1
                   MOVEQ    #0,D1
                   MOVE.W   D0,D1
                   BEQ      L05300
                   SWAP     D0
                   ADDQ.W   #1,D1
                   BCLR     #0,D1
                   MOVE.W   D1,D0
                   SUBA.L   BV.RIBAS(A6),A1
                   MOVEM.L  D0-2/A1,-(A7)
                   JSR      L04EF0(PC)
                   MOVEM.L  (A7)+,D0-2/A1
                   ADDA.L   BV.RIBAS(A6),A1
5294 L05294        MOVE.W   0(A6,A1.L),0(A6,A0.L)
                   ADDQ.W   #2,A1
                   ADDQ.W   #2,A0
                   SUBQ.W   #2,D1
                   BGT.S    L05294
                   SUBA.W   D0,A0
                   MOVE.W   0(A6,A1.L),D2
                   ADDQ.W   #2,A1
                   MOVEA.L  A1,A2
                   MOVE.W   D2,D1
                   ADDQ.W   #1,D1
                   BCLR     #0,D1
                   ADDA.W   D1,A1
                   MOVE.W   D2,D1
                   SWAP     D0
                   ADD.W    D0,D1
                   ADDQ.W   #1,D1
                   BMI.S    L05306
                   BCLR     #0,D1
                   SUBA.W   D1,A1
                   MOVE.W   D2,D1
                   BEQ.S    L052D8
52CA L052CA        MOVE.B   0(A6,A2.L),0(A6,A1.L)
                   ADDQ.W   #1,A2
                   ADDQ.W   #1,A1
                   SUBQ.W   #1,D1
                   BGT.S    L052CA
52D8 L052D8        ADD.W    D0,D2
                   MOVE.L   D0,D1
52DC L052DC        MOVE.B   0(A6,A0.L),0(A6,A1.L)
                   ADDQ.W   #1,A0
                   ADDQ.W   #1,A1
                   SUBQ.W   #1,D0
                   BGT.S    L052DC
                   SUBA.W   D1,A0
                   SUBA.W   D2,A1
                   SUBQ.W   #2,A1
                   MOVE.W   D2,0(A6,A1.L)
                   CLR.W    D1
                   SWAP     D1
                   MOVE.L   A1,-(A7)
                   JSR      L050E2(PC)
                   MOVEA.L  (A7)+,A1
5300 L05300        MOVEQ    #0,D0
5302 L05302        MOVEA.L  (A7)+,A0
                   RTS

5306 L05306        LEA      -2(A2),A1
530A L0530A        MOVE.W   D0,D1
                   MOVE.L   A1,-(A7)
                   JSR      L050E2(PC)
                   MOVEA.L  (A7)+,A1
                   MOVEQ    #-$12,D0
                   BRA.S    L05302

5318 L05318        DC.W     $0002,$0202
                   DC.W     $0205,$0505
                   DC.W     $0505,$0505
                   DC.W     $0303,$0302
                   DC.W     $0102

                   ANDI.B   #3,D2
                   BTST     D0,D2
                   ANDI.B   #0,D3
5334 L05334        ANDI.B   #$0F,-7(A6,A5.L)
                   MOVEQ    #0,D0
                   MOVE.B   L05318(PC,D4.W),D0
                   CMPI.B   #$16,D4
                   BGT      L05402
                   ANDI.B   #$0F,-$0F(A6,A5.L)
                   CMP.B    -7(A6,A5.L),D0
                   BEQ.S    L0537A
                   CMPI.B   #5,D0
                   BNE.S    L05370
                   MOVE.B   -7(A6,A5.L),D2
                   CMP.B    -15(A6,A5.L),D2
                   BNE.S    L0536E
                   SUBQ.B   #1,D2
                   BNE.S    L0536E
                   SUBQ.W   #8,A5
536A L0536A        BRA      L05408

536E L0536E        MOVEQ    #2,D0
5370 L05370        BSR      L0540C
5374 L05374        BNE      L0540A
                   MOVE.B   D2,D0
537A L0537A        SUBQ.W   #8,A5
                   CMP.B    -7(A6,A5.L),D0
                   BEQ.S    L0536A
                   MOVE.B   1(A6,A5.L),D1
                   SUBQ.B   #2,D1
                   BLT.S    L053A0
                   BEQ.S    L05394
                   MOVE.W   0(A6,A1.L),-(A7)
                   ADDQ.W   #2,A1
                   BRA.S    L053BC

5394 L05394        MOVE.L   2(A6,A1.L),-(A7)
5398 L05398        MOVE.W   0(A6,A1.L),-(A7)
                   ADDQ.W   #6,A1
                   BRA.S    L053BC

53A0 L053A0        MOVEQ    #3,D2
53A2 L053A2        ADD.W    0(A6,A1.L),D2
                   BCLR     #0,D2
                   SUBA.L   D2,A7
                   MOVE.L   D2,D1
                   SUBQ.W   #1,D1
53B0 L053B0        MOVE.W   0(A6,A1.L),(A7)+
                   ADDQ.W   #2,A1
                   SUBQ.W   #2,D1
                   BGE.S    L053B0
                   SUBA.L   D2,A7
53BC L053BC        MOVE.B   D1,-(A7)
                   MOVE.L   A1,BV.RIP(A6)
                   BSR.S    L0540C
                   MOVE.B   (A7)+,D2
                   BLT.S    L053DE
                   BEQ.S    L053D2
                   SUBQ.W   #2,A1
                   MOVE.W   (A7)+,0(A6,A1.L)
                   BRA.S    L053F6

53D2 L053D2        SUBQ.W   #6,A1
53D4 L053D4        MOVE.W   (A7)+,0(A6,A1.L)
                   MOVE.L   (A7)+,2(A6,A1.L)
                   BRA.S    L053F6

53DE L053DE        MOVEQ    #3,D2
53E0 L053E0        ADD.W    (A7),D2
                   BCLR     #0,D2
                   SUBA.L   D2,A1
                   MOVE.L   D2,D1
53EA L053EA        MOVE.W   (A7)+,0(A6,A1.L)
                   ADDQ.W   #2,A1
                   SUBQ.W   #2,D1
                   BGT.S    L053EA
                   SUBA.L   D2,A1
53F6 L053F6        MOVE.L   A1,BV.RIP(A6)
                   TST.L    D0
                   BEQ.S    L0540A
                   ADDQ.W   #8,A5
                   RTS

5402 L05402        CMP.B    -7(A6,A5.L),D0
5406 L05406        BNE.S    L0540C
5408 L05408        MOVEQ    #0,D0
540A L0540A        RTS

540C L0540C        MOVE.L   D7,-(A7)
540E L0540E        MOVE.L   A0,-(A7)
                   MOVE.B   D0,-(A7)
                   MOVE.B   -7(A6,A5.L),D2
                   MOVEQ    #15,D1
                   AND.L    D1,D0
                   AND.L    D1,D2
                   SUB.B    D2,D0
                   BEQ.S    L05480
                   SUBQ.B   #2,D2
                   BLT.S    L05454
                   BEQ.S    L0543A
                   ADDQ.B   #1,D0
                   BLT.S    L05430
                   JSR      L04852(PC)
                   BRA.S    L05480

5430 L05430        MOVEA.L  (A6),A0
5432 L05432        JSR      CN_ITOD(PC)
                   BSR.S    L05496
                   BRA.S    L05480

543A L0543A        TST.B    D0
543C L0543C        BLT.S    L0544A
                   JSR      RI_NINT(PC)
                   MOVE.B   #3,-7(A6,A5.L)
                   BRA.S    L05480

544A L0544A        MOVEA.L  (A6),A0
544C L0544C        JSR      CN_FTOD(PC)
                   BSR.S    L05496
                   BRA.S    L05480

5454 L05454        SUBQ.B   #1,D0
5456 L05456        BLT.S    L05480
                   BEQ.S    L05466
                   BSR.S    L054AA
                   MOVE.L   A0,-(A7)
                   ADDQ.W   #2,A0
                   JSR      CN_DTOI(PC)
                   BRA.S    L05470

5466 L05466        BSR.S    L054AA
5468 L05468        MOVE.L   A0,-(A7)
                   ADDQ.W   #2,A0
                   JSR      CN_DTOF(PC)
5470 L05470        MOVEA.L  (A7)+,A0
                   MOVE.L   D0,-(A7)
                   BSR.S    L054DC
                   MOVE.L   (A7)+,D0
                   BEQ.S    L05480
                   SUBQ.W   #2,A1
                   CLR.W    0(A6,A1.L)
5480 L05480        MOVE.B   (A7)+,D2
                   MOVEA.L  (A7)+,A0
                   MOVE.L   (A7)+,D7
                   MOVE.L   A1,BV.RIP(A6)
                   TST.L    D0
                   BNE.S    L05494
                   MOVE.B   D2,-7(A6,A5.L)
                   MOVEQ    #0,D0
5494 L05494        RTS

5496 L05496        MOVE.L   A1,BV.RIP(A6)
549A L0549A        MOVE.L   A4,-(A7)
                   MOVE.L   A0,D1
                   MOVEA.L  (A6),A4
                   SUB.L    A4,D1
                   JSR      L059FE(PC)
                   MOVEA.L  (A7)+,A4
                   BRA.S    L054D8

54AA L054AA        MOVEQ    #3,D1
54AC L054AC        ADD.W    0(A6,A1.L),D1
                   BCLR     #0,D1
                   JSR      L04EF0(PC)
                   MOVEA.L  BV.RIP(A6),A1
                   MOVE.L   A0,-(A7)
54BE L054BE        MOVE.W   0(A6,A1.L),0(A6,A0.L)
                   ADDQ.W   #2,A0
                   ADDQ.W   #2,A1
                   SUBQ.L   #2,D1
                   BGT.S    L054BE
                   MOVEA.L  (A7)+,A0
                   MOVE.L   A0,D7
                   MOVEQ    #2,D1
                   ADD.W    0(A6,A0.L),D1
                   ADD.L    D1,D7
54D8 L054D8        MOVEQ    #0,D0
                   RTS

54DC L054DC        MOVE.L   A1,-(A7)
54DE L054DE        MOVEQ    #3,D1
                   ADD.W    0(A6,A0.L),D1
                   BCLR     #0,D1
                   JSR      L050E2(PC)
                   MOVEA.L  (A7)+,A1
                   RTS

54F0 L054F0        MOVEQ    #1,D0
                   BRA.S    L054FA

54F4 L054F4        MOVEQ    #2,D0
                   BRA.S    L054FA

54F8 L054F8        MOVEQ    #3,D0
54FA L054FA        MOVE.B   D0,-(A7)
54FC L054FC        BSR.S    L05516
                   BNE.S    L05510
                   MOVE.B   (A7),D0
                   BNE.S    L05506
                   MOVEQ    #1,D0
5506 L05506        JSR      L0540C(PC)
                   SUBQ.L   #8,A5
                   MOVE.L   A5,BV.NTP(A6)
5510 L05510        ADDQ.W   #2,A7
                   TST.L    D0
                   RTS

5516 L05516        BSR.S    L05530
5518 L05518        BNE.S    L0551E
                   BSR      L0593E
551E L0551E        RTS

5520 L05520        DC.W     $0014,$1414            ;556a 557e 557e 557e
                   DC.W     $0484,$98B8            ;556e 55ee 5602 5622
                   DC.W     $C214,$14BE            ;562c 557e 557e 5628

                   MOVE.B   (A4),D2
                   MOVE.B   D0,D2
5530 L05530        MOVEA.L  BV.NTP(A6),A5
                   MOVE.L   A5,-(A7)
                   MOVEM.L  D4-6,-(A7)
                   ST       -(A7)
                   MOVEQ    #$40,D1
                   JSR      L04F5A(PC)
                   MOVEQ    #2,D0
                   JSR      L04F2C(PC)
                   BRA.S    L05552

554A L0554A        MOVEQ    #1,D6
554C L0554C        BRA.S    L05554

554E L0554E        ST       D6
5550 L05550        BRA.S    L05554

5552 L05552        SF       D6
5554 L05554        MOVEQ    #$7F,D4
5556 L05556        AND.B    0(A6,A0.L),D4
                   CMPI.B   #$70,D4
                   BGE      L056CE
                   MOVE.B   L05520(PC,D4.W),D4


;part 15

556A L0556A        ADDQ.W   #2,A0
556C L0556C        BRA.S    L05554

556E L0556E        MOVE.B   1(A6,A0.L),D4
                   CMPI.B   #5,D4
                   BEQ.S    L05584
                   CMPI.B   #1,D4
                   BEQ.S    L055E8
                   MOVEQ    #0,D5
                   BRA      L0578C

5584 L05584        ADDQ.W   #2,A0
5586 L05586        TST.B    D6
                   BEQ.S    L055B8
                   BGT      L05622
                   CMPI.B   #3,-8(A6,A5.L)
                   BEQ.S    L0559E
                   JSR      L05E2A(PC)
                   BNE.S    L055A2
                   BRA.S    L0554E

559E L0559E        JSR      L05CDC(PC)
55A2 L055A2        BNE      L05718
55A6 L055A6        CMPI.B   #3,-8(A6,A5.L)
                   BEQ.S    L0554E
55AE L055AE        CMPI.B   #1,-7(A6,A5.L)
                   BEQ.S    L0554E
                   BRA.S    L0554A

55B8 L055B8        BSR      L05516
55BC L055BC        BNE      L05718
                   CMPI.W   #SYM.RBKT,0(A6,A0.L)
                   BNE.S    L05622
                   ADDQ.W   #2,A0
                   BRA.S    L055AE

55CC L055CC        ORI.B    #6,D5
                   ADDI.B   #4,D4
                   SUBI.B   #4,D4
                   DC.W     $0102,$0107
                   DC.W     $0901,$0201
                   DC.W     $0606,$080B
                   DC.W     $0B03,$0300

55E8 L055E8        MOVE.W   #OPS.EQ,0(A6,A0.L)
                   TST.B    D6
                   BEQ.S    L05622
                   MOVE.B   1(A6,A0.L),D4
                   ADDQ.W   #2,A0
                   MOVE.B   L055CC(PC,D4.W),D5
                   SWAP     D4
                   BRA      L05790

5602 L05602        MOVEQ    #$16,D4
                   ADD.B    1(A6,A0.L),D4
                   ADDQ.W   #2,A0
                   MOVE.B   L055CC(PC,D4.W),D5
                   BRA.S    L05618

5610 L05610        TST.B    D5
5612 L05612        BEQ      L0577C
                   SWAP     D4
5618 L05618        MOVE.B   D5,-(A7)
                   MOVE.B   D4,1(A7)
                   BRA      L05552

5622 L05622        MOVEQ    #-17,D0
5624 L05624        BRA      L05718

5628 L05628        BRA      L056E0

562C L0562C        MOVEA.L  BV.NTP(A6),A5
                   ADDQ.L   #8,BV.NTP(A6)
                   MOVEQ    #0,D4
                   MOVE.W   2(A6,A0.L),D4
                   MOVE.L   D4,D0
                   ADDQ.W   #4,A0
                   LSL.L    #3,D4
                   MOVEA.L  BV.NTBAS(A6),A3
                   ADDA.L   D4,A3
                   MOVE.B   0(A6,A3.L),D4
                   CMPI.B   #9,D4
                   BEQ.S    L05682
                   CMPI.B   #5,D4
                   BEQ.S    L05688
                   CMPI.B   #8,D4
                   BEQ.S    L05622
                   CMPI.B   #4,D4
                   BEQ.S    L05622
                   MOVE.W   0(A6,A3.L),0(A6,A5.L)
                   ANDI.B   #%00001111,1(A6,A5.L)
                   MOVE.W   D0,2(A6,A5.L)
                   MOVE.L   4(A6,A3.L),4(A6,A5.L)
                   ADDQ.W   #8,A5
                   SUBQ.B   #3,D4
                   BEQ.S    L05694
                   BRA      L0570A

5682 L05682        JSR      L05B2A(PC)
5686 L05686        BRA.S    L0568C

5688 L05688        JSR      L05AD6(PC)
568C L0568C        BNE      L05718
5690 L05690        BRA      L0554A

5694 L05694        MOVEQ    #0,D1
5696 L05696        MOVE.L   -4(A6,A5.L),D0
                   BLT.S    L05622
                   MOVEA.L  BV.VVBAS(A6),A3
                   ADDA.L   D0,A3
                   MOVE.W   4(A6,A3.L),D1
                   LSL.W    #2,D1
                   ADDQ.W   #6,D1
                   MOVE.L   A3,-(A7)
                   BSR      L05A38
                   MOVEA.L  (A7)+,A3
                   MOVE.L   A2,D2
                   SUB.L    BV.VVBAS(A6),D2
                   MOVE.L   D2,-4(A6,A5.L)
56BC L056BC        MOVE.W   0(A6,A3.L),0(A6,A2.L)
                   ADDQ.W   #2,A3
                   ADDQ.W   #2,A2
                   SUBQ.W   #2,D1
                   BNE.S    L056BC
                   BRA      L0554E

56CE L056CE        MOVEA.L  A0,A4
56D0 L056D0        BSR      L059E2
                   ADDQ.W   #6,A0
                   ANDI.B   #$0F,0(A6,A1.L)
                   MOVEQ    #2,D4
                   BRA.S    L056EC

56E0 L056E0        ADDQ.W   #2,A0
56E2 L056E2        MOVEA.L  A0,A4
                   BSR      L059F6
                   MOVEA.L  A4,A0
                   MOVEQ    #1,D4
56EC L056EC        MOVEA.L  BV.NTP(A6),A5
                   ADDQ.L   #8,BV.NTP(A6)
                   MOVE.B   #1,0(A6,A5.L)
                   MOVE.B   D4,1(A6,A5.L)
                   MOVE.W   #-1,2(A6,A5.L)
                   CLR.L    4(A6,A5.L)
                   ADDQ.W   #8,A5
570A L0570A        CMPI.B   #1,-7(A6,A5.L)
                   BEQ      L0554E
                   BRA      L0554A

5718 L05718        TST.W    (A7)+
571A L0571A        BGE.S    L05718
                   MOVEM.L  (A7)+,D4-6
5720 L05720        CMPA.L   (A7),A5
                   BEQ.S    L0572A
                   MOVEQ    #1,D2
                   BSR.S    L05732
                   BRA.S    L05720

572A L0572A        MOVE.L   A5,BV.NTP(A6)
572E L0572E        ADDQ.W   #4,A7
                   BRA.S    L05788

5732 L05732        MOVE.B   -8(A6,A5.L),D1
5736 L05736        SUBQ.B   #1,D1
                   BNE.S    L05762
                   SUBQ.B   #2,-7(A6,A5.L)
                   BLT.S    L0574C
                   BGT.S    L05746
                   ADDQ.L   #4,BV.RIP(A6)
5746 L05746        ADDQ.L   #2,BV.RIP(A6)
                   BRA.S    L0575E

574C L0574C        MOVEA.L  BV.RIP(A6),A1
5750 L05750        MOVEQ    #3,D1
                   ADD.W    0(A6,A1.L),D1
                   BCLR     #0,D1
                   ADD.L    D1,BV.RIP(A6)
575E L0575E        SUBQ.W   #8,A5
5760 L05760        RTS

5762 L05762        TST.B    D2
5764 L05764        BEQ.S    L05760
                   SUBQ.B   #2,D1
                   BNE.S    L0575E
                   MOVE.L   -4(A6,A5.L),D1
                   BLT.S    L0575E
                   MOVEA.L  BV.VVBAS(A6),A3
                   ADDA.L   D1,A3
                   BSR      L059A6
                   BRA.S    L0575E

577C L0577C        MOVEQ    #0,D0
577E L0577E        ADDQ.W   #2,A7
                   MOVEM.L  (A7)+,D4-6
                   CMPA.L   (A7)+,A5
                   SEQ      D0
5788 L05788        TST.L    D0
                   RTS

578C L0578C        TST.B    (A7)
578E L0578E        BLE.S    L0577C
5790 L05790        BSR      L0593E
5794 L05794        BNE.S    L05718
5796 L05796        CMP.B    (A7),D5
                   BGT      L05610
                   MOVE.W   (A7)+,D4               ;get token
                   ANDI.W   #$00FF,D4              ;mask off top byte of token
                   JSR      L05334(PC)             ;get arguments
                   BNE.S    L05794
                   MOVE.L   A5,BV.NTP(A6)
                   ADD.W    D4,D4                  ;form word offset
                   MOVE.W   L057C4(PC,D4.W),D4     ;get offset from table
                   BEQ      L05622                 ;if first entry then ...
                   MOVEQ    #2,D0
                   JSR      L057C4(PC,D4.W)        ;call the routine
                   BNE.S    L05794
                   MOVE.L   A1,BV.RIP(A6)
                   BRA.S    L05796

   Do routine for operation symbol tokens $8501 to $8516.

57C4 L057C4        DC.W     $0000,$F10E            ;null,ri_add      null +
                   DC.W     $F100,$F1A2            ;ri_sub,ri_mult    -   *
                   DC.W     $F23A,$004A            ;ri_div,580e       /   >=
                   DC.W     $003C,$0042            ;5800 5806         >   ==
                   DC.W     $0044,$0056            ;5808 581a         =   <>
                   DC.W     $0050,$0036            ;5814 57fa         <=  <
                   DC.W     $011E,$0126            ;58e2 58ea         ||  &&
                   DC.W     $012E,$EC96            ;58f2 445a         ^^  ^
                   DC.W     $FAA2,$00F4            ;5266 5868         &   OR
                   DC.W     $00FA,$0100            ;586e 58c4         AND XOR
                   DC.W     $0144,$014A            ;5908 590e         MOD DIV
                   DC.W     $00D8,$00C2            ;589c 5886         INSTR
                   DC.W     $00BE,$0136            ;5882 58fa
                   DC.W     $0106                  ;586a

57FA L0574FA       BSR.S    L05820                 ;<
                   BLT.S    L0586A
                   BRA.S    L0587A

5800 L05800        BSR.S    L05820                 ;>
                   BGT.S    L0586A
                   BRA.S    L0587A

5806 L05806        MOVEQ    #3,D0                  ;==
5808 L05808        BSR.S    L05820                 ;=
                   BEQ.S    L0586A
                   BRA.S    L0587A

580E L0580E        BSR.S    L05820                 ;>=
                   BGE.S    L0586A
                   BRA.S    L0587A

5814 L05814        BSR.S    L05820                 ;<=
5816 L05816        BLE.S    L0586A
                   BRA.S    L0587A

581A L0581A        BSR.S    L05820                 ;<>
                   BNE.S    L0586A
                   BRA.S    L0587A

5820 L05820        CMPI.B   #1,-7(A6,A5.L)
5826 L05826        BNE.S    L05842
                   MOVE.L   A0,-(A7)
                   BSR.S    L0588C
                   JSR      UT_CSTR(PC)
                   BSR.S    L0588A
                   LEA      -6(A0),A1
                   MOVE.B   #2,-7(A6,A5.L)
583C L0583C        MOVEA.L  (A7)+,A0
                   TST.L    D0
                   RTS

5842 L05842        MOVE.W   D0,D4
5844 L05844        JSR      RI_SUB(PC)
                   BNE.S    L05866
                   SUBQ.W   #3,D4
                   BEQ.S    L05854
                   TST.B    2(A6,A1.L)
                   RTS

5854 L05854        ADDQ.W   #4,A7
5856 L05856        MOVE.W   0(A6,A1.L),D0
                   BEQ.S    L0586A
                   ADDI.W   #$18,D0
                   SUB.W    -6(A6,A1.L),D0
                   BRA.S    L05816

5866 L05866        ADDQ.W   #4,A7                  ;OR
5868 L05868        RTS

586A L0586A        MOVE.W   #$0801,0(A6,A1.L)
5870 L05870        MOVE.L   #$40000000,2(A6,A1.L)
                   BRA.S    L05882

587A L0587A        CLR.W    0(A6,A1.L)
587E L0587E        CLR.L    2(A6,A1.L)
5882 L05882        MOVEQ    #0,D0
                   RTS

5886 L05886        JMP      RI_NEG(PC)

588A L0588A        MOVEA.L  A0,A1
588C L0588C        MOVE.W   0(A6,A1.L),D2
5890 L05890        ADDQ.W   #3,D2
                   BCLR     #0,D2
                   LEA      0(A1,D2.W),A0
                   RTS

589C L0589C        MOVEQ    #1,D0                  ;INSTR
                   MOVE.L   A0,-(A7)
                   BSR.S    L0588C
                   JSR      L03ADC(PC)             ;some sort of string comparison
                   BSR.S    L0588A
                   LEA      -2(A0),A1
                   MOVE.B   #3,-7(A6,A5.L)
                   MOVE.W   D1,0(A6,A1.L)
                   BRA.S    L0583C

58B8 L058B8        BSR.S    L058D2
                   OR.B     D1,D0
                   BRA.S    L058CE

58BE L058BE        BSR.S    L058D2
                   AND.B    D1,D0
                   BRA.S    L058CE

58C4 L058C4        BSR.S    L058D2                 ;XOR
                   EOR.B    D1,D0
                   BRA.S    L058CE

58CA L058CA        BSR.S    L058DA
                   NOT.B    D0
58CE L058CE        BEQ.S    L0587A
                   BRA.S    L0586A

58D2 L058D2        ADDQ.W   #6,A1
58D4 L058D4        TST.L    -4(A6,A1.L)
                   SNE      D1
58DA L058DA        TST.L    2(A6,A1.L)
                   SNE      D0
                   RTS

58E2 L058E2        BSR.S    L05900                 ;||
                   OR.W     D0,0(A6,A1.L)
58E8 L058E8        BRA.S    L05882

58EA L058EA        BSR.S    L05900                 ;&&
                   AND.W    D0,0(A6,A1.L)
                   BRA.S    L05882

58F2 L058F2        BSR.S    L05900                 ;^^
                   EOR.W    D0,0(A6,A1.L)
                   BRA.S    L05882

58FA L058FA        NOT.W    0(A6,A1.L)
                   BRA.S    L05882

5900 L05900        MOVE.W   0(A6,A1.L),D0
5904 L05904        ADDQ.W   #2,A1
5906 L05906        RTS

5908 L05908        BSR.S    L05916                 ;MOD
                   MOVE.W   D0,D3
                   BRA.S    L05910

590E L0590E        BSR.S    L05916                 ;DIV
5910 L05910        MOVE.W   D3,0(A6,A1.L)
                   BRA.S    L058E8

5916 L05916        MOVE.W   2(A6,A1.L),D0
591A L0591A        EXT.L    D0
                   MOVE.W   0(A6,A1.L),D1
                   BEQ.S    L05938
                   MOVE.W   D0,D2
                   DIVS     D1,D0
                   MOVE.W   D0,D3
                   SWAP     D0
                   EOR.W    D1,D2
                   BPL.S    L05904
                   TST.W    D0
                   BEQ.S    L05904
                   ADD.W    D1,D0
                   SUBQ.W   #1,D3
                   BRA.S    L05904

5938 L05938        MOVEQ    #-$12,D0
593A L0593A        ADDQ.W   #4,A7
                   BRA.S    L05904

593E L0593E        ANDI.B   #$0F,-7(A6,A5.L)
5944 L05944        MOVE.B   -8(A6,A5.L),D0
                   BEQ.S    L0595E
                   SUBQ.B   #1,D0
                   BEQ      L05A2A
                   SUBQ.B   #2,D0
                   BLT.S    L059B8
                   BEQ.S    L0596C
                   SUBQ.B   #3,D0
                   BLT.S    L0595E
                   SUBQ.B   #1,D0
                   BLE.S    L059B8
595E L0595E        MOVEQ    #1,D2
                   BSR      L05732
                   MOVE.L   A5,BV.NTP(A6)
                   MOVEQ    #-$11,D0
                   RTS

596C L0596C        MOVE.B   -7(A6,A5.L),D0
5970 L05970        SUBQ.B   #1,D0
                   BGT.S    L0595E
                   MOVEA.L  -4(A6,A5.L),A3
                   ADDA.L   BV.VVBAS(A6),A3
                   MOVEA.L  0(A6,A3.L),A4
                   ADDA.L   BV.VVBAS(A6),A4
                   CMPI.W   #1,4(A6,A3.L)
                   BGT.S    L0595E
                   MOVE.B   #1,-8(A6,A5.L)
                   MOVE.B   #1,-7(A6,A5.L)
                   MOVEQ    #0,D1
                   MOVE.W   6(A6,A3.L),D1
                   BSR.S    L059A6
                   TST.B    D0
                   BEQ.S    L059F6
                   BRA.S    L059FE

59A6 L059A6        MOVEM.L  D0-1/A0-1,-(A7)
59AA L059AA        MOVEA.L  A3,A0
                   MOVEQ    #10,D1
                   JSR      L050E2(PC)
                   MOVEM.L  (A7)+,D0-1/A0-1
                   RTS

59B8 L059B8        MOVE.B   -7(A6,A5.L),D0
59BC L059BC        MOVE.L   -4(A6,A5.L),D1
                   BLT.S    L0595E
                   MOVE.B   #1,-8(A6,A5.L)
                   MOVEA.L  D1,A4
                   ADDA.L   BV.VVBAS(A6),A4
                   SUBQ.B   #2,D0
                   BLT.S    L059F6
                   BEQ.S    L059E2
                   MOVEQ    #2,D1
                   BSR.S    L05A32
                   SUBQ.W   #2,A1
                   MOVE.W   0(A6,A4.L),0(A6,A1.L)
                   BRA.S    L05A2A

59E2 L059E2        MOVEQ    #6,D1
59E4 L059E4        BSR.S    L05A32
                   SUBQ.W   #6,A1
                   MOVE.L   2(A6,A4.L),2(A6,A1.L)
                   MOVE.W   0(A6,A4.L),0(A6,A1.L)
                   BRA.S    L05A2A

59F6 L059F6        MOVEQ    #0,D1
59F8 L059F8        MOVE.W   0(A6,A4.L),D1
                   ADDQ.W   #2,A4
59FE L059FE        MOVE.L   D1,-(A7)
                   ADDQ.L   #3,D1
                   BSR.S    L05A32
                   MOVE.L   (A7),D1
                   BEQ.S    L05A22
                   ADDQ.L   #1,D1
                   BCLR     #0,D1
                   MOVE.L   D1,D0
                   SUBA.L   D0,A1
5A12 L05A12        MOVE.B   0(A6,A4.L),0(A6,A1.L)
                   ADDQ.W   #1,A1
                   ADDQ.W   #1,A4
                   SUBQ.L   #1,D0
                   BGT.S    L05A12
                   SUBA.L   D1,A1
5A22 L05A22        SUBQ.W   #2,A1
                   ADDQ.W   #2,A7
                   MOVE.W   (A7)+,0(A6,A1.L)
5A2A L05A2A        MOVE.L   A1,BV.RIP(A6)
                   MOVEQ    #0,D0
                   RTS

5A32 L05A32        JSR      L04F48(PC)
5A36 L05A36        BRA.S    L05A42

5A38 L05A38        MOVE.L   A0,-(A7)
5A3A L05A3A        JSR      L04EF0(PC)
                   MOVEA.L  A0,A2
                   MOVEA.L  (A7)+,A0
5A42 L05A42        MOVEA.L  BV.RIP(A6),A1
                   RTS

5A48 L05A48        JSR      L05530(PC)
5A4C L05A4C        BNE.S    L05ABE
                   ANDI.B   #$0F,-7(A6,A5.L)
                   MOVE.B   -8(A6,A5.L),D0
                   CMPI.B   #1,D0
                   BNE.S    L05ABC
                   MOVE.W   #-1,-6(A6,A5.L)
                   MOVE.B   #2,-8(A6,A5.L)
                   MOVE.B   -7(A6,A5.L),D0
                   SUBQ.B   #2,D0
                   BLT.S    L05A8E
                   BEQ.S    L05A7E
                   MOVEQ    #2,D1
                   BSR.S    L05AC0
                   ADDQ.W   #2,A2
                   ADDQ.W   #2,A1
                   BRA.S    L05AB8

5A7E L05A7E        MOVEQ    #6,D1
5A80 L05A80        BSR.S    L05AC0
                   MOVE.L   2(A6,A1.L),2(A6,A2.L)
                   ADDQ.W   #6,A2
                   ADDQ.W   #6,A1
                   BRA.S    L05AB8

5A8E L05A8E        MOVEQ    #3,D1
5A90 L05A90        ADD.W    0(A6,A1.L),D1
                   BCLR     #0,D1
                   BSR.S    L05AC0
                   MOVE.W   0(A6,A1.L),D1
                   ADDQ.W   #2,A1
                   ADDQ.W   #2,A2
                   BEQ.S    L05AB8
                   ADDQ.W   #1,D1
                   BCLR     #0,D1
5AAA L05AAA        MOVE.W   0(A6,A1.L),0(A6,A2.L)
                   ADDQ.W   #2,A1
                   ADDQ.W   #2,A2
                   SUBQ.W   #2,D1
                   BGT.S    L05AAA
5AB8 L05AB8        MOVE.L   A1,BV.RIP(A6)
5ABC L05ABC        MOVEQ    #0,D0
5ABE L05ABE        RTS

5AC0 L05AC0        JSR      L05A38(PC)
5AC4 L05AC4        MOVE.L   A2,D2
                   SUB.L    BV.VVBAS(A6),D2
                   MOVE.L   D2,-4(A6,A5.L)
                   MOVE.W   0(A6,A1.L),0(A6,A2.L)
                   RTS

5AD6 L05AD6        MOVEA.L  A3,A2
5AD8 L05AD8        BSR.S    L05B06
                   MOVE.B   1(A6,A2.L),-7(A6,A5.L)
                   BSR.S    L05B18
                   BNE.S    L05AEA
                   ADDQ.W   #2,A0
                   MOVEQ    #2,D5
                   BRA.S    L05AEC

5AEA L05AEA        MOVEQ    #3,D5
5AEC L05AEC        MOVEA.L  A0,A4
5AEE L05AEE        MOVE.L   D0,D4
                   MOVE.L   A0,-(A7)
                   LEA      L04CBA,A0
                   MOVE.L   A0,-(A7)
                   LEA      L09EFA,A0
                   MOVE.L   A0,-(A7)
                   BRA      L08CB6

5B06 L05B06        CLR.W    0(A6,A5.L)
5B0A L05B0A        MOVE.W   #-1,2(A6,A5.L)
                   CLR.L    4(A6,A5.L)
                   ADDQ.W   #8,A5
                   RTS

5B18 L05B18        CMPI.B   #SPC.B,0(A6,A0.L)      ;space token ?
5B1E L05B1E        BNE.S    L05B22
                   ADDQ.W   #2,A0
5B22 L05B22        CMPI.W   #SYM.LBKT,0(A6,A0.L)
                   RTS

5B2A L05B2A        BSR.S    L05B06
5B2C L05B2C        MOVE.L   A5,D0
                   SUB.L    BV.NTBAS(A6),D0
                   MOVE.L   D0,-(A7)
                   MOVE.L   4(A6,A3.L),-(A7)
                   BSR.S    L05B18
                   BEQ.S    L05B3E
                   BRA.S    L05B50

5B3E L05B3E        ADDQ.W   #2,A0
5B40 L05B40        JSR      L05BB4(PC)
                   BNE.S    L05BAE
                   CMPI.W   #SYM.RBKT,0(A6,A0.L)
                   BNE.S    L05BAC
                   ADDQ.W   #2,A0
5B50 L05B50        MOVEA.L  (A7)+,A2
                   MOVEA.L  BV.NTBAS(A6),A3
                   MOVE.L   A5,D0
                   SUB.L    A3,D0
                   ADDA.L   (A7),A3
                   MOVE.L   D0,-(A7)
                   MOVEA.L  BV.RIP(A6),A1
                   SUBA.L   BV.RIBAS(A6),A1
                   MOVEM.L  D5-7/A0-1,-(A7)
                   JSR      (A2)
                   MOVE.L   D0,D2
                   MOVEM.L  (A7)+,D5-7/A0-1
                   BEQ.S    L05B7C
                   ADDA.L   BV.RIBAS(A6),A1
                   MOVE.L   A1,BV.RIP(A6)
5B7C L05B7C        MOVEA.L  BV.RIP(A6),A1
                   MOVEA.L  BV.NTBAS(A6),A5
                   MOVEA.L  A5,A3
                   ADDA.L   (A7)+,A5
                   ADDA.L   (A7)+,A3
                   MOVE.L   A0,-(A7)
                   MOVE.L   A3,-(A7)
                   JSR      L05178(PC)
                   MOVEA.L  (A7)+,A5
                   MOVE.L   D2,D0
                   BNE.S    L05BB0
                   MOVE.B   D4,-7(A6,A5.L)
                   MOVE.B   #1,-8(A6,A5.L)
                   CLR.L    -4(A6,A5.L)
                   MOVEA.L  (A7)+,A0
                   MOVEQ    #0,D0                  ;signal "no errors"
                   RTS

5BAC L05BAC        MOVEQ    #ERR.XP,D0             ;signal "error in expression"
5BAE L05BAE        ADDQ.W   #4,A7
5BB0 L05BB0        ADDQ.W   #4,A7
5BB2 L05BB2        RTS

5BB4 L05BB4        MOVE.L   D3,-(A7)
5BB6 L05BB6        MOVE.L   D4,-(A7)
                   SF       D4
5BBA L05BBA        JSR      L05A48(PC)
                   BLT.S    L05C20
                   BGT.S    L05BCC
                   MOVE.B   0(A6,A0.L),D0
                   MOVE.W   0(A6,A0.L),D1
                   BRA.S    L05BF6

5BCC L05BCC        MOVE.B   0(A6,A0.L),D0
5BD0 L05BD0        MOVE.W   0(A6,A0.L),D1
                   CMPI.B   #SEP.B,D0              ;seperator token ?
                   BEQ.S    L05BE6
                   CMPI.W   #SYM.HASH,D1
                   BNE.S    L05C14
                   ST       D4
                   ADDQ.W   #2,A0
                   BRA.S    L05BBA

5BE6 L05BE6        CLR.W    0(A6,A5.L)
5BEA L05BEA        MOVE.W   #-1,2(A6,A5.L)
                   CLR.L    4(A6,A5.L)
                   ADDQ.W   #8,A5
5BF6 L05BF6        MOVE.L   A5,BV.NTP(A6)
                   CMPI.B   #SEP.B,D0              ;seperator token ?
                   BNE.S    L05C14
                   TST.B    D4
                   BEQ.S    L05C08
                   BSET     #3,D1
5C08 L05C08        SF       D4
                   ADDQ.W   #2,A0
                   LSL.B    #4,D1
                   OR.B     D1,-7(A6,A5.L)
                   BRA.S    L05BBA

5C14 L05C14        TST.B    D4
5C16 L05C16        BEQ.S    L05C1E
                   BSET     #7,-7(A6,A5.L)
5C1E L05C1E        MOVEQ    #0,D0
5C20 L05C20        MOVE.L   (A7)+,D4
                   MOVE.L   (A7)+,D3
                   TST.L    D0
                   RTS

5C28 L05C28        BSR.S    L05C44
                   BRA.S    L05C36

5C2C L05C2C        BSR.S    L05C4C
                   BRA.S    L05C36

5C30 L05C30        BSR.S    L05C48
                   BRA.S    L05C36

5C34 L05C34        BSR.S    L05C40
5C36 L05C36        BNE.S    L05C3E
                   SUBQ.W   #1,D3
                   BEQ.S    L05C3E
                   MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
5C3E L05C3E        RTS

Ú----------------------------------------------------------------------¿
³=CA_GTSTR             GET STRINGS                                             ³
³=CA_GTINT             GET INTEGERS                                            ³
³=CA_GTFP              GET FLOATING POINTS                                     ³
³=CA_GTLIN             GET LONG INTEGERS                                       ³
Ã----------------------------------------------------------------------´
³JOB:                                                                          ³
Ã----------------------------------------------------------------------´
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³                                                                              ³
³ERRORS:                                                                       ³
À----------------------------------------------------------------------Ù

5C40 CA_GTSTR      MOVEQ    #1,D0
5C42 L05C42        BRA.S    L05C50

5C44 CA_GTINT      MOVEQ    #3,D0
5C46 L05C46        BRA.S    L05C50

5C48 CA_GTFP       MOVEQ    #2,D0
5C4A L05C4A        BRA.S    L05C50

5C4C CA_GTLIN      MOVEQ    #5,D0
5C4E L05C4E        ROR.L    #1,D0
5C50 L05C50        MOVEM.L  D5/A4-5,-(A7)
                   MOVE.L   A3,-(A7)
                   MOVE.L   D0,-(A7)
                   MOVEQ    #0,D5
5C5A L05C5A        CMPA.L   4(A7),A5
                   BLE.S    L05C92
                   MOVEQ    #15,D6
                   AND.B    -7(A6,A5.L),D6
                   MOVE.B   D6,-7(A6,A5.L)
                   JSR      L0593E(PC)
                   BNE.S    L05C94
                   MOVE.L   (A7),D0
                   JSR      L0540C(PC)
                   MOVE.B   D6,-7(A6,A5.L)
                   TST.L    D0
                   BNE.S    L05C94
                   TST.L    (A7)
                   BPL.S    L05C8C
                   JSR      L04844(PC)
                   BNE.S    L05C94
                   MOVE.L   A1,BV.RIP(A6)
5C8C L05C8C        ADDQ.W   #1,D5
                   SUBQ.W   #8,A5
                   BRA.S    L05C5A

5C92 L05C92        MOVEQ    #0,D0
5C94 L05C94        ADDQ.W   #4,A7
5C96 L05C96        MOVE.L   D5,D3
                   MOVEA.L  (A7)+,A3
                   MOVEM.L  (A7)+,D5/A4-5
                   TST.L    D0
                   RTS

5CA2 L05CA2        ANDI.B   #$0F,-7(A6,A5.L)
5CA8 L05CA8        MOVEA.L  -4(A6,A5.L),A4
                   ADDA.L   BV.VVBAS(A6),A4
                   MOVEA.L  A4,A2
                   MOVE.L   0(A6,A4.L),D6
                   MOVE.W   4(A6,A4.L),D4
                   ADDQ.W   #6,A4
                   RTS

5CBE L05CBE        SUBA.L   BV.VVBAS(A6),A2
5CC2 L05CC2        SUBA.L   BV.VVBAS(A6),A4
                   MOVEM.L  A2/A4-5,-(A7)
                   JSR      L054F8(PC)
                   MOVEM.L  (A7)+,A2/A4-5
                   ADDA.L   BV.VVBAS(A6),A4
                   ADDA.L   BV.VVBAS(A6),A2
                   RTS

5CDC L05CDC        BSR.S    L05CA2
5CDE L05CDE        MOVEQ    #0,D5
5CE0 L05CE0        BSR.S    L05CBE
                   BLT.S    L05D3A
                   BEQ.S    L05CF2
                   CMPI.W   #SEP.TO,0(A6,A0.L)
                   BEQ.S    L05CFC
5CEE L05CEE        MOVEQ    #ERR.XP,D0             ;signal "error in expression"
                   BRA.S    L05D3A

5CF2 L05CF2        ADDQ.L   #2,BV.RIP(A6)
5CF6 L05CF6        MOVE.W   0(A6,A1.L),D5
                   BLT.S    L05D38
5CFC L05CFC        CMP.W    0(A6,A4.L),D5
                   BGT.S    L05D38
                   MOVE.W   D5,D0
                   MULU     2(A6,A4.L),D0
                   MOVE.B   -7(A6,A5.L),D1
                   SUBQ.B   #2,D1
                   BLT.S    L05D1A
                   BEQ.S    L05D16
                   ADD.L    D0,D0
                   BRA.S    L05D1A

5D16 L05D16        MULU     #6,D0
5D1A L05D1A        ADD.L    D0,D6
5D1C L05D1C        MOVEQ    #0,D0
                   MOVE.L   D6,0(A6,A2.L)
                   CMPI.W   #SEP.TO,0(A6,A0.L)
                   BNE.S    L05D50
                   ADDQ.W   #2,A0
                   BSR.S    L05CBE
                   BLT.S    L05D3A
                   BEQ.S    L05D3E
                   MOVE.W   0(A6,A4.L),D0
                   BRA.S    L05D4C

5D38 L05D38        MOVEQ    #ERR.OR,D0             ;signal "out of range"
5D3A L05D3A        BRA      L05E28

5D3E L05D3E        ADDQ.L   #2,BV.RIP(A6)
5D42 L05D42        MOVE.W   0(A6,A1.L),D0
                   CMP.W    0(A6,A4.L),D0
                   BGT.S    L05D38
5D4C L05D4C        SUB.W    D5,D0
                   BLT.S    L05D38
5D50 L05D50        MOVE.W   D0,0(A6,A4.L)
                   ADDQ.W   #4,A4
                   SUBQ.W   #1,D4
                   BNE.S    L05D84
                   CMPI.B   #1,-7(A6,A5.L)
                   BNE.S    L05D84
                   CLR.B    -7(A6,A5.L)
                   ADDQ.W   #1,-4(A6,A4.L)
                   ADDQ.L   #1,0(A6,A2.L)
                   TST.W    D5
                   BNE.S    L05D84
                   TST.W    D0
                   BNE.S    L05D38
                   SUBQ.L   #1,0(A6,A2.L)
                   SUBQ.W   #1,-4(A6,A4.L)
                   MOVE.B   #3,-7(A6,A5.L)
5D84 L05D84        MOVE.W   0(A6,A0.L),D0
                   ADDQ.W   #2,A0
                   CMPI.W   #SYM.RBKT,D0
                   BEQ.S    L05DA0
                   CMPI.W   #SEP.COM,D0
                   BNE      L05CEE
                   TST.W    D4
                   BGT      L05CDE
                   BRA.S    L05D38

5DA0 L05DA0        BSR      L05CA2
5DA4 L05DA4        MOVEA.L  (A6),A3
                   MOVE.L   0(A6,A2.L),0(A6,A3.L)
                   ADDQ.W   #6,A3
                   MOVEQ    #0,D0
5DB0 L05DB0        TST.W    0(A6,A4.L)
                   BEQ.S    L05DC0
                   MOVE.L   0(A6,A4.L),0(A6,A3.L)
                   ADDQ.W   #4,A3
                   ADDQ.W   #1,D0
5DC0 L05DC0        ADDQ.W   #4,A4
                   SUBQ.W   #1,D4
                   BGT.S    L05DB0
                   MOVEA.L  (A6),A3
                   MOVE.W   D0,4(A6,A3.L)
                   MOVE.W   4(A6,A2.L),D1
                   LSL.L    #2,D1
                   ADDQ.W   #6,D1
                   MOVE.L   A0,-(A7)
                   MOVE.L   A3,-(A7)
                   MOVEA.L  A2,A0
                   JSR      L050E2(PC)
                   MOVEA.L  (A7)+,A3
                   MOVEA.L  (A7)+,A0
                   MOVE.W   4(A6,A3.L),D1
                   BGT.S    L05DFC
                   TST.B    -7(A6,A5.L)
                   BEQ.S    L05DFC
                   MOVE.L   0(A6,A3.L),-4(A6,A5.L)
                   MOVE.B   #2,-8(A6,A5.L)
                   BRA.S    L05E26

5DFC L05DFC        LSL.L    #2,D1
5DFE L05DFE        ADDQ.W   #6,D1
                   MOVE.L   A0,-(A7)
                   MOVE.L   A3,-(A7)
                   JSR      L04EF0(PC)
                   MOVEA.L  A0,A2
                   MOVEA.L  (A7)+,A3
                   MOVEA.L  (A7)+,A0
                   MOVE.L   A2,D0
                   SUB.L    BV.VVBAS(A6),D0
                   MOVE.L   D0,-4(A6,A5.L)
5E18 L05E18        MOVE.W   0(A6,A3.L),0(A6,A2.L)
                   ADDQ.W   #2,A3
                   ADDQ.W   #2,A2
                   SUBQ.L   #2,D1
                   BGT.S    L05E18
5E26 L05E26        MOVEQ    #0,D0                  ;signal "no errors"
5E28 L05E28        RTS

5E2A L05E2A        MOVEM.L  D5-6/A2/A4,-(A7)
5E2E L05E2E        CMPI.B   #1,-8(A6,A5.L)
                   BEQ.S    L05E48
                   MOVE.L   -4(A6,A5.L),D0
                   BLT.S    L05E44
                   MOVEA.L  BV.VVBAS(A6),A2
                   ADDA.L   D0,A2
                   BRA.S    L05E5E

5E44 L05E44        MOVEQ    #ERR.XP,D0             ;signal "error in expression"
5E46 L05E46        BRA.S    L05E98

5E48 L05E48        MOVE.L   A0,-(A7)
5E4A L05E4A        JSR      L054AA(PC)
                   MOVEQ    #0,D7
                   MOVE.L   A1,BV.RIP(A6)
                   MOVEA.L  A0,A2
                   MOVEA.L  (A7)+,A0
                   MOVE.L   A2,D0
                   SUB.L    BV.VVBAS(A6),D0
5E5E L05E5E        MOVE.L   D0,-(A7)
                   BSR.S    L05EA0
                   MOVEA.L  BV.VVBAS(A6),A2
                   ADDA.L   (A7)+,A2
                   BNE.S    L05E7A
                   MOVEA.L  A2,A4
                   ADDQ.W   #2,A4
                   SUBQ.W   #1,D5
                   ADDA.W   D5,A4
                   MOVE.W   D6,D1
                   SUB.W    D5,D1
                   JSR      L059FE(PC)
5E7A L05E7A        MOVE.L   D0,-(A7)
                   CMPI.B   #1,-8(A6,A5.L)
                   BNE.S    L05E8E
                   MOVE.L   A0,-(A7)
                   MOVEA.L  A2,A0
                   JSR      L054DC(PC)
                   MOVEA.L  (A7)+,A0
5E8E L05E8E        MOVE.L   (A7)+,D0
                   BNE.S    L05E98
                   MOVE.B   #1,-8(A6,A5.L)
5E98 L05E98        MOVEM.L  (A7)+,D5-6/A2/A4
                   TST.L    D0
                   RTS

5EA0 L05EA0        MOVE.W   0(A6,A2.L),-(A7)
5EA4 L05EA4        JSR      L054F8(PC)
                   BLT.S    L05EF0
                   BGT.S    L05EF8
                   ADDQ.L   #2,BV.RIP(A6)
                   MOVE.W   0(A6,A1.L),D5
                   BLE.S    L05EF8
                   CMP.W    (A7),D5
                   BGT.S    L05EF8
                   MOVE.W   D5,D6
                   CMPI.W   #SEP.TO,0(A6,A0.L)
                   BNE.S    L05EDC
                   ADDQ.W   #2,A0
                   JSR      L054F8(PC)
                   BLT.S    L05EF0
                   BGT.S    L05EDA
                   ADDQ.L   #2,BV.RIP(A6)
                   MOVE.W   0(A6,A1.L),D6
                   CMP.W    (A7),D6
                   BLE.S    L05EDC
5EDA L05EDA        MOVE.W   (A7),D6
5EDC L05EDC        MOVE.W   D6,D0
                   ADDQ.W   #1,D0
                   SUB.W    D5,D0
                   BLT.S    L05EF8
                   CMPI.W   #SYM.RBKT,0(A6,A0.L)
                   BNE.S    L05EF4
                   ADDQ.W   #2,A0
                   MOVEQ    #0,D0                  ;signal "no errors"
5EF0 L05EF0        ADDQ.W   #2,A7
                   RTS

5EF4 L05EF4        MOVEQ    #ERR.XP,D0             ;signal "error in expression"
                   BRA.S    L05EF0

5EF8 L05EF8        MOVEQ    #ERR.OR,D0             ;signal "out of range"
                   BRA.S    L05EF0

5EFC L05EFC        MOVE.L   A4,-(A7)
                   MOVEQ    #15,D0
                   AND.B    -7(A6,A5.L),D0
                   SUBQ.B   #1,D0
                   BEQ.S    L05F30
                   MOVEQ    #0,D0
                   MOVE.W   -6(A6,A5.L),D0
                   BLT.S    L05F36
                   MOVEA.L  BV.NTBAS(A6),A1
                   LSL.L    #3,D0
                   ADDA.L   D0,A1
                   MOVEA.L  BV.NLBAS(A6),A0
                   ADDA.W   2(A6,A1.L),A0
                   MOVEQ    #0,D1
                   MOVE.B   0(A6,A0.L),D1
                   LEA      1(A0),A4
                   JSR      L059FE(PC)
                   BRA.S    L05F38

5F30 L05F30        JSR      L0593E(PC)
                   BRA.S    L05F38

5F36 L05F36        MOVEQ    #ERR.BN,D0             ;signal "bad name"
5F38 L05F38        MOVEA.L  (A7)+,A4
                   RTS


;part 16
2.20 SuperBASIC procedures.

Ú----------------------------------------------------------------------¿
³=BP_BAUD         SET BAUD RATE FOR SERIAL CHANNELS                            ³
Ã----------------------------------------------------------------------´
³SYNTAX:          rate := numeric_expression                                   ³
³                                                                              ³
³                 BAUD rate                                                    ³
Ã----------------------------------------------------------------------´
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:            none                                                         ³
³                                                                              ³
³ERRORS:          ERR.BP   invalid baud rate                                   ³
À----------------------------------------------------------------------Ù

   This is the first of the SUPERBASIC procedures and functions command
   handlers. Note that unlike the spectrum, only a few of these routines
   check the syntax of the SUPERBASIC statement and most only expect to be
   followed by a particular number of parameters.
   The syntax definitions are given along with the other entry conditions
   and use the standard notation given in the user guide in the "concepts"
   section.

5F3C BP_BAUD       JSR      L078D0(PC)             ;check for one integer parameter
                   BNE.S    BAUD_EXI               ;and exit if none
                   MOVE.W   TOS(A6,A1.L),D1        ;get the required baud rate
                   MOVEQ    #MT.BAUD,D0            ;TRAP to set serial port baud rate
                   TRAP     #1                     ;set it
                   TST.L    D0                     ;any errors ?
                   BMI.S    BAUD_ERR               ;jump forward if so
                   MOVEQ    #0,D0                  ;signal "no errors"
5F50 BAUD_EXI      RTS

5F52 BAUD_ERR      MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
                   RTS

Ú----------------------------------------------------------------------¿
³=BP_BEEP         SWITCH SOUND ON OR OFF                                       ³
Ã----------------------------------------------------------------------´
³SYNTAX: duration and grad_x := mumeric_expression {-32768 .. 32767}           ³
³        pitch_1 and pitch_2 := numeric_expression {0 .. 255}                  ³
³        grad_y := numeric_expression {-8 .. 7}                                ³
³        wrap,fuzzy and random := numeric_expression {0 .. 15}                 ³
³                                                                              ³
³        BEEP [ duration, pitch_1                                              ³
³             [ , pitch_2, grad_x, grad_y                                      ³
³             [ , wrap                                                         ³
³             [ , fuzzy                                                        ³
³             [ , random ]]]]]                                                 ³
Ã----------------------------------------------------------------------´
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À----------------------------------------------------------------------Ù

   The parameters are not given in the same order as they occur in the
   IPC command so this table gives the position in the command string for
   the corresponding parameter in the SUPERBASIC statement.

5F56 BEEPTBL       DC.W     6        duration
                   DC.W     0        pitch
                   DC.W     2        pitch_2
                   DC.W     4        grad_x
                   DC.W     8        grad_y
                   DC.W     10       wrap
                   DC.W     14       fuzzy
                   DC.W     12       random

5F66 BEEP_EXI      ADD.L    D3,D3                  ;form number of bytes used on stack
                   ADD.L    D3,BV.RIP(A6)          ;update arithmetic stack pointer
5F6C BEEP_END      ADDA.W   #$18,A7                ;restore stack and registers
                   MOVEM.L  (A7)+,D4-7/A3-5
                   TST.L    D0                     ;set flags to test for any errors
                   RTS

5F78 BP_BEEP       JSR      CA_GTINT(PC)           ;get word integers,D3 = number found
                   MOVEM.L  D4-7/A3-5,-(A7)
                   ADDA.W   #-$18,A7               ;A7 points at parameter block on stack
                   MOVEA.L  A7,A3                  ;copy pointer
                   BNE.S    BEEP_EXI               ;and exit if error in expression

                   MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
                   CMPI.W   #0,D3                  ;command to stop sound ?
                   BEQ.S    SOUNDOFF               ;jump forward if so

   Valid no's of parameters are : 2,5,6,7 and 8.

                   CMPI.W   #1,D3                  ;invalid number ?
                   BEQ.S    BEEP_EXI               ;exit if so
                   CMPI.W   #3,D3
                   BEQ.S    BEEP_EXI
                   CMPI.W   #4,D3
                   BEQ.S    BEEP_EXI
                   CMPI.W   #8,D3                  ;more then 8 parameters ?
                   BGT.S    BEEP_EXI               ;exit if so

                   LEA      BEEPTBL(PC),A5         ;A5 points at table of parameter numbers
                   MOVEQ    #1,D2                  ;initialise parameter count
5FAE L05FAE        MOVE.W   TOS(A6,A1.L),D0        ;get parameter from arithmetic stack
                   CMPI.W   #2,D2                  ;pitch ?
                   BEQ.S    L05FBE                 ;process parameter if so
                   CMPI.W   #3,D2                  ;pitch_2 ?
                   BNE.S    L05FC0                 ;jump forward if not

5FBE L05FBE        ADDQ.W   #1,D0                  ;add one to pitch value
5FC0 L05FC0        ROR.W    #8,D0                  ;and swop high & low bytes around
                   JSR      BEEP_INS(PC)           ;insert in IPC command string
                   ADDA.W   #2,A1                  ;point at next paramter
                   CMP.W    D3,D2                  ;finished ?
                   BLE.S    L05FAE                 ;next entry if not

                   CMPI.W   #3,D2                  ;duration and pitch only ?
                   BEQ.S    L05FDC
5FD4 L05FD4        MOVEQ    #0,D0                  ;signal "no errors"
                   CMPI.W   #8,D2                  ;all parameters specified ?
                   BGT.S    SOUNDON                ;do command if so
5FDC L05FDC        JSR      BEEP_INS(PC)           ;otherwise insert extra parameters
                   BRA.S    L05FD4                 ;and do command

5FE2 SOUNDON       MOVE.B   #10,(A3)               ;"initiate sound process" command
                   MOVE.B   #16,1(A3)              ;number of parameters to follow
                   MOVE.L   #$4444AA66,$2(A3)      ;number of bits to send from each
                   MOVE.B   #1,$16(A3)             ;signal "send number reply"
                   MOVEQ    #MT.IPCOM,D0           ;TRAP to send command to IPC
                   TRAP     #1
                   BRA      BEEP_EXI

6002 SOUNDOFF      MOVE.B   #11,(A3)               ;"kill sound process" command
                   MOVE.B   #0,1(A3)               ;number of parameters to follow
                   MOVE.B   #1,6(A3)               ;signal "send number reply"
                   MOVEQ    #MT.IPCOM,D0           ;TRAP to send command to IPC
                   TRAP     #1
                   BRA      BEEP_END

   Insert parameters into IPC command string.

601A BEEP_INS      MOVEA.W  (A5)+,A4               ;get parameter position
                   MOVE.W   D0,6(A3,A4.W)          ;insert the parameter
                   ADDQ.W   #1,D2                  ;increment parameter count
                   RTS

Ú----------------------------------------------------------------------¿
³=BP_CALL         CALL MACHINE CODE ROUTINE                                    ³
Ã----------------------------------------------------------------------´
³SYNTAX:          address : numeric_expression                                 ³
³                 data := numeric_expression                                   ³
³                                                                              ³
³                 CALL address *[, data]* {13 parameters maximum}              ³
Ã----------------------------------------------------------------------´
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:          ERR.BP   invalid number of parameters                        ³
À----------------------------------------------------------------------Ù

   This procedure executes machine code as a subroutine. The address given
   must be even otherwise the RTS at the end will generate an address error
   which merely re-executes the RTS which this time is OK. The command is
   therefore ignored for odd addresses. The following parameters are then
   stored in the registers in the order D1 to D7 and A0 to A5. The routine
   will be executed in user mode.

6024 BP_CALL       JSR      CA_GTLIN(PC)           ;get long integers,D3 = number found
                   BNE.S    L0603E                 ;jump forward if any errors
                   LSL.L    #2,D3                  ;form number of bytes used
                   BEQ.S    L0603C                 ;jump forward if none given
                   ADD.L    D3,BV.RIP(A6)          ;restore maths stack

   The next two instructions were supposed to get the call address and the
   register values from the arithmetic stack, but this will only work if
   basic occupies less than around 20k because of the word accesses used.

                   MOVE.L   TOS(A6,A1.W),-(A7)
                   MOVEM.L  4(A6,A1.W),D1-7/A0-5

603C L0603C        MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
603E L0603E        RTS                             ;"return" to required routine

Ú----------------------------------------------------------------------¿
³=                                                                             ³
Ã----------------------------------------------------------------------´
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À----------------------------------------------------------------------Ù

6040 L06040        MOVEQ    #1,D1
                   MOVE.L   A5,-(A7)
                   CMPA.L   A3,A5                  ;any parameters in name table ?
                   BLS.S    L06076                 ;jump forward if none
                   BCLR     #7,1(A6,A3.L)          ;parameter preceded by "#" ?
                   BEQ.S    L06076                 ;jump forward if so
                   MOVE.L   A3,-(A7)
                   LEA      8(A3),A5               ;A5 points at next parameter in name tab

   Mask off but the variable type field in the name table type word entry.

                   ANDI.B   #%00001111,1(A6,A3.L)
                   JSR      L0593E(PC)
                   BNE.S    L0609C
                   MOVEQ    #3,D0
                   JSR      L0540C(PC)
                   BNE.S    L0609C
                   MOVEA.L  (A7)+,A3
                   ADDQ.W   #8,A3
                   MOVE.W   TOS(A6,A1.L),D1
                   ADDQ.L   #2,BV.RIP(A6)          ;restore maths stack
6076 L06076        MOVEA.L  (A7)+,A5

Ú----------------------------------------------------------------------¿
³=GETCHID         GET SUPERBASIC CHANNEL INFORMATION FROM ID                   ³
------------------------------------------------------------------------------
³ENTRY:           D1.L     SUPERBASIC channel ID                               ³
³                 A6.L     SUPERBASIC system variables                         ³
³                                                                              ³
³EXIT:            A0.L     channel ID                                          ³
³                 A2.L     pointer to channel table block                      ³
³                                                                              ³
³ERRORS:          ERR.NO   channel not found                                   ³
À------------------------------------------------------------------------------Ù

   SUPERBASIC has it's own channel table containing extra information to
   handle Turtle graphics and printers. There is one entry for each channel
   open. Each entry is $28 bytes long and is laid out as follows:=

   1.     $00      CH.ID    long     QDOS channel ID (-1 if closed)
   2.     $04      CH.CCPY  f.p.     current graphics y co-ordinate
   3.     $0A      CH.CCPX  f.p.     current graphics x co-ordinate
   4.     $10      CH.ANGLE f.p.     Turtle angle
   5.     $16      CH.PEN   byte     pen status: 0 = up , 1 = down
   6.     $20      CH.CHPOS word     printer cursor position across line
   7.     $22      CH.WIDTH word     printer width in characters
   8.     $24      CH.SPARE long
   9.     $28      CH.LENCH          end of channel block

6078 GETCHID       MOVE.L   D1,D0                  ;copy channel number
                   MOVEA.L  BV.CHBAS(A6),A0        ;A0 points at SUPERBASIC channel table
                   MULU     #$28,D0                ;form  block offset
                   ADDA.L   D0,A0                  ;A0 points at entry for this ID
                   CMPA.L   BV.CHP(A6),A0          ;end of table ?
                   BGE.S    L06098                 ;exit if so
                   MOVE.L   CH.ID(A6,A0.L),D0
                   BLT.S    L06098                 ;and exit if channel closed
                   MOVEA.L  A0,A2                  ;copy pointer to block and channel ID
                   MOVEA.L  D0,A0
                   MOVEQ    #0,D0                  ;signal "no errors"
                   RTS

6098 L06098        MOVEQ    #ERR.NO,D0             ;signal "channel not open"
                   RTS

609C L0609C        ADDQ.W   #8,A7                  ;restore stack
                   RTS

60A0 L060A0        MOVE.L   A0,-(A7)
                   BSR.S    GETCHID                ;get channel info from ID
                   BEQ.S    L060F8                 ;exit if already exists
                   CMPA.L   BV.CHP(A6),A0          ;end of table ?
                   BLT.S    L060DA                 ;jump forward if not

   There are not enough entries in the current SUPERBASIC channel table
   so increase it's size to suit the new channel no.

                   MOVE.L   D1,-(A7)
                   MOVE.L   A0,D1                  ;D1 points at channel table block
   60b0                ADDI.L   #$28,D1                ;point at next block
     b6              SUB.L    BV.CHP(A6),D1          ;make it relative
     ba              JSR      CA_ALCHB(PC)           ;reserve space for new entry(s)
     be              MOVE.L   (A7)+,D1
     c0              BSR.S    GETCHID                ;get channel info from ID
60C2 L060C2        MOVEA.L  BV.CHP(A6),A2          ;A2 points at current channel table entr
                   ADDI.L   #$28,BV.CHP(A6)        ;set pointer to end of table
                   MOVE.L   #-1,CH.ID(A6,A2.L)     ;signal "closed"
                   CMPA.L   A0,A2
                   BLT.S    L060C2
60DA L060DA        MOVEA.L  A0,A2

   Now clear the channel table entry.

                   MOVEQ    #10,D0                 ;11 long words to clear
60DE L060DE        CLR.L    0(A6,A0.L)             ;clear one
                   ADDQ.W   #4,A0                  ;and point at next one
                   SUBQ.W   #1,D0                  ;any more ?
                   BGT.S    L060DE                 ;clear next one if so

   Then set up the channel ID and the default printer width.

                   MOVEA.L  (A7)+,A0
                   MOVE.L   A0,CH.ID(A6,A2.L)      ;copy channel ID to entry
                   MOVE.W   #80,CH.WIDTH(A6,A2.L)
  60f4                 MOVEQ    #0,D0                  ;signal "no errors"
                   RTS

60F8 L060F8        MOVEQ    #ERR.EX,D0             ;signal "already exists"
                   RTS

Ú------------------------------------------------------------------------------¿
³=BP_CSIZE        SET A NEW CHARACTER SIZE                                     ³
------------------------------------------------------------------------------
³SYNTAX:          width := numeric_expression {0 .. 3}                         ³
³                 height := numeric_expression {0 .. 1}                        ³
³                 channel := #numeric_expression                               ³
³                                                                              ³
³                 CSIZE [channel,] width, height                               ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

60FC BP_CSIZE      JSR      L078CA(PC)
                   BNE.S    L0611E
                   SUBQ.W   #1,D3
                   JSR      L078BA(PC)
                   BNE.S    L0611E
                   MOVE.W   -2(A6,A1.L),D2
                   EXG      D1,D2
                   CMPI.W   #3,D1
                   BHI.S    L0611C
                   MOVEQ    #$2D,D4
                   JMP      L07856(PC)

611C L0611C        MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
611E L0611E        RTS

Ú------------------------------------------------------------------------------¿
³=BP_CURSO        POSITION CURSOR WITH GRAPHIC CO-ORDS                         ³
------------------------------------------------------------------------------
³SYNTAX:          x := numeric_expression                                      ³
³                 y := numeric_expression                                      ³
³                                                                              ³
³                 CURSOR [channel,] x, y [, x, y]                              ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

6120 BP_CURSO      MOVEQ    #-$20,D0
                   ADD.L    A5,D0
                   SUB.L    A3,D0
                   BEQ      L06626
                   MOVEQ    #$17,D4
                   BRA.S    L06130

Ú------------------------------------------------------------------------------¿
³=BP_AT           POSITION CURSOR at CHARACTER CO-ORDS                         ³
------------------------------------------------------------------------------
³SYNTAX:          line := numeric_expression                                   ³
³                 column := numeric-expression                                 ³
³                                                                              ³
³                 AT [channel,] line, column                                   ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

612E BP_AT         MOVEQ    #16,D4
6130 L06130        JSR      L078CA(PC)
                   BNE.S    L06152
                   CMPI.W   #2,D3
                   BNE.S    L06150
                   MOVE.W   TOS(A6,A1.L),D2
                   MOVE.W   -2(A6,A1.L),D1
                   CMPI.B   #16,D4
                   BNE.S    L0614C
                   EXG      D1,D2
614C L0614C        JMP      L07856(PC)

6150 L06150        MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
6152 L06152        RTS

Ú------------------------------------------------------------------------------¿
³=                                                                             ³
------------------------------------------------------------------------------
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

6154 L06154        MOVE.L   BV.LINUM(A6),-(A7)
                   MOVE.L   BV.INLIN(A6),-(A7)
                   MOVE.W   BV.STMNT(A6),-(A7)
                   MOVE.L   A4,-(A7)
                   JSR      L08D70(PC)
                   BNE.S    L061DE
                   MOVE.W   BV.DALNO(A6),D4        ;get current DATA line number
                   JSR      L09694(PC)
                   JSR      L09F46(PC)
                   BNE.S    L061DE
                   MOVE.B   BV.DASTM(A6),D4        ;get current DATA statement number
                   JSR      L096FC(PC)
                   JSR      L09B92(PC)
                   CMPI.W   #$8118,D1              ;keyword token,"DATA" ?
                   BNE.S    L061A4
                   MOVE.B   BV.DAITM(A6),D5        ;get DATA item count
                   ADDQ.B   #1,BV.DAITM(A6)        ;and increment it for next time

6190 L06190        ADDQ.W   #2,A4
                   JSR      L09B92(PC)
                   SUBQ.B   #1,D5
                   BEQ.S    L061C8
                   MOVE.W   #$8404,D4              ;symbol, ??
                   JSR      L09C02(PC)
                   BEQ.S    L06190

   Scan through the program for the next DATA statement.

61A4 L061A4        JSR      L09C30(PC)
                   BNE.S    L061DE                 ;jump forward if none left
                   JSR      L09B92(PC)
                   CMPI.W   #$8118,D1              ;keyword token, "DATA" ?
                   BNE.S    L061A4                 ;next statement if not

   The next DATA statement has been found so update the variables.

                   ADDQ.W   #2,A4
                   MOVE.W   BV.LINUM(A6),BV.DALNO(A6)
                   MOVE.B   BV.STMNT(A6),BV.DASTM(A6)
                   MOVE.B   #2,BV.DAITM(A6)
61C8 L061C8        MOVEA.L  A4,A0
                   MOVEQ    #0,D0                  ;signal "no errors"
61CC L061CC        MOVEA.L  (A7)+,A4
                   MOVE.W   (A7)+,BV.STMNT(A6)
                   MOVE.L   (A7)+,BV.INLIN(A6)
                   MOVE.L   (A7)+,BV.LINUM(A6)
                   TST.L    D0                     ;set flags for interpreter
                   RTS

61DE L061DE        MOVEQ    #ERR.EF,D0             ;signal "end of file"
                   BRA.S    L061CC

Ú------------------------------------------------------------------------------¿
³=SD_ADATE        ADJUST SYSTEM CLOCK                                          ³
------------------------------------------------------------------------------
³SYNTAX:          seconds := numeric_expression                                ³
³                                                                              ³
³                 ADATE seconds                                                ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

61E2 BP_ADATE      JSR      L05C2C(PC)
                   BNE.S    L06208                 ;exit if number parameters or wrong type
                   ADDQ.L   #4,BV.RIP(A6)          ;restore maths stack
                   MOVE.L   TOS(A6,A1.L),D1        ;get the adjustment required
                   MOVEQ    #MT.ACLK,D0            ;TRAP to adjust clock
                   TRAP     #1                     ;adjust it
                   BRA.S    EXIT_CLK

Ú------------------------------------------------------------------------------¿
³=BP_SDATE        RESET SYSTEM CLOCK                                           ³
------------------------------------------------------------------------------
³SYNTAX:          year,month,day,                                              ³
³                 hours,minutes and seconds := numeric_expression              ³
³                                                                              ³
³                 SDATE year, month, day, hours, minutes, seconds              ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

61F6 BP_SDATE      JSR      CA_GTLIN(PC)           ;get long integers,D3 = number found
                   BNE.S    CLK_END                ;exit if none given
                   MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
                   LSL.L    #2,D3                  ;form amount of stack used
                   ADD.L    D3,BV.RIP(A6)          ;and adjust the maths stack pointer
                   LSR.L    #2,D3                  ;restore number of parameters
                   SUBQ.W   #6,D3                  ;and check if six given
6208 L06208        BNE.S    CLK_END                ;exit if wrong number of parameters
                   MOVE.L   TOS(A6,A1.L),D0        ;get the year
                   SUBI.L   #1961,D0               ;subtract base year
                   MOVE.L   D0,D1
                   MULU     #365,D1                ;form number of days
                   MOVE.L   4(A6,A1.L),D2          ;get month
                   DIVU     #4,D0                  ;check for a leap year
                   SWAP     D0
                   CMPI.W   #3,D0
                   BNE.S    L06232
                   CMPI.W   #2,D2                  ;after or including February ?
                   BLE.S    L06232                 ;jump forward if not
                   ADDQ.L   #1,D1                  ;otherwise add one for extra day
6232 L06232        CLR.W    D0
                   SWAP     D0
                   ADD.L    D0,D1                  ;add correction for leap year if any
                   SUBQ.L   #1,D2                  ;form offset into month table
                   ASL.W    #1,D2
                   LEA      MONTHTBL(PC,D2.W),A2
                   CLR.L    D0                     ;prepare D0
                   MOVE.W   (A2),D0                ;get the cummulative number of days
                   ADD.L    D0,D1                  ;add to total so far
                   ADD.L    8(A6,A1.L),D1          ;add day parameter
                   SUBQ.W   #1,D1
                   MOVEQ    #24,D0                 ;hours in a day
                   BSR.S    L06284                 ;form number of hours
                   ADD.L    12(A6,A1.L),D1         ;add hours parameter
                   MOVEQ    #60,D0                 ;minutes/hour and seconds/minute
                   BSR.S    L06284                 ;form number of minutes
                   ADD.L    16(A6,A1.L),D1         ;add minutes parameter
                   BSR.S    L06284                 ;form number of seconds
                   ADD.L    20(A6,A1.L),D1         ;add seconds parameter
                   MOVEQ    #MT.SCLK,D0            ;TRAP to set clock
                   TRAP     #1                     ;set it
6266 EXIT_CLK      MOVEQ    #0,D0                  ;signal "no errors"
6268 CLK_END       TST.L    D0                     ;set flags for interpreter
                   RTS

   Table of cummulative days in each month.

626C MONTHTBL      DC.W     0,31,59,90,120,151,181 ;jan,feb,mar,apr,may,jun,jul
                   DC.W     212,243,273,304,334    ;aug,sep,oct,nov,dec

6284 L06284        BSR.S    L062A8
                   MOVE.L   D4,D3
                   SWAP     D0
                   SWAP     D1
                   BSR.S    L062A8
                   MOVE.L   D4,D2
                   SWAP     D0
                   SWAP     D3
                   BSR.S    L062A8
                   BSR.S    L062AE
                   SWAP     D0
                   SWAP     D1
                   BSR.S    L062A8
                   BSR.S    L062AE
                   SWAP     D3
                   SWAP     D0
                   MOVE.L   D3,D1
                   RTS

62A8 L062A8        MOVE.L   D0,D4
                   MULU     D1,D4
                   RTS

62AE L062AE        ADD.W    D4,D3
                   CLR.W    D4
                   SWAP     D4
                   ADDX.L   D4,D2
                   RTS

Ú------------------------------------------------------------------------------¿
³=BP_READ         ASSIGN DATA TO LIST OF VARIABLES                             ³
------------------------------------------------------------------------------
³SYNTAX:          READ *[identifier,]* {see "concepts" in user guide}          ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

62B8 BP_READ       MOVE.L   A5,-(A7)
62BA L062BA        CMPA.L   (A7),A3                ;end of name table ?
                   BGE.S    L062E0                 ;exit if so
                   JSR      L0737C(PC)
                   BNE.S    L062E2
                   JSR      L06154(PC)             ;get next DATA item
                   BNE.S    L062E2                 ;exit if end of data statements
                   MOVE.B   1(A6,A3.L),D0          ;get seperator type
                   MOVE.L   A3,-(A7)
                   JSR      L054FA(PC)             ;evaluate the identifier
                   MOVEA.L  (A7)+,A3
                   BNE.S    L062E2                 ;exit if wrong type
                   JSR      BP_LET(PC)             ;assign the value to the variable
                   ADDQ.W   #8,A3                  ;next entry in name table
                   BRA.S    L062BA                 ;try next identifier

62E0 L062E0        MOVEQ    #0,D0                  ;signal "no errors"
62E2 L062E2        MOVEA.L  (A7)+,A5
                   RTS

Ú------------------------------------------------------------------------------¿
³=BP_EXEC         LOAD A MACHINE CODE PROGRAM and RETURN                       ³
³=BP_EXECW        LOAD A MACHINE CODE PROGRAM and WAIT                         ³
------------------------------------------------------------------------------
³SYNTAX:          program := device {see "concepts" in user guide}             ³
³                                                                              ³
³                 EXEC   program                                               ³
³                 EXEC_W program                                               ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:          ERR.BP   not an executable file                              ³
À------------------------------------------------------------------------------Ù

   This procedure implements the standard way of loading executable files
   from any specified device, normally a microdrive or floppy disc, that
   can be loaded as multitasking jobs. The EXEC_W version will wait until
   the job is finished before returning control to SUPERBASIC, the EXEC
   version returns control immediately. An attempt to execute a file that
   was not created using SEXEC will result in a bad parameter error.

62E6 BP_EXEC       MOVEQ    #0,D5                  ;set timeout to return immediately
                   BRA.S    L062EC

62EA BP_EXECW      MOVEQ    #-1,D5                 ;set timeout to return when finished
62EC L062EC        MOVEQ    #1,D4                  ;signal "old shared device"
                   BSR      DOIOOPEN               ;open a channel
                   BNE      BP_EXIT                ;and exit if any errors

   First of all read the file header and allocate the required space for
   the code and data areas according to the header contents then start the
   job with a priority of 32.

                   MOVEQ    #FS.HEADR,D0           ;TRAP to read file header
                   MOVEQ    #14,D2                 ;length of header
                   MOVEA.L  (A6),A1                ;A1 points at keyboard buffer base
                   BSR      DOTRAP3                ;read the header into the buffer
                   BNE      DO_CLOSE               ;and exit if any errors
                   CMPI.B   #1,-9(A6,A1.L)         ;is it an executable file ?
                   BNE      L063DE                 ;exit if not

   Create space for the job in the transient program area using the data
   from the file header.

                   MOVEQ    #MT.CJOB,D0            ;TRAP to create a job
                   MOVEQ    #-1,D1                 ;use an infinite timeout
                   MOVE.L   -14(A6,A1.L),D2        ;get code space required
                   MOVE.L   -8(A6,A1.L),D3         ;and get data space required
                   SUBA.L   A1,A1                  ;signal "use jb_end as start"
                   MOVEM.L  D2/A0/A3,-(A7)
                   TRAP     #1                     ;create the job,A0 points at area on exi
                   MOVEA.L  A0,A1
                   MOVEM.L  (A7)+,D2/A0/A3
                   TST.L    D0                     ;any errors ?
                   BNE      DO_CLOSE               ;close the channel if so

   Now load in the actual code of the job into the job arae.

                   MOVE.L   D1,D6                  ;save the job ID
                   MOVEQ    #FS.LOAD,D0            ;TRAP to load a file
                   BSR      DO_TRAP3               ;load it
                   BSR      DO_CLOSE               ;then close the channel
                   BNE.S    BP_RJOB                ;and remove the job if any errors

   The job is now in memory so activate it.

                   MOVEQ    #MT.ACTIV,D0           ;TRAP to activate a job
                   MOVE.L   D6,D1                  ;restore job ID
                   MOVEQ    #32,D2                 ;job priority
                   MOVE.L   D5,D3                  ;set timout according to exec type

   Note that for EXEC, control will be returned to the current job but for
   EXEC_W, the current job will wait until this one has finished. Hence an
   EXEC_W command call will cause one job to be run at the expense of all
   the others in the system including SUPERBASIC and therefore this job must
   terminate for multitasking to be resumed again.

                   TRAP     #1                     ;activate the job
                   TST.L    D0                     ;any errors ?
                   BEQ      BP_EXIT                ;exit if none

   Remove the job from the transient program area as an error has occured.

634C BP_RJOB       MOVE.L   D0,D4
                   MOVEQ    #MT.RJOB,D0            ;TRAP to remove a job
                   MOVE.L   D6,D1                  ;get the job's ID
                   TRAP     #1                     ;remove it
                   BRA      BP_END

Ú------------------------------------------------------------------------------¿
³=BP_LBYTE        LOAD DATA FILE INTO MEMORY                                   ³
------------------------------------------------------------------------------
³SYNTAX:          start_address := numeric_expression                          ³
³                                                                              ³
³                 LBYTES device, start_address                                 ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

   This procedure is used to load machine code or data into memory at a
   specific address.

6358 BP_LBYTE      MOVEQ    #1,D4                  ;signal "old exclusive device"
                   BSR      DOIOOPEN               ;open a channel
                   BNE.S    BP_EXIT                ;and exit if any errors
                   JSR      CA_GTLIN(PC)           ;get long integers,D3 = number found
                   BNE.S    DO_CLOSE               ;and close the channel if wrong type
                   SUBQ.W   #1,D3                  ;check for one integer
                   BNE.S    L063DE                 ;exit if invalid number
                   BTST     #0,3(A6,A1.L)          ;start address even ?
                   BNE.S    L063DE                 ;exit if not
                   MOVEA.L  TOS(A6,A1.L),A1        ;get the address
                   ADDQ.L   #4,BV.RIP(A6)          ;restore maths stack
                   MOVEQ    #FS.HEADR,D0           ;TRAP to read file header
                   MOVEQ    #14,D2                 ;length of header
                   MOVE.L   A1,-(A7)
                   BSR.S    DO_TRAP3               ;read it
                   MOVEA.L  (A7)+,A1
                   BNE.S    DO_CLOSE               ;exit if any errors
                   MOVE.L   (A1),D2
                   MOVEQ    #FS.LOAD,D0            ;TRAP to load a file
                   BSR.S    DO_TRAP3               ;load it
                   BRA.S    DO_CLOSE               ;and close the channel

Ú------------------------------------------------------------------------------¿
³=BP_SEXEC        SAVE AN EXECUTABLE PROGRAM FILE                              ³
³=BP_SBYTE        SAVE AN AREA OF MEMORY TO A DEVICE                           ³
------------------------------------------------------------------------------
³SYNTAX:          start_address := numeric_expression                          ³
³                 length := numeric_expression                                 ³
³                 data_space := numeric_expression                             ³
³                                                                              ³
³                 SEXEC  device, start_address, length, data_space             ³
³                 SBYTES device, start_address, length                         ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

   The procedure SEXEC is used for generating executable program files that
   can be run as multitasking jobs. The start address parameter is not in
   fact saved along with the code since jobs are meant to always contain
   relocatable code as there is number way of guaranteeing that the code will
   be loaded at a particular location due to the way EXEC and EXEC_W work.
   The data space parameter however is saved as this is needed when the job
   is created prior to loading the code. SBYTE is actually only used when a
   particular block of memory, such as a screen dump, is to be saved. Again
   only the length parameter is saved with the data.

638E BP_SEXEC      MOVEQ    #1,D5
                   BRA.S    L06394

6392 BP_SBYTE      MOVEQ    #0,D5
6394 L06394        MOVEQ    #2,D4
                   BSR.S    DOIOOPEN               ;open the channel
                   BNE.S    BP_EXIT                ;and exit if there were any errors
                   JSR      CA_GTLIN(PC)           ;get long integers,D3 = number found
                   BNE.S    DO_CLOSE               ;close the channel if any errors
                   SUBQ.W   #2,D3
                   SUB.W    D5,D3
                   BNE.S    L063DE
                   MOVEA.L  TOS(A6,A1.L),A2
                   ADDQ.W   #2,A1
                   MOVE.L   2(A6,A1.L),TOS(A6,A1.L)
                   MOVE.W   D5,4(A6,A1.L)
                   MOVEQ    #FS.HEADS,D0           ;TRAP to set file header
                   MOVE.L   A1,-(A7)
                   BSR.S    DOTRAP3                ;set the header
                   MOVEA.L  (A7)+,A1
                   BNE.S    DO_CLOSE               ;close the channel
                   MOVE.L   TOS(A6,A1.L),D2
                   ADDQ.W   #6,A1
                   LSL.W    #4,D5
                   ADDA.W   D5,A1
                   MOVE.L   A1,BV.RIP(A6)
                   MOVEA.L  A2,A1
                   MOVEQ    #FS.SAVE,D0            ;TRAP to save a file
                   BSR.S    DO_TRAP3               ;save it

63D4 DO_CLOSE      MOVE.L   D0,D4
                   MOVEQ    #IO.CLOSE,D0           ;TRAP to close a file
                   TRAP     #2                     ;close it
63DA BP_END        MOVE.L   D4,D0
63DC BP_EXIT       RTS

63DE L063DE        MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
                   BRA.S    DO_CLOSE               ;and close the channel

63E2 L063E2        ADDQ.W   #4,A7                  ;restore stack
                   MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
                   RTS

63E8 DOTRAP3       TRAP     #4                     ;convert to absolute addresses
63EA DO_TRAP3      MOVEQ    #-1,D3                 ;use an infinite timeout
                   TRAP     #3                     ;do the TRAP
                   TST.L    D0                     ;set flags for interpreter
                   RTS

63F2 L063F2        CMPA.L   A5,A3                  ;end of name table ?
                   BGE.S    L063E2
                   MOVE.L   A5,-(A7)
                   ADDQ.W   #8,A3                  ;next entry in name table
                   MOVEA.L  A3,A5
                   JSR      L05EFC(PC)             ;evaluate entry
                   MOVEA.L  (A7)+,A5
                   BEQ.S    BP_EXIT
                   ADDQ.W   #4,A7
                   RTS

6408 DOIOOPEN      BSR.S    L063F2
                   MOVEQ    #IO.OPEN,D0            ;TRAP to open a channel
                   MOVEQ    #-1,D1                 ;use an infinite timeout
                   MOVE.L   D4,D3
6410 DOTRAP2       MOVEA.L  A1,A0
                   MOVE.W   TOS(A6,A1.L),-(A7)
                   TRAP     #4                     ;convert to absolute addresses
                   TRAP     #2                     ;do the TRAP
                   MOVEQ    #3,D3
                   ADD.W    (A7)+,D3
                   BCLR     #0,D3
                   ADD.L    D3,BV.RIP(A6)          ;restore maths stack pointer
                   TST.L    D0                     ;set flags for interpreter
                   RTS

Ú------------------------------------------------------------------------------¿
³=BP_DLETE        REMOVE A FILE FROM DEVICE DIRECTORY                          ³
------------------------------------------------------------------------------
³SYNTAX:          DELETE device                                                ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

642A BP_DLETE      BSR.S    L063F2
                   MOVEQ    #IO.DELET,D0           ;TRAP to delete a file
                   BRA.S    DOTRAP2                ;delete it

Ú------------------------------------------------------------------------------¿
³=BP_DIR          DISPLAY DEVICE DIRECTORY                                     ³
------------------------------------------------------------------------------
³SYNTAX:          DIR device                                                   ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

6430 BP_DIR        JSR      L06040(PC)
                   BNE.S    BP_EXIT
                   MOVEA.L  A0,A4
                   MOVEQ    #4,D4                  ;signal "get directory"
                   BSR.S    DOIOOPEN               ;open the channel
                   BNE.S    BP_EXIT                ;exit if any errors
                   MOVEA.L  A0,A5
                   MOVEQ    #FS.MDINF,D0           ;TRAP to get information about medium
                   MOVEA.L  (A6),A1
                   MOVEA.L  A5,A0
                   BSR.S    DOTRAP3                ;get the information
                   BNE.S    DO_CLOSE               ;and close the channel if any errors
                   MOVE.L   D1,-(A7)
                   MOVEA.L  (A6),A1
                   MOVEQ    #10,D2
                   BSR.S    L064B0

                   MOVEQ    #IO.SBYTE,D0           ;TRAP to send a byte
                   MOVEQ    #10,D1
                   TRAP     #3                     ;send it
                   MOVEM.W  (A7)+,D1-2
                   BSR.S    L06484

645E L0645E        MOVEQ    #IO.FSTRG,D0           ;TRAP to fetch a string of bytes
                   MOVEQ    #64,D2                 ;length of file header
                   MOVEA.L  (A6),A1
                   MOVEA.L  A5,A0
                   MOVEQ    #0,D4
                   BSR      DOTRAP3                ;get the header
                   BNE      L063D6
                   SUBA.W   #$30,A1
                   MOVE.W   -2(A6,A1.L),D2
                   BEQ.S    L0645E
                   BSR.S    L064B0
                   MOVEQ    #IO.SBYTE,D0           ;TRAP to send a byte
                   MOVEQ    #10,D1                 ;length of medium name
                   TRAP     #3                     ;print it
                   BRA.S    L0645E

6484 L06484        MOVE.W   D2,D4
                   BSR.S    L064A0
                   MOVEQ    #IO.SBYTE,D0           ;TRAP to send a byte
                   MOVE.B   #$2F,D1
                   TRAP     #3                     ;send it

                   MOVE.W   D4,D1
                   BSR.S    L064A0
                   MOVEQ    #IO.SSTRG,D0           ;TRAP to send a string of bytes
                   LEA      L065C4(PC),A1          ;A1 points at "sectors" message
                   MOVEQ    #9,D2                  ;length of message
                   TRAP     #3                     ;print it
                   RTS

64A0 L064A0        MOVEA.L  (A6),A1
                   LEA      2(A1),A0
                   MOVE.W   D1,TOS(A6,A1.L)
                   JSR      L03EC4(PC)
                   MOVE.W   D1,D2                  ;save number of bytes to send
64B0 L064B0        MOVEQ    #IO.SSTRG,D0           ;TRAP to send a string of bytes
                   MOVEA.L  A4,A0                  ;get channel ID
                   MOVEQ    #-1,D3                 ;use an infinite timeout
                   BRA      DOTRAP3                ;send them

Ú------------------------------------------------------------------------------¿
³=BP_FORMT        FORMAT DEVICE MEDIUM                                         ³
------------------------------------------------------------------------------
³SYNTAX:          FORMAT [channel,] device                                     ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

64BA BP_FORMT      JSR      L06040(PC)
                   BNE      BP_EXIT
                   MOVEA.L  A0,A4
                   BSR      L063F2
                   MOVEQ    #IO.FORMT,D0           ;TRAP to format a medium
                   BSR      DOTRAP2                ;format it
                   BNE      BP_EXIT                ;and exit if any errors
                   BRA.S    L06484

Ú------------------------------------------------------------------------------¿
³=BP_COPY         COPY FILE                                                    ³
³=BP_COPYN        COPY FILE MINUS HEADER                                       ³
------------------------------------------------------------------------------
³SYNTAX:          COPY   device TO device                                      ³
³                 COPY_N device TO device                                      ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

64D4 BP_COPY       MOVEQ    #0,D5
                   BRA.S    L064DA

64D8 BP_COPYN      MOVEQ    #-1,D5
64DA L064DA        MOVEQ    #IO.OPEN,D4            ;TRAP to open a channel
                   BSR      DOIOOPEN               ;open it
                   BNE      BP_EXIT                ;and exit if any errors
                   MOVEA.L  A0,A4                  ;A4 points at channel definition block
                   MOVEQ    #2,D4                  ;signal "new file"
                   BSR      DOIOOPEN               ;open it
                   BNE.S    L06566
                   TST.B    D5
                   BNE.S    L06510
                   MOVEQ    #-1,D5
                   MOVEA.L  (A6),A1

                   MOVEQ    #FS.HEADR,D0           ;TRAP to read file header
                   MOVEQ    #14,D2                 ;length of header
                   EXG      A4,A0
                   BSR      DOTRAP3                ;read it
                   EXG      A4,A0
                   BNE.S    L06510
                   MOVEA.L  (A6),A1
                   MOVE.L   TOS(A6,A1.L),D5
                   MOVEQ    #FS.HEADS,D0           ;TRAP to set file header
                   BSR      DOTRAP3                ;set it

6510 L06510        MOVEA.L  (A6),A1
                   MOVE.L   8(A6),D2
                   SUB.L    A1,D2
                   MOVEQ    #0,D3
                   EXG      A4,A0
                   TST.L    D5
                   BLE.S    L06526
                   CMP.L    D5,D2
                   BLE.S    L06526
                   MOVE.L   D5,D2
6526 L06526        TAS      $8F(A6)
                   BEQ.S    L06564
                   MOVEQ    #IO.FSTRG,D0           ;TRAP to fetch a string of bytes
                   TRAP     #4                     ;use absolute values
                   TRAP     #3                     ;fetch them

                   CMPI.L   #ERR.NC,D0             ;not complete ?
                   BNE.S    L06540                 ;jump forward if not
                   TST.W    D1
                   BEQ.S    L06526                 ;keep trying if so
                   BRA.S    L06552

6540 L06540        CMPI.L   #ERR.EF,D0             ;end of file ?
                   BNE.S    L0654E                 ;jump forward if not
                   MOVEQ    #0,D0                  ;signal "no errors"
                   TST.W    D1
                   BEQ.S    L06564
654E L0654E        TST.L    D0                     ;set flags for interpreter
                   BNE.S    L06564

6552 L06552        MOVEQ    #IO.SSTRG,D0           ;TRAP to send a string of bytes
                   MOVE.W   D1,D2
                   EXG      A4,A0
                   SUBA.W   D1,A1
                   BSR      DOTRAP3                ;send them

                   BNE.S    L06564
                   SUB.L    D2,D5
                   BNE.S    L06510
6564 L06564        BSR.S    L06568
6566 L06566        EXG      A4,A0
6568 L06568        BRA      DO_CLOSE               ;close it

Ú------------------------------------------------------------------------------¿
³=BP_CLOSE        CLOSE A CHANNEL                                              ³
------------------------------------------------------------------------------
³SYNTAX:          CLOSE channel                                                ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:          ERR.BP   bad paraameter                                      ³
À------------------------------------------------------------------------------Ù

656C BP_CLOSE      CMPA.L   A3,A5                  ;any parameters ?
                   BLE.S    L0658A                 ;exit if not
                   TST.B    1(A6,A3.L)             ;preceded by a hash ?
                   BPL.S    L0658A                 ;exit if not
                   JSR      L06040(PC)
                   BNE.S    L06588
                   MOVE.L   #-1,0(A6,A2.L)
                   MOVEQ    #IO.CLOSE,D0           ;TRAP to close a channel
                   TRAP     #2                     ;close it
6588 L06588        RTS

658A L0658A        MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
                   BRA.S    L06588

Ú------------------------------------------------------------------------------¿
³=BP_OPEN         LINK CHANNEL WITH PHYSICAL DEVICE                            ³
³=BP_OPENI        OPEN EXISTING MICRODRIVE FILE FOR I/P                        ³
³=BP_OPENN        OPEN NEW MICRODRIVE FILE FOR O/P                             ³
------------------------------------------------------------------------------
³SYNTAX:          OPEN     channel, device                                     ³
³                 OPEN_IN  channel, device                                     ³
³                 OPEN_NEW channel, device                                     ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

658E BP_OPEN       MOVEQ    #0,D4
                   BRA.S    L06598

6592 BP_OPENI      MOVEQ    #1,D4
                   BRA.S    L06598

6596 BP_OPENN      MOVEQ    #IO.CLOSE,D4           ;TRAP to close a channel
6598 L06598        BSR.S    BP_CLOSE
                   TST.L    D0
                   BEQ.S    L065A4
                   MOVEQ    #-6,D2
                   CMP.L    D0,D2
                   BNE.S    L06588
65A4 L065A4        EXG      D1,D6
                   BSR      DOIOOPEN
                   EXG      D6,D1
                   BNE.S    L06588
                   JSR      L060A0(PC)
                   RTS

Ú------------------------------------------------------------------------------¿
³=BP_SAVE         SAVE SUPERBASIC PROGRAM ON DEVICE                            ³
------------------------------------------------------------------------------
³SYNTAX:          line :=  | numeric_expression TO numeric_exression           ³
³                          | numeric_expression TO                             ³
³                          | TO numeric_expression                             ³
³                          | numeric_expression                                ³
³                          |                                                   ³
³                                                                              ³
³                 SAVE device *[, line]*                                       ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

65B4 BP_SAVE       MOVEQ    #IO.CLOSE,D4           ;TRAP to close channel
                   BSR      L00408                 ;!!!!!!!!!!!!!!!!
                   BNE.S    L06588
                   JSR      L06DD4(PC)
                   BRA      DO_CLOSE               ;close it

65C4 L065C4        DC.B     " sectors",10,0

Ú------------------------------------------------------------------------------¿
³=BP_FILL         TURN GRAPHICS FILL ON OR OFF                                 ³
------------------------------------------------------------------------------
³SYNTAX:          switch := numeric_expression {0 .. 1}                        ³
³                                                                              ³
³                 FILL [channel,] switch                                       ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

65CE BP_FILL       JSR      L06040(PC)
                   BNE.S    L065EA
                   JSR      L05C2C(PC)
                   BNE.S    L065EA
                   MOVE.L   TOS(A6,A1.L),D1        ;get required fill mode
                   ADDQ.L   #4,A1                  ;restore maths stack
                   MOVE.L   A1,BV.RIP(A6)          ;update top of maths stack pointer
                   MOVEQ    #SD.FLOOD,D0           ;TRAP to set fill mode
                   MOVEQ    #-1,D3                 ;use an infinite timeout
                   TRAP     #3                     ;set it
65EA L065EA        RTS

Ú------------------------------------------------------------------------------¿
³=BP_UNDER        TURN UNDERLINE STATE ON OR OFF                               ³
³=BP_FLASH        TURN FLASH STATE ON OR OFF                                   ³
------------------------------------------------------------------------------
³SYNTAX:          switch := numeric_expression {0 .. 1}                        ³
³                                                                              ³
³                 UNDER [channel,] switch                                      ³
³                 FLASH [channel,] switch                                      ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

65EC BP_UNDER      MOVE.B   #SD.SETUL,D4           ;TRAP to set underline mode
                   BRA.S    L065F6

65F2 BP_FLASH      MOVE.B   #SD.SETFL,D4           ;TRAP to set flash mode
65F6 L065F6        JSR      L078CA(PC)
                   BNE.S    L06606
                   JSR      L078BA(PC)
                   BNE.S    L06606
6602 L06602        JMP      L07856(PC)
6606 L06606        RTS

Ú------------------------------------------------------------------------------¿
³=BP_OVER         SELECT OVER PRINTING TYPE                                    ³
------------------------------------------------------------------------------
³SYNTAX:          switch := numeric_expression {-1 .. 1}                       ³
³                                                                              ³
³                 OVER [channel,] switch                                       ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:          ERR.BP   invalid "over" value                                ³
À------------------------------------------------------------------------------Ù

6608 BP_OVER       JSR      L078CA(PC)
                   BNE.S    L06606
                   MOVE.B   #SD.SETMD,D4           ;TRAP to set write mode
                   MOVE.W   TOS(A6,A1.L),D1        ;get required mode
                   CMPI.W   #1,D1                  ;valid value ?
                   BGT.S    L06622                 ;exit if not
                   CMPI.W   #-1,D1                 ;valid value ?
                   BGE.S    L06602                 ;do TRAP if so otherwise
6622 L06622        MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
                   RTS

Ú------------------------------------------------------------------------------¿
³=                                                                             ³
------------------------------------------------------------------------------
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

6626 L06626        BSR      L066FC
                   JSR      L05C48(PC)
                   BNE.S    L06638
                   MOVEQ    #SD.GCUR,D0            ;TRAP to set text cursor
                   MOVEQ    #-1,D3                 ;use an infinite timeout
                   TRAP     #4                     ;and absolute values
                   TRAP     #3                     ;set cursor
6638 L06638        BRA      L066F4

Ú------------------------------------------------------------------------------¿
³=BP_SCALE        ALTER GRAPHICS SCALE FACTOR and ORIGIN                       ³
------------------------------------------------------------------------------
³SYNTAX:          scale := numeric_expression                                  ³
³                 origin_x := numeric_expression                               ³
³                 origin_y := numeric_expression                               ³
³                                                                              ³
³                 SCALE [channel,] scale, origin_x, origin_y                   ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

663C BP_SCALE      MOVEQ    #SD.SCALE,D4           ;TRAP to set graphic scale and origin
                   BSR      L066FC
                   BSR      L06788
                   BSR      L0678C
                   BRA      L066DC

Ú------------------------------------------------------------------------------¿
³=BP_POINT        DRAW POINT RELATIVE TO GRAPHICS ORIGIN                       ³
³=BP_RPOIN        DRAW POINT RELATIVE TO GRAPHICS CURSOR                       ³
------------------------------------------------------------------------------
³SYNTAX:          x := numeric_expression                                      ³
³                 y := numeric_expression                                      ³
³                                                                              ³
³                 POINT    [channel,] x, y *[, x, y]*                          ³
³                 POINT_R  [channel,] x, y *[, x, y]*                          ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

664E BP_POINT      MOVEQ    #SD.POINT,D4           ;TRAP to plot point
                   BRA.S    L06656

6652 BP_RPOIN      MOVE.W   #SD.POINT + 128,D4     ;         " "
6656 L06656        BSR      L066FC
                   BSR      L06762
                   BRA.S    L066DC

Ú------------------------------------------------------------------------------¿
³=BP_LINE         DRAW LINE RELATIVE TO GRAPHICS ORIGIN                        ³
³=BP_LINER        DRAW LINE RELATIVE TO GRAPHICS CURSOR                        ³
------------------------------------------------------------------------------
³SYNTAX:          x := numeric_expression                                      ³
³                 y := numeric_expression                                      ³
³                 point := x,y                                                 ³
³                 angle := numeric_expression {in radians}                     ³
³                 parameter_1 :=    | TO point, angle                          ³
³                                   | TO point                                 ³
³                                   | point                                    ³
³                 parameter_2 :=    | TO point                                 ³
³                                   | , point TO point                         ³
³                                                                              ³
³                 LINE   [channel,] parameter_1 *[, parameter_2]*              ³
³                 LINE_R [channel,] parameter_1 *[, parameter_2]*              ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

6660 BP_LINE       MOVEQ    #SD.LINE,D4            ;TRAP to draw line
                   BRA.S    L06668

6664 BP_LINER      MOVE.W   #SD.LINE + 128,D4      ;TRAP to draw line
6668 L06668        BSR      L066FC
                   BSR      L06750
                   BNE.S    L066EA
                   BSR      L06762
                   BRA.S    L066DC

Ú------------------------------------------------------------------------------¿
³=BP_ELLIP        DRAW ELLIPSE RELATIVE TO GRAPHICS ORIGIN                     ³
³=BP_ELPSR        DRAW ELLIPSE RELATIVE TO GRAPHICS CURSOR                     ³
------------------------------------------------------------------------------
³SYNTAX:          x := numeric_expression                                      ³
³                 y := numeric_expression                                      ³
³                 radius := numeric_expression                                 ³
³                 eccentricity := numeric_expression                           ³
³                 angle := numeric_expression {in radians}                     ³
³                 parameters :=     | x, y,                                    ³
³                                   | radius, eccentricity, angle              ³
³                                                                              ³
³                 CIRCLE   [channel,] parameters *[; parameters]*              ³
³                 CIRCLE_R [channel,] parameters *[; parameters]*              ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

6678 BP_ELLIP      MOVEQ    #SD.ELIPS,D4           ;TRAP to draw circle/ellipse
                   BRA.S    L06680

667C BP_ELPSR      MOVE.W   #SD.ELIPS + 128,D4     ;         "        "
6680 L06680        BSR.S    L066FC
                   BSR      L06762
                   BSR      L0678C
                   CMPI.B   #1,D5
                   BNE.S    L06696
                   BSR      L06788
                   BRA.S    L066AE

6696 L06696        SUBQ.L   #8,A1
                   SUBQ.L   #4,A1
                   CLR.L    TOS(A6,A1.L)
                   MOVE.L   #$801,4(A6,A1.L)
                   MOVE.L   #$40000000,8(A6,A1.L)
66AE L066AE        MOVEM.W  6(A6,A1.L),D0-2
                   MOVE.W   12(A6,A1.L),6(A6,A1.L)
                   MOVE.L   14(A6,A1.L),8(A6,A1.L)
                   MOVEM.W  D0-2,12(A6,A1.L)
                   BRA.S    L066DC

Ú------------------------------------------------------------------------------¿
³=BP_ARC          DRAW ARC RELATIVE TO GRAPHICS ORIGIN                         ³
³=BP_ARC_R        DRAW ARC RELATIVE TO GRAPHICS CURSOR                         ³
------------------------------------------------------------------------------
³SYNTAX:          x := numeric_expression                                      ³
³                 y := numeric_expression                                      ³
³                 angle := numeric_expression {in radians}                     ³
³                 point := x, y                                                ³
³                 parameter_1 :=    | , point TO point, angle                  ³
³                                   | TO point, angle                          ³
³                 parameter_2 :=    | TO point, angle                          ³
³                                   | , point TO point, angle                  ³
³                                                                              ³
³                 ARC   [channel,] parameter_1 *[, parameter_2]*               ³
³                 ARC_R [channel,] parameter_1 *[, parameter_2]*               ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

66C8 BP_ARC        MOVEQ    #SD.ARC,D4             ;TRAP to plot arc
                   BRA.S    L066D0

66CC BP_ARC_R      MOVE.W   #SD.ARC + 128,D4       ;TRAP to plot arc
66D0 L066D0        BSR.S    L066FC
                   BSR.S    L06750
                   BSR      L06762
                   BSR      L0678C
66DC L066DC        MOVE.L   D4,D0                  ;copy command
                   SWAP     D0
                   BCLR     #7,D0                  ;reset to SD.ARC if ARC_R required
                   MOVEQ    #-1,D3                 ;use an infinite timeout
                   TRAP     #4                     ;and absolute values
                   TRAP     #3                     ;plot the arc

66EA L066EA        CMPA.L   D6,A3
                   BGE.S    L066F2
                   MOVE.L   A4,-(A7)
                   MOVE.W   D5,D4
66F2 L066F2        MOVEQ    #0,D0                  ;signal "no errors"
66F4 L066F4        MOVE.L   D7,BV.RIP(A6)          ;restore maths stack pointer
                   MOVEA.L  D7,A1
                   RTS

66FC L066FC        SWAP     D4
                   CLR.W    D4
                   CLR.W    D5
                   MOVE.L   BV.RIP(A6),D7          ;get top of maths stack
                   MOVE.L   A5,D6                  ;D6 points at last entry in name table
                   CMPA.L   D6,A3                  ;any parameters ?
                   BLT.S    L06710                 ;jump forward if so otherwise
                   MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
                   BRA.S    L0674C

6710 L06710        MOVE.B   1(A6,A3.L),D0
                   ANDI.B   #%00001111,D0
                   BNE.S    L06722
                   JSR      L06DA2(PC)
                   MOVE.W   D5,D4
                   BRA.S    L06734
6722 L06722        BTST     #7,1(A6,A3.L)
                   BEQ.S    L06734
                   MOVE.B   1(A6,A3.L),D4
                   BCLR     #7,D4
                   LSR.B    #4,D4
6734 L06734        JSR      L06040(PC)
                   BNE.S    L0674C
                   MOVE.W   #256,D1
                   JSR      BV_CHRIX(PC)           ;reserve space on maths sack
                   MOVE.L   BV.RIP(A6),D7
                   MOVEA.L  D7,A1
                   MOVEA.L  (A7),A4
                   RTS

674C L0674C        ADDQ.L   #4,A7
                   BRA.S    L066F4

6750 L06750        CMPI.B   #5,D4
                   BNE.S    L06762
                   BSR.S    L067B4
                   BSR.S    L067C4
                   MOVE.L   A1,BV.RIP(A6)
                   MOVEQ    #0,D0
                   RTS

6762 L06762        BSR.S    L06792
                   BNE.S    L0674C
                   BTST     #$17,D4
                   BEQ.S    L06772
                   BSR.S    L067B4
                   JSR      L048D2(PC)
6772 L06772        BSR.S    L06792
                   BNE.S    L0674C
                   BTST     #$17,D4
                   BEQ.S    L06782
                   BSR.S    L067C4
                   JSR      L048D2(PC)
6782 L06782        BSR.S    L067D4
                   MOVEQ    #1,D0
                   RTS

6788 L06788        BSR.S    L06792
                   BNE.S    L0674C
678C L0678C        BSR.S    L06792
                   BNE.S    L0674C
                   RTS

6792 L06792        MOVE.L   A4,-(A7)
                   CMPA.L   D6,A3
                   BLT.S    L0679C
                   MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
                   BRA.S    L067B0

679C L0679C        MOVE.W   D5,D4
                   JSR      L06DA2(PC)
                   MOVEA.L  A3,A5
                   JSR      L0593E(PC)
                   BNE.S    L067B0
                   MOVEQ    #2,D0
                   JSR      L0540C(PC)
67B0 L067B0        MOVEA.L  (A7)+,A4
                   RTS

67B4 L067B4        SUBQ.W   #6,A1
                   MOVE.L   10(A6,A2.L),TOS(A6,A1.L)
                   MOVE.W   14(A6,A2.L),4(A6,A1.L)
                   RTS

67C4 L067C4        SUBQ.W   #6,A1
                   MOVE.L   4(A6,A2.L),TOS(A6,A1.L)
                   MOVE.W   8(A6,A2.L),4(A6,A1.L)
                   RTS

67D4 L067D4        MOVE.L   TOS(A6,A1.L),4(A6,A2.L)
                   MOVE.L   4(A6,A1.L),8(A6,A2.L)
                   MOVE.L   8(A6,A1.L),12(A6,A2.L)
                   RTS

67E8 SB_INIT       LEA      PROCLIST(PC),A1        ;A1 points at procedure/function list

Ú------------------------------------------------------------------------------¿
³=BP_INIT         ADD SUPER BASIC PROCEDURES          (VECTOR $110)            ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     start of procedure/function list                    ³
³                 A6.L     SUPERBASIC system variables                         ³
³                                                                              ³
³EXIT:            D3 and A1  corrupted                                         ³
³                 D1,D2,A0,A2 and A3 preserved                                 ³
³                 A6.L     updated pointer if memory expanded                  ³
³                                                                              ³
³ERRORS:          none                                                         ³
À------------------------------------------------------------------------------Ù

67EC BP_INIT       MOVEM.L  D1-2/D5-7/A0/A2-3,-(A7)
                   MOVEQ    #8,D5
67F2 L067F2        MOVEQ    #0,D7
                   MOVEQ    #0,D6
                   MOVE.W   (A1)+,D6
   67f8                LSL.L    #3,D6
                   MOVE.L   D6,D1
                   MOVE.L   A1,-(A7)
   67fe                JSR      L04F5A(PC)
                   MOVE.L   D6,D1
   6804                JSR      L04F6C(PC)
                   MOVEA.L  BV.NTP(A6),A0
                   MOVEA.L  BV.NLP(A6),A2
                   MOVEA.L  (A7)+,A1
6812 L06812        MOVEA.L  A1,A3
                   MOVE.W   (A1)+,D0
                   BEQ.S    L0684E
                   ADDA.W   D0,A3
                   MOVE.B   (A1)+,D1
                   MOVE.B   D5,0(A6,A0.L)
                   MOVE.B   D7,1(A6,A0.L)
                   MOVE.L   A2,D2
                   SUB.L    BV.NLBAS(A6),D2
                   MOVE.W   D2,2(A6,A0.L)
                   MOVE.B   D1,0(A6,A2.L)
                   ADDQ.W   #1,A2
                   MOVE.B   D1,D2
6836 L06836        MOVE.B   (A1)+,0(A6,A2.L)
                   ADDQ.W   #1,A2
                   SUBQ.B   #1,D1
                   BGT.S    L06836
                   BTST     D7,D2
                   BNE.S    L06846
                   ADDQ.W   #1,A1
6846 L06846        MOVE.L   A3,4(A6,A0.L)
                   ADDQ.W   #8,A0
                   BRA.S    L06812

684E L0684E        MOVE.L   A0,BV.NTP(A6)
                   MOVE.L   A2,BV.NLP(A6)
                   SUBQ.W   #8,D5
                   BNE.S    L0685E
                   MOVEQ    #9,D5
                   BRA.S    L067F2
685E L0685E        MOVEM.L  (A7)+,D1-2/D5-7/A0/A2-3
                   RTS

2.21 Procedures and functions list.

6864 PROCLIST      DC.W     79                     ;number of procedures to follow
                   DC.W     BP_PRINT - *           ;print character(s) to a channel
                   DC.B     5,"PRINT"
                   DC.W     BP_RUN - *             ;start program execution
                   DC.B     3,"RUN"
                   DC.W     BP_STOP - *            ;terminate program execution
                   DC.B     4,"STOP",0
                   DC.W     BP_INPUT - *           ;read character(s) from a channel
                   DC.B     5,"INPUT"
                   DC.W     BP_WINDO - *           ;redefine channel's window
                   DC.B     6,"WINDOW",0
                   DC.W     BP_BORDE - *           ;add a border to a window
                   DC.B     6,"BORDER",0
                   DC.W     BP_INK - *             ;set current ink colour
                   DC.B     3,"INK"
                   DC.W     BP_STRIP - *           ;set current strip colour
                   DC.B     5,"STRIP"
                   DC.W     BP_PAPER - *           ;set current paper colour
                   DC.B     5,"PAPER"
                   DC.W     BP_BLOCK - *           ;fill a block with colour
                   DC.B     5,"BLOCK"
                   DC.W     BP_PAN - *             ;pan part or all of screen
                   DC.B     3,"PAN"
                   DC.W     BP_SCROL - *           ;scroll part or all of screen
                   DC.B     6,"SCROLL",0
                   DC.W     BP_CSIZE - *           ;set a new character size
                   DC.B     5,"CSIZE"
                   DC.W     BP_FLASH - *           ;turn flash state on or off
                   DC.B     5,"FLASH"
                   DC.W     BP_UNDER - *           ;turn underline state on or off
                   DC.B     5,"UNDER"
                   DC.W     BP_OVER - *            ;select over printing type
                   DC.B     4,"OVER",0
                   DC.W     BP_CURSO - *           ;position cursor with graphic co-ords
                   DC.B     6,"CURSOR",0
                   DC.W     BP_AT - *              ;position cursor at character co-ords
                   DC.B     2,"AT",0
                   DC.W     BP_SCALE - *           ;alter graphics scale factor and origin
                   DC.B     5,"SCALE"
                   DC.W     BP_POINT - *           ;plot point relative to graph origin
                   DC.B     5,"POINT"
                   DC.W     BP_LINE - *            ;draw line relative to graph origin
                   DC.B     4,"LINE",0
                   DC.W     BP_ELLIP - *           ;draw ellipse relative to graph origin
                   DC.B     7,"ELLIPSE"
                   DC.W     BP_ELLIP - *           ;draw ellipse relative to graph origin
                   DC.B     6,"CIRCLE",0
                   DC.W     BP_ARC - *             ;draw arc relative to graph origin
                   DC.B     3,"ARC"
                   DC.W     BP_RPOIN - *           ;plot a point relative to graph cursor
                   DC.B     7,"POINT_R"
                   DC.W     BP_TURN - *            ;turn turtle by specified angle
                   DC.B     4,"TURN",0
                   DC.W     BP_TURNT - *           ;turn turtle to specified angle
                   DC.B     6,"TURNTO",0
                   DC.W     BP_PENUP - *           ;switch turtle graphics pen off
                   DC.B     5,"PENUP"
                   DC.W     BP_PENDO - *           ;switch turtle graphics pen on
                   DC.B     7,"PENDOWN"
                   DC.W     BP_MOVE - *            ;move turtle in current direction
                   DC.B     4,"MOVE",0
                   DC.W     BP_LIST - *            ;list part of program on channel
                   DC.B     4,"LIST",0
                   DC.W     BP_OPEN - *            ;link channel with physical device
                   DC.B     4,"OPEN",0
                   DC.W     BP_CLOSE - *           ;close a channel
                   DC.B     5,"CLOSE"
                   DC.W     BP_FORMT - *           ;format device medium
                   DC.B     6,"FORMAT",0
                   DC.W     BP_COPY - *            ;copy file
                   DC.B     4,"COPY",0
                   DC.W     BP_NCOPY - *           ;copy file minus header
                   DC.B     6,"COPY_N",0
                   DC.W     BP_DLETE - *           ;remove a file from device directory
                   DC.B     6,"DELETE",0
                   DC.W     BP_DIR - *             ;display device directory
                   DC.B     3,"DIR"
                   DC.W     BP_EXEC - *            ;execute a program and return to basic
                   DC.B     4,"EXEC",0
                   DC.W     BP_EXECW - *           ;execute a program and wait
                   DC.B     6,"EXEC_W",0
                   DC.W     BP_LBYTE - *           ;load data file into memory
                   DC.B     6,"LBYTES",0
                   DC.W     BP_SEXEC - *           ;save executable program
                   DC.B     5,"SEXEC"
                   DC.W     BP_SBYTE - *           ;save area of memory to device
                   DC.B     6,"SBYTES",0
                   DC.W     BP_SAVE - *            ;save a SUPERBASIC program on device
                   DC.B     4,"SAVE",0
                   DC.W     BP_MERGE - *           ;load and merge a SUPERBASIC program
                   DC.B     5,"MERGE"
                   DC.W     BP_MRUN - *            ;load,merge and run SUPERBASIC program
                   DC.B     4,"MRUN",0
                   DC.W     BP_LOAD - *            ;load a SUPERBASIC program
                   DC.B     4,"LOAD",0
                   DC.W     BP_LRUN - *            ;load and run a SUPERBASIC program
                   DC.B     4,"LRUN",0
                   DC.W     BP_NEW - *             ;clear SUPERBASIC program and variables
                   DC.B     3,"NEW"
                   DC.W     BP_CLEAR - *           ;clear SUPERBASIC variables
                   DC.B     5,"CLEAR"
                   DC.W     BP_OPENI - *           ;open existing microdrive file for I/P
                   DC.B     7,"OPEN_IN"
                   DC.W     BP_OPENN - *           ;open new microdrive file for O/P
                   DC.B     8,"OPEN_NEW",0
                   DC.W     BP_CLS - *             ;clear part or all of window
                   DC.B     3,"CLS"
                   DC.W     BP_CALL - *            ;call machine code routine
                   DC.B     4,"CALL",0
                   DC.W     BP_RECOL - *           ;recolour individul pixels in window
                   DC.B     5,"RECOL"
                   DC.W     BP_RNDMZ - *           ;reseed random number generator
                   DC.B     9,"RANDOMISE"
                   DC.W     BP_PAUSE - *           ;delay executing a superbasic program
                   DC.B     5,"PAUSE"
                   DC.W     BP_POKE - *            ;place byte in memory
                   DC.B     4,"POKE",0
                   DC.W     BP_POKEW - *           ;place word in memory
                   DC.B     6,"POKE_W",0
                   DC.W     BP_POKEL - *           ;place long word in memory
                   DC.B     6,"POKE_L",0
                   DC.W     BP_BAUD - *            ;set baud rate for serial channels
                   DC.B     4,"BAUD",0
                   DC.W     BP_BEEP - *            ;switch sound on or off
                   DC.B     4,"BEEP",0
                   DC.W     BP_CONTI - *           ;continue halted SUPERBASIC program
                   DC.B     8,"CONTINUE",0
                   DC.W     BP_RETRY - *           ;re-execute SUPERBASIC statement
                   DC.B     5,"RETRY"
                   DC.W     BP_READ - *            ;assign data to list of variables
                   DC.B     4,"READ",0
                   DC.W     BP_NET - *             ;set network station numer
                   DC.B     3,"NET"
                   DC.W     BP_MODE - *            ;set resolution of screen
                   DC.B     4,"MODE",0
                   DC.W     BP_RENUM - *           ;renumber SUPERBASIC program lines
                   DC.B     5,"RENUM"
                   DC.W     BP_DLINE - *           ;remove SUPERBASIC program lines
                   DC.B     5,"DLINE"
                   DC.W     BP_SDATE - *           ;reset system clock
                   DC.B     5,"SDATE"
                   DC.W     BP_ADATE - *           ;adjust system clock
                   DC.B     5,"ADATE"
                   DC.W     BP_LINER - *           ;draw line relative to graph cursor
                   DC.B     6,"LINE_R",0
                   DC.W     BP_ELPSR - *           ;draw ellipse relative to graph cursor
                   DC.B     9,"ELLIPSE_R"
                   DC.W     BP_ELPSR - *           ;draw ellipse relative to graph cursor
                   DC.B     8,"CIRCLE_R",0
                   DC.W     BP_ARC_R - *           ;draw arc relative to graph cursor
                   DC.B     5,"ARC_R"
                   DC.W     BP_AUTO - *            ;generate line numbers automatically
                   DC.B     4,"AUTO",0
                   DC.W     BP_EDIT - *            ;edit list of SUPERBASIC lines
                   DC.B     4,"EDIT",0
                   DC.W     BP_FILL - *            ;turn graphics fill on or off
                   DC.B     4,"FILL" ,0
                   DC.W     BP_WIDTH - *           ;set default width on device
                   DC.B     5,"WIDTH"
                   DC.W     0                      ;end of procedures

   List of functions.

     FNCTLIST      DC.W     35                     ;number of functions to follow
                   DC.W     BF_ACOS - *            ;return arc cosine
                   DC.B     4,"ACOS",0
                   DC.W     BF_ACOT - *            ;return arc cotangent
                   DC.B     4,"ACOT",0
                   DC.W     BF_ASIN - *            ;return arc sine
                   DC.B     4,"ASIN",0
                   DC.W     BF_ATAN - *            ;return arc tangent
                   DC.B     4,"ATAN",0
                   DC.W     BF_COS - *             ;return cosine
                   DC.B     3,"COS"
                   DC.W     BF_COT - *             ;return cotangent
                   DC.B     3,"COT"
                   DC.W     BF_EXP - *             ;return e to power argument
                   DC.B     3,"EXP"
                   DC.W     BF_LN - *              ;return natural logarithm
                   DC.B     2,"LN",0
                   DC.W     BF_LOG10 - *           ;return logarithm to base 10
                   DC.B     5,"LOG10"
                   DC.W     BF_SIN - *             ;return sine
                   DC.B     3,"SIN"
                   DC.W     BF_SQRT - *            ;return square root
                   DC.B     4,"SQRT",0
                   DC.W     BF_TAN - *             ;return tangent
                   DC.B     3,"TAN"
                   DC.W     BF_DEG - *             ;return angle in degrees
                   DC.B     3,"DEG"
                   DC.W     BF_RAD - *             ;return angle in radians
                   DC.B     3,"RAD"
                   DC.W     BF_RND - *             ;return random number within limits
                   DC.B     3,"RND"
                   DC.W     BF_INT - *             ;return integer part of number
                   DC.B     3,"INT"
                   DC.W     BF_ABS - *             ;return absolute value of nuber
                   DC.B     3,"ABS"
                   DC.W     BF_PI - *              ;return the value 3.1415926
                   DC.B     2,"PI",0
                   DC.W     BF_PEEK - *            ;return value of byte in memory
                   DC.B     4,"PEEK",0
                   DC.W     BF_PEEKW - *           ;return signed value of word in memory
                   DC.B     6,"PEEK_W",0
                   DC.W     BF_PEEKL - *           ;return signed value of memory long
                   DC.B     6,"PEEK_L",0
                   DC.W     BF_RESPR - *           ;reserve resident procedure space
                   DC.B     5,"RESPR"
                   DC.W     BF_EOF - *             ;return file or data statement status
                   DC.B     3,"EOF"
                   DC.W     BF_INKEY - *           ;return character from channel
                   DC.B     6,"INKEY$",0
                   DC.W     BF_CHR$ - *            ;return ascii character
                   DC.B     4,"CHR$",0
                   DC.W     BF_CODE - *            ;return ascii value of character
                   DC.B     4,"CODE",0
                   DC.W     BF_KEYRW - *           ;return state of row of keyboard
                   DC.B     6,"KEYROW",0
                   DC.W     BF_BEEPI - *           ;return sound status
                   DC.B     7,"BEEPING"
                   DC.W     BF_LEN - *             ;return length of string
                   DC.B     3,"LEN"
                   DC.W     BF_DIMN - *            ;return maximum size of dimension
                   DC.B     4,"DIMN",0
                   DC.W     BF_DAY$ - *            ;return current day of the week
                   DC.B     4,"DAY$",0
                   DC.W     BF_DATE - *            ;return current date in seconds
                   DC.B     4,"DATE",0
                   DC.W     BF_DATE$ - *           ;return current date and time
                   DC.B     5,"DATE$"
                   DC.W     BF_FILL$ - *           ;return filled string
                   DC.B     5,"FILL$"
                   DC.W     BF_VER$ - *            ;return SUPERBASIC version number
                   DC.B     4,"VER$",0
                   DC.W     0                      ;end of functions

Ú------------------------------------------------------------------------------¿
³=BP_LET          RETURN PARAMETER VALUES             (VECTOR $120)            ³
------------------------------------------------------------------------------
³ENTRY:           A3.L     pointer to parameter (relative)                     ³
³                                                                              ³
³EXIT:            D1,D2,D3,A0,A1,A2 and A3 corrupted                           ³
³                                                                              ³
³ERRORS:          ERR.BP   bad parameter                                       ³
À------------------------------------------------------------------------------Ù

   BV_RIP should be set to point to the top of the arithmetic stack.

6C12 BP_LET        MOVEM.L  D4/A0/A3-5,-(A7)
                   MOVE.B   1(A6,A3.L),D0
                   ANDI.B   #%00001111,D0
                   SUBQ.B   #2,D0
                   BGT.S    L06C3E
                   BEQ.S    L06C48
                   CMPI.B   #3,0(A6,A3.L)
                   BEQ.S    L06C34
                   ADDQ.B   #2,D0
                   BGT.S    L06CA0
                   BRA      L06CE6

6C34 L06C34        ADDQ.B   #2,D0
                   BGT      L06D04
                   BRA      L06D0E

6C3E L06C3E        MOVEQ    #2,D1
                   BSR.S    L06C58
                   ADD.L    D1,BV.RIP(A6)
                   BRA.S    L06C80

6C48 L06C48        MOVEQ    #6,D1
                   BSR.S    L06C58
                   MOVE.L   2(A6,A1.L),2(A6,A0.L)
                   ADD.L    D1,BV.RIP(A6)
                   BRA.S    L06C80

6C58 L06C58        MOVE.L   4(A6,A3.L),D4
                   BGE.S    L06C60
                   BSR.S    L06C88
6C60 L06C60        MOVEA.L  BV.VVBAS(A6),A0
                   ADDA.L   D4,A0
                   MOVEA.L  BV.RIP(A6),A1
                   MOVE.W   TOS(A6,A1.L),0(A6,A0.L)
6C70 L06C70        MOVEQ    #1,D0
                   SUB.B    0(A6,A3.L),D0
                   BLT.S    L06C84
                   MOVE.B   #2,0(A6,A3.L)
                   BRA.S    L06C84

6C80 L06C80        MOVEM.L  (A7)+,D4/A0/A3-5
6C84 L06C84        MOVEQ    #0,D0                  ;signal "no errors"
                   RTS

6C88 L06C88        MOVEM.L  A2-3,-(A7)
                   JSR      L04EF0(PC)
                   MOVEM.L  (A7)+,A2-3
                   MOVE.L   A0,D4
                   SUB.L    BV.VVBAS(A6),D4
                   MOVE.L   D4,4(A6,A3.L)
                   RTS

6CA0 L06CA0        BSR.S    L06D16
                   ANDI.L   #$FFFF,D1
                   MOVE.L   4(A6,A3.L),D4
                   BLT.S    L06CD2
                   MOVEA.L  BV.VVBAS(A6),A0
                   ADDA.L   D4,A0
                   MOVEQ    #1,D2
                   ADD.W    0(A6,A0.L),D2
                   BCLR     #0,D2
                   CMP.W    D1,D2
                   BEQ.S    L06CD8
                   ADDQ.L   #2,D2
                   MOVEM.L  D1/A1/A3,-(A7)
                   MOVE.L   D2,D1
                   JSR      L050E2(PC)
                   MOVEM.L  (A7)+,D1/A1/A3
6CD2 L06CD2        ADDQ.L   #2,D1
                   BSR.S    L06C88
                   SUBQ.L   #2,D1
6CD8 L06CD8        BSR.S    L06D2E
                   BSR.S    L06D3C
                   MOVEQ    #0,D0
                   MOVEQ    #0,D2
                   BSR.S    L06D50
                   BSR.S    L06C70
6CE4 L06CE4        BRA.S    L06C80

6CE6 L06CE6        MOVE.B   #1,1(A6,A3.L)
                   BSR.S    L06D16
                   SUBQ.W   #1,D5
                   ADDQ.W   #2,A2
                   ADDA.W   D5,A2
                   MOVEA.L  A2,A0
                   SUB.W    D5,D6
                   MOVE.W   D6,D2
                   BSR      L06D8C
                   ADDQ.W   #2,A1
6D00 L06D00        BSR.S    L06D50
                   BRA.S    L06CE4

6D04 L06D04        BSR.S    L06D16
                   BSR.S    L06D7C
                   BSR.S    L06D2E
                   BSR.S    L06D3C
                   BRA.S    L06D00

6D0E L06D0E        BSR.S    L06D16
                   BSR.S    L06D7C
                   BSR.S    L06D2E
                   BRA.S    L06D00

6D16 L06D16        MOVEA.L  BV.RIP(A6),A1
                   MOVEQ    #0,D1
                   MOVE.W   TOS(A6,A1.L),D1
                   MOVE.W   D1,D0
                   SWAP     D1
                   MOVE.W   D0,D1
                   ADDQ.W   #1,D1
                   BCLR     #0,D1
                   RTS

6D2E L06D2E        MOVEA.L  BV.VVBAS(A6),A0
                   ADDA.L   D4,A0
                   MOVEA.L  BV.RIP(A6),A1
                   ADDQ.W   #2,A1
                   RTS

6D3C L06D3C        MOVE.W   -2(A6,A1.L),0(A6,A0.L)
                   CMP.W    0(A6,A0.L),D1
                   BCC.S    L06D4C
                   MOVE.W   D1,0(A6,A0.L)
6D4C L06D4C        ADDQ.W   #2,A0
                   RTS

6D50 L06D50        TST.W    D1
6D52 L06D52        BEQ.S    L06D62
                   MOVE.B   TOS(A6,A1.L),0(A6,A0.L)
                   ADDQ.W   #1,A0
                   ADDQ.W   #1,A1
                   SUBQ.W   #1,D1
                   BRA.S    L06D52

6D62 L06D62        TST.W    D2
6D64 L06D64        BEQ.S    L06D72
                   MOVE.B   #$20,0(A6,A0.L)
                   ADDQ.W   #1,A0
                   SUBQ.W   #1,D2
                   BRA.S    L06D64

6D72 L06D72        ADDA.W   D0,A1
                   MOVE.L   A1,BV.RIP(A6)
                   MOVEQ    #0,D0
                   RTS

6D7C L06D7C        MOVEA.L  4(A6,A3.L),A0
                   ADDA.L   BV.VVBAS(A6),A0
                   MOVE.W   6(A6,A0.L),D2
                   MOVE.L   0(A6,A0.L),D4
6D8C L06D8C        MOVE.W   D1,D0
                   SWAP     D1
                   CMP.W    D2,D1
                   BHI.S    L06D9A
                   SUB.W    D1,D2
                   SUB.W    D1,D0
                   RTS

6D9A L06D9A        MOVE.W   D2,D1
                   SUB.W    D2,D0
                   MOVEQ    #0,D2
                   RTS



part19

Ú------------------------------------------------------------------------------¿
³=                                                                             ³
------------------------------------------------------------------------------
³SYNTAX:                                                                       ³
------------------------------------------------------------------------------
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

6DA2 L06DA2        MOVE.B   1(A6,A3.L),D5
                   LSR.B    #4,D5
                   ANDI.B   #%00001111,1(A6,A3.L)
                   ADDQ.W   #8,A3
                   RTS

2.22 SuperBASIC procedures continued.

Ú------------------------------------------------------------------------------¿
³=BP_DLINE        REMOVE SUPERBASIC PROGRAM LINES                              ³
------------------------------------------------------------------------------
³SYNTAX:          line_number := numeric_expression {10 .. 32768}              ³
³                 range := | line_number TO line_number                        ³
³                          | line_number TO                                    ³
³                          | TO line_number                                    ³
³                          | line_number                                       ³
³                                                                              ³
³                 DLINE range *[, range]*                                      ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

6DB2 BP_DLINE      CMPA.L   A5,A3
                   BGE      L06E5E
                   ST       D7
                   JSR      L076FE(PC)
                   BEQ.S    L06DC6
                   ST       BV.UNDO(A6)
6DC4 L06DC4        RTS

6DC6 L06DC6        BSR.S    L06DCA
6DC8 L06DC8        BRA.S    L06DE2

6DCA L06DCA        MOVEQ    #2,D1
6DCC L06DCC        JMP      L06042(PC)

Ú------------------------------------------------------------------------------¿
³=BP_LIST         LIST PART OF PROGRAM ON CHANNEL                              ³
------------------------------------------------------------------------------
³SYNTAX:          line :=  | line_number TO line_number                        ³
³                          | line_number TO                                    ³
³                          | TO line_number                                    ³
³                          | line_number                                       ³
³                                                                              ³
³                 LIST [channel,] line *[, line]*                              ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

6DD0 BP_LIST       BSR.S    L06DCA
                   BLT.S    L06DC4
                   ST       BV.PRINT(A6)
                   CLR.W    BV.LSFIL(A6)
                   CMPA.L   A5,A3
                   BGE      L06E62
6DE2 L06DE2        MOVE.L   A5,-(A7)
6DE4 L06DE4        CMPA.L   (A7),A3
                   BGE.S    L06E2E
                   BSR.S    L06DA2
                   BNE.S    L06DF0
                   MOVEQ    #0,D4
                   BRA.S    L06DF6

6DF0 L06DF0        BSR.S    L06E40
6DF2 L06DF2        BNE.S    L06E2A
                   MOVE.W   D1,D4
6DF6 L06DF6        SUBQ.B   #5,D5
                   BEQ.S    L06E06
                   ADDQ.B   #5,D5
                   MOVE.W   D4,D6
                   BNE.S    L06E1E
                   TST.B    D7
                   BNE.S    L06DE4
                   BRA.S    L06E0E

6E06 L06E06        CMPA.L   (A7),A3
6E08 L06E08        BGE.S    L06E0E
                   BSR.S    L06DA2
                   BNE.S    L06E14
6E0E L06E0E        MOVE.W   #$7FFF,D6
                   BRA.S    L06E1E

6E14 L06E14        BSR.S    L06E40
6E16 L06E16        BNE.S    L06E2A
                   MOVE.W   D1,D6
                   CMP.W    D4,D6
                   BLT.S    L06E2A
6E1E L06E1E        BSR.S    SB_CCBTA               ;convert pre-compiled basic to ascii
                   CMPI.B   #1,D5
                   BEQ.S    L06DE4
                   TST.B    D5
                   BEQ.S    L06E2E
6E2A L06E2A        MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
                   BRA.S    L06E3C

6E2E L06E2E        TST.B    D7
6E30 L06E30        BEQ.S    L06E3A
                   MOVEQ    #0,D2
                   MOVEQ    #0,D5
                   JSR      L087D2(PC)
6E3A L06E3A        MOVEQ    #0,D0
6E3C L06E3C        MOVEA.L  (A7)+,A5
                   RTS

6E40 L06E40        MOVEA.L  A3,A5
6E42 L06E42        JSR      L0593E(PC)
                   BNE.S    L06E60
                   MOVEQ    #3,D0
                   JSR      L0540C(PC)
                   BNE.S    L06E60
                   ADDQ.L   #2,BV.RIP(A6)
                   MOVE.W   TOS(A6,A1.L),D1
                   BGT.S    L06E5E
                   MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
                   RTS

6E5E L06E5E        MOVEQ    #0,D0                  ;signal "no errors"
6E60 L06E60        RTS

Ú------------------------------------------------------------------------------¿
³=                                                                             ³
³=                                                                             ³
³=SB_CCBTA        CONVERT PRE-COMPILED BASIC TO ASCII                          ³
------------------------------------------------------------------------------
³JOB:                                                                          ³
------------------------------------------------------------------------------
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

6E62 L06E62        MOVEQ    #0,D4
6E64 L06E64        MOVE.W   #$7FFF,D6
6E68 SB_CCBTA      MOVEA.L  BV.PFBAS(A6),A4        ;point at start of basic program
                   CLR.L    BV.LINUM(A6)           ;convert current line number and length to zero
                   TST.W    D4                     ;how was the routine invoked ?
                   BEQ.S    L06E80
                   MOVE.L   A0,-(A7)
                   JSR      L096B0(PC)
                   MOVEA.L  (A7)+,A0
                   MOVE.W   D2,BV.LINUM(A6)
6E80 L06E80        TST.B    D7
                   BNE.S    L06E8C
                   LEA      L0833C(PC),A2          ;point at first syntax table for commands
                   JMP      L088A2(PC)

6E8C L06E8C        CMP.W    4(A6,A4.L),D6
6E90 L06E90        BLT.S    L06E5E
                   MOVE.L   A4,-(A7)
                   MOVE.W   BV.LENGTH(A6),-(A7)
6E98 L06E98        CMPA.L   BV.PFP(A6),A4
                   BGE.S    L06ED8
                   MOVE.W   0(A6,A4.L),D1
                   ADDQ.W   #2,A4
                   ADD.W    D1,BV.LENGTH(A6)
                   ADDA.W   BV.LENGTH(A6),A4
                   CMP.W    4(A6,A4.L),D6
                   BGE.S    L06E98
                   MOVE.W   0(A6,A4.L),D1
                   ADD.W    BV.LENGTH(A6),D1
                   SUB.W    (A7)+,D1
                   MOVE.W   D1,0(A6,A4.L)
                   MOVEA.L  (A7)+,A2
6EC2 L06EC2        MOVE.W   0(A6,A4.L),0(A6,A2.L)
                   ADDQ.W   #2,A4
                   ADDQ.W   #2,A2
                   CMPA.L   BV.PFP(A6),A4
                   BLT.S    L06EC2
                   MOVE.L   A2,BV.PFP(A6)
6ED6 L06ED6        BRA.S    L06E5E

6ED8 L06ED8        ADDQ.W   #2,A7
6EDA L06EDA        MOVE.L   (A7)+,BV.PFP(A6)
                   BRA.S    L06ED6

Ú------------------------------------------------------------------------------¿
³=BP_MODE         SET RESOLUTION OF SCREEN                                     ³
------------------------------------------------------------------------------
³SYNTAX:          mode := numeric_expression {4 .. 512}                        ³
³                                                                              ³
³                 MODE mode                                                    ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

6EE0 BP_MODE       JSR      L05C28(PC)
                   BNE.S    L06EFA
                   ADDQ.L   #2,BV.RIP(A6)
                   MOVE.W   #$108,D1               ;signal "set mode 8"
                   AND.W    D1,TOS(A6,A1.L)
                   BNE.S    L06EF6
                   MOVEQ    #0,D1                  ;signal "set mode 4"
6EF6 L06EF6        MOVEQ    #MT.DMODE,D0           ;TRAP to set or read display mode
                   TRAP     #1
6EFA L06EFA        RTS

Ú------------------------------------------------------------------------------¿
³=BP_NET          SET NETWORK STATION NUMBER                                   ³
------------------------------------------------------------------------------
³SYNTAX:          station := numeric_expression {0 .. 127}                     ³
³                                                                              ³
³                 NET station                                                  ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

6EFC BP_NET        JSR      L05C28(PC)
                   BNE.S    L06F12
                   ADDQ.L   #2,BV.RIP(A6)
                   MOVE.B   1(A6,A1.L),D1
                   BLE.S    L06F14
                   MOVE.B   D1,SV_NETNR
6F12 L06F12        RTS

6F14 L06F14        MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
6F16 L06F16        RTS

Ú------------------------------------------------------------------------------¿
³=BP_INK          SET CURRENT INK COLOUR                                       ³
³=BP_STRIP        SET CURRENT STRIP COLOUR                                     ³
³=BP_PAPER        SET CURRENT PAPER COLOUR                                     ³
------------------------------------------------------------------------------
³SYNTAX:          colour := numeric_expression {0 .. 7}                        ³
³                                                                              ³
³                 INK [channel,] colour                                        ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

6F18 BP_INK        MOVEQ    #$29,D4
                   BRA.S    L06F22

6F1C BP_STRIP      MOVEQ    #$28,D4
                   BRA.S    L06F22

6F20 BP_PAPER      MOVEQ    #$27,D4
6F22 L06F22        JSR      L078CA(PC)
                   BNE.S    L06F3C
                   BSR      L07866
                   BNE.S    L06F3C
                   CMPI.B   #$27,D4
                   BNE.S    L06F38
                   BSR.S    L06F38
                   MOVEQ    #$28,D4
6F38 L06F38        JMP      L07856(PC)

6F3C L06F3C        RTS

Ú------------------------------------------------------------------------------¿
³=BP_CLS          CLEAR PART OR ALL OF WINDOW                                  ³
³=BP_PAN          PAN PART OR ALL OF SCREEN                                    ³
³=BP_SCROL        SCROLL PART OR ALL OF SCREEN                                 ³
------------------------------------------------------------------------------
³SYNTAX:          distance := numeric_expression                               ³
³                 part := numeric_expression                                   ³
³                                                                              ³
³                 CLS [channel,] [part]                                        ³
³                 PAN [channel,] distance [, part]                             ³
³                 SCROLL [channel,] distance [, part]                          ³
³                                                                              ³
³                 part:                                                        ³
³                                                                              ³
³                 0 = whole screen (default if number parameters)              ³
³                 1 = top excluding the cursor line                            ³
³                 2 = bottom excluding the cursor line                         ³
³                 3 = whole of the cursor line                                 ³
³                 4 = right hand end of cursor line including the cursor       ³
³                     position                                                 ³
³                                                                              ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

6F3E BP_CLS        MOVEQ    #32,D4
                   BRA.S    L06F48

6F42 BP_PAN        MOVEQ    #$1B,D4
                   BRA.S    L06F48

6F46 BP_SCROL      MOVEQ    #$18,D4
6F48 L06F48        JSR      L078CA(PC)
                   BNE.S    L06F90
                   MOVE.W   TOS(A6,A1.L),D1
                   CMPI.B   #$20,D4
                   BEQ.S    L06F5C
                   SUBQ.L   #2,A1
                   SUBQ.L   #1,D3
6F5C L06F5C        SUBQ.W   #1,D3
                   BHI.S    L06F8E
                   BLT.S    L06F7A
                   MOVE.W   D4,D3
                   SUBI.W   #$17,D3
                   LSR.W    #2,D3
                   LEA      L06F92(PC),A2
                   BTST     D1,0(A2,D3.W)
                   BEQ.S    L06F8E
                   ADD.L    D1,D4
                   MOVE.W   TOS(A6,A1.L),D1
6F7A L06F7A        JSR      L0888E(PC)
                   BNE.S    L06F8A
                   MOVE.L   BV.LNBAS(A6),BV.LNP(A6)
                   CLR.W    BV.LSBAS(A6)
6F8A L06F8A        JMP      L07856(PC)

6F8E L06F8E        MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
6F90 L06F90        RTS

6F92 L06F92        BTST D3,(A1)+
                   MOVE.B D0,-(A7)

Ú------------------------------------------------------------------------------¿
³=BP_PAUSE        DELAY EXECUTING A SUPERBASIC PROGRAM                         ³
------------------------------------------------------------------------------
³SYNTAX:          delay := numeric_expression                                  ³
³                                                                              ³
³                 PAUSE [delay]                                                ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:          ERR.BP   BAD PARAMETER                                       ³
À------------------------------------------------------------------------------Ù

6F96 BP_PAUSE      JSR      CA_GTINT(PC)           ;get integers,D3 = number found
                   SUBQ.W   #1,D3                  ;only one parameter allowed so
                   BLT.S    L06FA8                 ;jump forward if correct number and
                   BGT.S    L06FB6                 ;exit if too many
                   ADDQ.L   #2,BV.RIP(A6)
                   MOVE.W   TOS(A6,A1.L),D3
6FA8 L06FA8        MOVEQ    #0,D1
                   JSR      L06078(PC)
                   MOVEQ    #IO.FBYTE,D0           ;TRAP to fetch a byte
                   TRAP     #3
                   MOVEQ    #0,D0                  ;signal "no errors"
                   RTS

6FB6 L06FB6        MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
6FB8 L06FB8        RTS

Ú------------------------------------------------------------------------------¿
³=BP_POKE         PLACE BYTE IN MEMORY                                         ³
³=BP_POKEW        PLACE WORD IN MEMORY                                         ³
³=BP_POKEL        PLACE LONG WORD IN MEMORY                                    ³
------------------------------------------------------------------------------
³SYNTAX:          address := numeric_expression                                ³
³                 data := numeric_expression                                   ³
³                                                                              ³
³                 POKE   address, data                                         ³
³                 POKE_W address, data                                         ³
³                 POKE_L address, data                                         ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:          ERR.BP   INVALID NUMBER OF PARAMETERS                        ³
À------------------------------------------------------------------------------Ù

6FBA BP_POKE       MOVEQ    #0,D4
                   BSR.S    L06FD0
                   MOVE.B   D1,(A4)
                   RTS

6FC2 BP_POKEW      BSR.S    L06FCE
                   MOVE.W   D1,(A4)
                   RTS

6FC8 BP_POKEL      BSR.S    L06FCE
                   MOVE.L   D1,(A4)
                   RTS

6FCE L06FCE        MOVEQ    #1,D4
6FD0 L06FD0        JSR      CA_GTLIN(PC)           ;get long integers,D3 = number found
6FD4 L06FD4        BNE.S    L06FF2
                   SUBQ.W   #2,D3
                   BNE.S    L06FEE                 ;exit if more then two parameters
                   ADDQ.L   #8,BV.RIP(A6)
                   MOVEA.L  TOS(A6,A1.L),A4
                   MOVE.L   4(A6,A1.L),D1
                   MOVE.L   A4,D0
                   AND.L    D4,D0
                   BNE.S    L06FEE
                   RTS

6FEE L06FEE        ADDQ.W   #4,A7
6FF0 L06FF0        MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
6FF2 L06FF2        RTS

Ú------------------------------------------------------------------------------¿
³=BP_INPUT        READ CHARACTER(S) FROM A CHANNEL                             ³
³=BP_PRINT        PRINT CHARACTER(S) TO A CHANNEL                              ³
------------------------------------------------------------------------------
³SYNTAX:          separator:=       |!                                         ³
³                                   |,                                         ³
³                                   |\                                         ³
³                                   |;                                         ³
³                                   | TO numeric_expression                    ³
³                                                                              ³
³                 item :=  |expression                                         ³
³                          |channel                                            ³
³                          |separator                                          ³
³                                                                              ³
³                 prompt := [channel,] expression seperator                    ³
³                                                                              ³
³                 INPUT [prompt] [channel] variable *[, variable]*             ³
³                 PRINT *[item]*                                               ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

6FF4 BP_INPUT      ST       D7
6FF6 BP_PRINT      JSR      CA_RERIS(PC)           ;reserve space on  arithmetic stack
                   MOVEQ    #0,D4
                   JSR      L06040(PC)
                   BNE      L07198
                   MOVE.L   A5,-(A7)
                   MOVEA.L  A2,A5
                   MOVEQ    #0,D5
                   TST.B    D7
                   BEQ.S    L0701E
                   MOVEQ    #11,D0
                   MOVEA.L  (A6),A1
                   BSR      L072B6
                   CMPI.W   #$FFF1,D0
                   BNE.S    L0701E
                   MOVEQ    #1,D7
701E L0701E        CMPA.L   (A7),A3
                   BGE      L07188
                   MOVE.B   1(A6,A3.L),D0
                   MOVE.B   D0,D5
                   LSR.B    #4,D5
                   ANDI.B   #%00001111,D0
                   BNE.S    L07040
                   TST.B    0(A6,A3.L)
                   BNE.S    L07040
                   BSR      L072A2
                   BRA      L0717C

7040 L07040        TST.W    2(A6,A3.L)
7044 L07044        SGE      D1
                   AND.B    D7,D1
                   BEQ.S    L0705E
                   MOVE.W   D0,-(A7)
                   BSR      L072A2
                   MOVE.W   (A7)+,D0
                   JSR      L0730C(PC)
                   BNE      L0719A
                   BRA      L0717C

705E L0705E        TST.B    D7
7060 L07060        BGT      L07182
                   MOVEA.L  BV.VVBAS(A6),A0
                   MOVE.L   4(A6,A3.L),D1
                   BLT      L07172
                   ADDA.L   D1,A0
                   CMPI.B   #3,0(A6,A3.L)
                   BNE      L0716E
                   TST.B    D5
                   BEQ.S    L0708A
                   CMPI.B   #5,D5
                   BNE.S    L0708C
                   SWAP     D5
                   BRA.S    L0708C

708A L0708A        MOVEQ    #3,D5
708C L0708C        MOVE.B   D0,-(A7)
708E L0708E        MOVEA.L  A0,A2
                   BSR      L07164
                   SUBA.L   BV.VVBAS(A6),A2
                   SUBA.L   BV.CHBAS(A6),A5
                   MOVEM.L  A2-3/A5,-(A7)
                   JSR      $00004EF0(PC)
                   MOVEM.L  (A7)+,A2-3/A5
                   ADDA.L   BV.CHBAS(A6),A5
                   ADDA.L   BV.VVBAS(A6),A2
                   MOVEA.L  A0,A4
70B2 L070B2        SUBQ.W   #1,D1
                   LEA      0(A4,D1.W),A1
                   SF       TOS(A6,A1.L)
                   BNE.S    L070B2
                   MOVE.W   4(A6,A2.L),D1
                   MOVE.B   (A7),D0
                   SUBQ.B   #2,D0
                   BLT.S    L070D2
                   BEQ.S    L070CE
                   MOVEQ    #2,D0
                   BRA.S    L070D6

70CE L070CE        MOVEQ    #6,D0
70D0 L070D0        BRA.S    L070D6

70D2 L070D2        SUBQ.W   #1,D1
70D4 L070D4        MOVEQ    #1,D0
70D6 L070D6        MOVE.W   D0,0(A6,A4.L)
                   LSL.W    #1,D1
                   MOVE.W   D1,2(A6,A4.L)
70E0 L070E0        MOVEA.L  BV.VVBAS(A6),A0
                   ADDA.L   0(A6,A2.L),A0
                   MOVE.W   4(A6,A2.L),D0
                   LSL.W    #2,D0
                   LEA      2(A2,D0.W),A1
                   MOVE.W   TOS(A6,A1.L),D3
                   LSR.W    #1,D0
70F8 L070F8        LEA      2(A4,D0.W),A1
                   MOVE.W   TOS(A6,A1.L),D1
                   LSL.W    #1,D0
                   LEA      4(A2,D0.W),A1
                   LSR.W    #1,D0
                   MULU     TOS(A6,A1.L),D1
                   MULU     0(A6,A4.L),D1
                   ADDA.L   D1,A0
                   SUBQ.W   #2,D0
                   BNE.S    L070F8
                   MOVE.B   (A7),D0
                   BSR      L071A6
                   BNE.S    L07148
                   MOVE.W   2(A6,A4.L),D0
                   BEQ.S    L07148
7124 L07124        LSL.W    #1,D0
                   LEA      2(A2,D0.W),A1
                   MOVE.W   TOS(A6,A1.L),D1
                   LSR.W    #1,D0
                   LEA      2(A4,D0.W),A1
                   CMP.W    TOS(A6,A1.L),D1
                   BEQ.S    L07140
                   ADDQ.W   #1,TOS(A6,A1.L)
                   BRA.S    L070E0

7140 L07140        CLR.W    TOS(A6,A1.L)
7144 L07144        SUBQ.W   #2,D0
                   BNE.S    L07124
7148 L07148        BSR.S    L07164
                   MOVEA.L  A4,A0
                   MOVE.L   D0,-(A7)
                   MOVE.L   A3,-(A7)
                   JSR      L050E2(PC)
                   MOVEA.L  (A7)+,A3
                   MOVE.L   (A7)+,D0
                   ADDQ.W   #2,A7
                   BNE.S    L07196
                   TST.B    D5
                   BNE.S    L07182
                   SWAP     D5
                   BRA.S    L0717C

7164 L07164        MOVEQ    #2,D1
7166 L07166        ADD.W    4(A6,A2.L),D1
                   LSL.W    #1,D1
                   RTS

716E L0716E        BSR.S    L071A6
7170 L07170        BRA.S    L07180

7172 L07172        BSR      L072A2
7176 L07176        MOVEQ    #$2A,D1
                   BSR      L072A8
717C L0717C        BSR      L07228
7180 L07180        BNE.S    L07196
7182 L07182        ADDQ.W   #8,A3
                   BRA      L0701E

7188 L07188        TST.B    D5
718A L0718A        BNE.S    L07194
                   TST.B    D7
                   BGT.S    L07194
                   BSR      L0727C
7194 L07194        MOVEQ    #0,D0
7196 L07196        MOVEA.L  (A7)+,A5
7198 L07198        RTS

719A L0719A        MOVE.L   D0,-(A7)
719C L0719C        MOVEQ    #15,D0
                   BSR      L072B8
                   MOVE.L   (A7)+,D0
                   BRA.S    L07196

71A6 L071A6        MOVEA.L  BV.RIP(A6),A1
71AA L071AA        SUBQ.W   #6,A1
                   TST.B    D0
                   BEQ.S    L071C0
                   SUBQ.B   #2,D0
                   BGT.S    L071C6
                   BEQ.S    L071D6
                   MOVE.W   0(A6,A0.L),D2
                   MOVEA.L  A0,A1
                   ADDQ.W   #2,A1
                   BRA.S    L071F2

71C0 L071C0        MOVEA.L  A0,A1
71C2 L071C2        MOVE.W   D3,D2
                   BRA.S    L071F2

71C6 L071C6        MOVE.W   0(A6,A0.L),TOS(A6,A1.L)
71CC L071CC        MOVEA.L  (A6),A0
                   ADDQ.W   #1,A0
                   JSR      CN_ITOD(PC)            ;convert integer to decimal ascii
                   BRA.S    L071EA

71D6 L071D6        MOVE.L   2(A6,A0.L),2(A6,A1.L)
71DC L071DC        MOVE.W   0(A6,A0.L),TOS(A6,A1.L)
                   MOVEA.L  (A6),A0
                   ADDQ.W   #1,A0
                   JSR      CN_FTOD(PC)            ;convert floating point to ascii
71EA L071EA        MOVEA.L  (A6),A1
                   ADDQ.W   #1,A1
                   MOVE.L   A0,D2
                   SUB.L    A1,D2
71F2 L071F2        TST.B    D4
                   BEQ.S    L0721A
                   SWAP     D4
                   ADDQ.W   #1,D2
                   SUBQ.W   #1,A1
                   MOVE.B   TOS(A6,A1.L),-(A7)
                   SUB.W    D2,D4
                   BLT.S    L0720C
                   MOVE.B   #$20,TOS(A6,A1.L)
                   BRA.S    L07218

720C L0720C        MOVE.B   #10,TOS(A6,A1.L)
7212 L07212        MOVE.W   #$FFFF,32(A6,A5.L)
7218 L07218        SWAP     D4
721A L0721A        BSR      L072B0
                   TST.B    D4
                   BEQ.S    L07228
                   SUBA.W   D2,A1
                   MOVE.B   (A7)+,TOS(A6,A1.L)
7228 L07228        TAS      BV.BRK(A6)
                   BNE.S    L07230
                   MOVEQ    #ERR.NC,D0             ;signal "not complete"
7230 L07230        TST.L    D0
                   BNE.S    L072A0
                   TST.B    D7
                   BGT.S    L0729E
                   SF       D4
                   CMPI.B   #1,D5
                   BEQ.S    L07286
                   CMPI.B   #3,D5
                   BEQ.S    L0727C
                   CMPI.B   #4,D5
                   BEQ.S    L0726E
                   CMPI.B   #5,D5
                   BNE.S    L0729E
                   MOVE.L   A5,-(A7)
                   ADDQ.W   #8,A3
                   LEA      8(A3),A5
                   JSR      L05C28(PC)
                   MOVEA.L  (A7)+,A5
                   BNE.S    L072A0
                   MOVE.W   TOS(A6,A1.L),D2
                   ADDQ.L   #2,BV.RIP(A6)
                   BSR.S    L072C2
                   BRA.S    L07292

726E L0726E        BSR.S    L072C2
7270 L07270        SUB.W    D0,D1
                   MOVE.W   D1,D4
                   SWAP     D4
                   TST.W    D0
                   SNE      D4
                   BRA.S    L0729E

727C L0727C        MOVEQ    #10,D1
727E L0727E        BSR.S    L072A8
                   CLR.W    32(A6,A5.L)
                   BRA.S    L0729E

7286 L07286        BSR.S    L072C2
7288 L07288        MOVE.W   D0,D2
                   ADDQ.W   #8,D2
                   ANDI.W   #$F8,D2
                   SUBQ.W   #8,D1
7292 L07292        SUB.W    D2,D1
                   BLT.S    L0727C
                   SUB.W    D0,D2
7298 L07298        BSR.S    L072A6
                   SUBQ.W   #1,D2
                   BGT.S    L07298
729E L0729E        MOVEQ    #,D0
72A0 L072A0        RTS

72A2 L072A2        TST.B    D4
72A4 L072A4        BEQ.S    L072A0
72A6 L072A6        MOVEQ    #$20,D1
72A8 L072A8        MOVEQ    #IO.SBYTE,D0           ;TRAP to send a byte
                   ADDQ.W   #1,32(A6,A5.L)
                   BRA.S    L072B8

72B0 L072B0        MOVEQ    #IO.SSTRG,D0           ;TRAP to send a string of bytes
72B2 L072B2        ADD.W    D2,32(A6,A5.L)
72B6 L072B6        TRAP     #4                     ;convert to absolute addresses
72B8 L072B8        MOVEQ    #-1,D3                 ;use an infinite timeout
                   MOVEA.L  0(A6,A5.L),A0
                   TRAP     #3
                   RTS

72C2 L072C2        MOVEQ    #SD.CHENQ,D0           ;TRAP to read window size/cursor
72C4 L072C4        MOVEA.L  (A6),A1
                   BSR.S    L072B6
                   TST.L    D0
                   BNE.S    L072D6
                   MOVE.W   4(A6,A1.L),D0
                   MOVE.W   TOS(A6,A1.L),D1
                   RTS

72D6 L072D6        MOVE.W   $22(A6,A5.L),D1
72DA L072DA        MOVE.W   $20(A6,A5.L),D0
                   RTS

Ú------------------------------------------------------------------------------¿
³=BP_RNDMZ        RESEED RANDOM NUMBER GENERATOR                               ³
------------------------------------------------------------------------------
³SYNTAX:          seed := numeric_expression                                   ³
³                                                                              ³
³                 RANDOMIZE seed                                               ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

72E0 BP_RNDMZ      JSR      CA_GTLIN(PC)           ;get long integers,D3 = number found
                   BNE.S    L07306                 ;and exit if none found
                   SUBQ.W   #1,D3
                   BGT.S    L07308
                   BEQ.S    L072F2
                   MOVEQ    #MT.RCLCK,D0           ;TRAP to read clock
                   TRAP     #1
                   BRA.S    L072FC

72F2 L072F2        MOVE.L   TOS(A6,A1.L),D1
72F6 L072F6        ADDQ.L   #4,BV.RIP(A6)
                   MOVEQ    #0,D0
72FC L072FC        MOVE.L   D1,D2
                   SWAP     D1
                   ADD.L    D2,D1
                   MOVE.L   D1,BV.RAND(A6)
7306 L07306        RTS

7308 L07308        MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
730A L0730A        RTS

730C L0730C        MOVE.L   D7,-(A7)
730E L0730E        MOVE.W   D0,-(A7)
                   BSR.S    L0737C
                   BEQ.S    L0731C
7314 L07314        ADDQ.W   #2,A7
7316 L07316        MOVE.L   (A7)+,D7
                   TST.L    D0
                   RTS

731C L0731C        MOVE.L   A3,-(A7)
731E L0731E        MOVEA.L  0(A6,A5.L),A0
                   MOVEA.L  (A6),A1
                   ADDA.L   A6,A1
                   MOVEQ    #IO.FLINE,D0           ;TRAP to fetch a line
                   MOVE.W   #$80,D2
                   MOVEQ    #-1,D3                 ;use an infinite timout
                   TRAP     #3
                   TST.L    D0
                   BEQ.S    L07338
                   MOVEA.L  (A7)+,A3
                   BRA.S    L07314

7338 L07338        MOVEQ    #SD.PCOL,D0            ;TRAP to set to previous column
733A L0733A        TRAP     #3
                   MOVEQ    #SD.NCOL,D0            ;TRAP to set to next column
                   TRAP     #3
                   MOVEA.L  (A7)+,A3
                   MOVEA.L  (A6),A0
                   SUBA.L   A6,A1
                   MOVE.L   A1,D7
                   MOVEA.L  BV.RIP(A6),A1
                   MOVE.W   (A7)+,D0
                   SUBQ.B   #2,D0
                   BLT.S    L07362
                   BEQ.S    L0735A
                   JSR      CN_DTOI(PC)            ;convert ascii to integer
                   BRA.S    L0735E

735A L0735A        JSR      CN_DTOF(PC)            ;convert ascii to floating point
735E L0735E        BNE.S    L07316
7360 L07360        BRA.S    L0736A

7362 L07362        MOVEA.L  D7,A0
7364 L07364        SUBQ.W   #1,A0
                   JSR      L05496(PC)
736A L0736A        MOVE.L   A1,BV.RIP(A6)
                   SUBA.L   BV.CHBAS(A6),A5
                   JSR      BP_LET(PC)             ;return parameter values
                   ADDA.L   BV.CHBAS(A6),A5
                   BRA.S    L07316

737C L0737C        MOVE.B   0(A6,A3.L),D0
7380 L07380        SUBQ.B   #2,D0
                   BLE.S    L073AE
                   SUBQ.B   #1,D0
                   BNE.S    L073A6
                   MOVE.B   1(A6,A3.L),D0
                   ANDI.B   #%00001111,D0
                   SUBQ.B   #1,D0
                   BGT.S    L073B6
                   MOVEA.L  4(A6,A3.L),A2
                   ADDA.L   BV.VVBAS(A6),A2
                   CMPI.W   #1,4(A6,A2.L)
                   BGT.S    L073B6
                   BRA.S    L073AE

73A6 L073A6        SUBQ.B   #3,D0
73A8 L073A8        BLT.S    L073B2
                   SUBQ.B   #1,D0
                   BGT.S    L073B2
73AE L073AE        MOVEQ    #0,D0
                   RTS

73B2 L073B2        MOVEQ    #ERR.BN,D0             ;signal "bad name"
73B4 L073B4        RTS

73B6 L073B6        MOVEQ    #ERR.NI,D0             ;signal "not implemented"
73B8 L073B8        RTS

Ú------------------------------------------------------------------------------¿
³=BP_RECOL        RECOLOUR INDIVIDUAL PIXELS IN WINDOW                         ³
------------------------------------------------------------------------------
³SYNTAX:          c0 := new colour for black                                   ³
³                 c1 := new colour for blue                                    ³
³                 c2 := new colour for red                                     ³
³                 c3 := new colour for magenta                                 ³
³                 c4 := new colour for green                                   ³
³                 c5 := new colour for cyan                                    ³
³                 c6 := new colour for yellow                                  ³
³                 c7 := new colour for white                                   ³
³                                                                              ³
³                 RECOL [channel,] c0, c1, c2, c3, c4, c5, c6, c7              ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:          ERR>BP   invalid colour list                                 ³
À------------------------------------------------------------------------------Ù

73BA BP_RECOL      JSR      L078CA(PC)
                   BNE.S    L073E2
                   CMPI.W   #8,D3
                   BNE.S    L073E0
                   MOVEA.L  A1,A2
                   MOVEQ    #7,D0                  ;8 parameters to copy
73CA L073CA        MOVE.B   1(A6,A2.L),1(A6,A1.L)
                   SUBQ.W   #2,A2
                   SUBQ.W   #1,A1
                   DBF      D0,L073CA
                   ADDQ.W   #2,A1
                   MOVEQ    #$26,D4
                   JMP      L07856(PC)

73E0 L073E0        MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
73E2 L073E2        RTS

Ú------------------------------------------------------------------------------¿
³=BP_EDIT         EDIT LIST OF SUPERBASIC LINES                                ³
³=BP_AUTO         GENERATE LINE NUMBERS AUTOMATICALLY                          ³
------------------------------------------------------------------------------
³SYNTAX:          first_line := numeric_expression                             ³
³                 gap := numeric_expression                                    ³
³                                                                              ³
³                 EDIT [first_line] [, gap]                                    ³
³                 AUTO [first_line] [, gap]                                    ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

73E4 BP_EDIT       MOVEQ    #0,D4
                   BRA.S    L073EA

73E8 BP_AUTO       MOVEQ    #10,D4
73EA L073EA        ST       BV.AUTO(A6)
                   TST.B    BV.UNRVL(A6)
                   BNE.S    L07420
                   BRA.S    L07414

73F6 L073F6        MOVEQ    #0,D5
73F8 L073F8        CMPA.L   4(A7),A3
                   BEQ.S    L0740E
                   JSR      L06DA2(PC)
                   BEQ.S    L0740E
                   JSR      L06E40(PC)
                   BEQ.S    L07410
                   ADDQ.W   #4,A7
                   BRA.S    L07472

740E L0740E        MOVEQ    #1,D0
7410 L07410        RTS

Ú------------------------------------------------------------------------------¿
³=BP_RENUM        RENUMBER SUPERBASIC PROGRAM LINES                            ³
------------------------------------------------------------------------------
³SYNTAX:          first := numeric_expression                                  ³
³                 last := numeric_expression                                   ³
³                 start := numeric_expression                                  ³
³                 step := numeric_expression                                   ³
³                                                                              ³
³                 RENUM [first [TO last];] [start] [, step]                    ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

7412 BP_RENUM      MOVEQ    #10,D4
7414 L07414        JSR      L076FE(PC)
                   BEQ.S    L07420
                   ST       BV.UNDO(A6)
                   RTS

7420 L07420        MOVE.L   A5,-(A7)
7422 L07422        MOVE.W   #$7FFF,D7
                   MOVEQ    #$64,D6
                   SWAP     D4
                   BSR.S    L073F6
                   CMPI.B   #5,D5
                   BNE.S    L07448
                   TST.B    D0
                   BNE.S    L07438
                   MOVE.W   D1,D4
7438 L07438        BSR.S    L073F6
                   CMPI.B   #2,D5
                   BNE.S    L07472
                   TST.B    D0
                   BNE.S    L07454
                   MOVE.W   D1,D7
                   BRA.S    L07454

7448 L07448        CMPI.B   #2,D5
744C L0744C        BNE.S    L07456
                   TST.B    D0
                   BNE.S    L07454
                   MOVE.W   D1,D4
7454 L07454        BSR.S    L073F6
7456 L07456        TST.B    D0
                   BNE.S    L0745C
                   MOVE.W   D1,D6
745C L0745C        SWAP     D4
                   CMPI.B   #1,D5
                   BNE.S    L0746A
                   BSR.S    L073F6
                   BNE.S    L0746A
                   MOVE.W   D1,D4
746A L0746A        MOVE.W   D4,D3
                   SWAP     D4
                   TST.B    D5
                   BEQ.S    L07482
7472 L07472        SF       BV.AUTO(A6)
                   ADDQ.W   #4,A7
                   MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
                   RTS

747C L0747C        ADDQ.W   #2,A7
747E L0747E        MOVEQ    #ERR.OR,D0             ;signal "out of range"
                   RTS

7482 L07482        MOVE.W   D7,D5
7484 L07484        ADDQ.W   #4,A7
                   TST.B    BV.AUTO(A6)
                   BEQ.S    L07498
                   MOVE.W   D6,BV.EDLIN(A6)
                   MOVE.W   D3,BV.EDINC(A6)
7494 L07494        MOVEQ    #0,D0                  ;signal "no errors"
                   RTS

7498 L07498        MOVEA.L  BV.PFBAS(A6),A4
749C L0749C        CMPA.L   BV.PFP(A6),A4
                   BGE.S    L07494
                   CLR.W    -(A7)
                   CLR.L    BV.LINUM(A6)
                   TST.W    D4
                   BEQ.S    L074C6
                   JSR      L096B0(PC)
                   CMPA.L   (A6),A4
                   BEQ.S    L074C6
                   SUBA.W   BV.LENGTH(A6),A4
                   MOVE.W   2(A6,A4.L),D2
                   CMP.W    D2,D6
                   BLE.S    L0747C
                   ADDA.W   BV.LENGTH(A6),A4
                   MOVE.W   D2,(A7)
74C6 L074C6        MOVEQ    #0,D0
74C8 L074C8        ADDQ.W   #1,D0
                   BSR.S    L0753C
                   BEQ.S    L074C8
                   BGT.S    L074D4
                   MOVE.W   #$7FFF,D2
74D4 L074D4        MOVE.L   D0,D1
                   SUBQ.W   #1,D1
                   MULU     D3,D1
                   ADD.L    D6,D1
                   EXT.L    D2
                   CMP.L    D2,D1
                   BGE.S    L0747C
                   MOVE.W   D2,-(A7)
                   MOVEQ    #2,D1
                   ADD.L    D0,D1
                   LSL.L    #2,D1
                   JSR      L04EF0(PC)
                   MOVEA.L  A0,A3
                   SUBA.L   BV.VVBAS(A6),A3
                   MOVE.L   D1,0(A6,A0.L)
                   SUBA.W   BV.LENGTH(A6),A4
                   MOVE.W   2(A6,A4.L),BV.LINUM(A6)
                   ADDA.W   BV.LENGTH(A6),A4
                   JSR      L096B0(PC)
                   BSR      L07644
                   MOVE.W   D6,D0
                   MOVE.W   4(A6,A4.L),D2
                   MOVE.W   2(A7),D6
                   SWAP     D4
751A L0751A        MOVE.W   D2,0(A6,A0.L)
                   MOVE.W   D0,2(A6,A0.L)
                   MOVE.W   D0,4(A6,A4.L)
                   ADDQ.W   #4,A0
                   ADD.W    D4,D0
                   BSR.S    L0753C
                   BEQ.S    L0751A
                   MOVE.W   (A7),D5
                   MOVE.W   D5,0(A6,A0.L)
                   MOVE.W   D5,2(A6,A0.L)
                   ADDQ.W   #4,A7
                   BRA.S    L07568

753C L0753C        MOVE.W   0(A6,A4.L),D1
7540 L07540        ADDQ.W   #2,A4
                   ADD.W    D1,BV.LENGTH(A6)
                   ADDA.W   BV.LENGTH(A6),A4
                   CMPA.L   BV.PFP(A6),A4
                   BGE.S    L07560
                   MOVE.W   4(A6,A4.L),D2
                   CMP.W    D2,D5
                   BLT.S    L0755C
                   MOVEQ    #0,D1
                   RTS

755C L0755C        MOVEQ    #1,D1
755E L0755E        RTS

7560 L07560        MOVEQ    #ERR.NC,D1             ;signal "not complete"
7562 L07562        RTS

7564 L07564        JMP      L9B92(PC)

7568 L07568        ST       BV.EDIT(A6)
756C L0756C        JSR      L08D70(PC)
                   BRA.S    L07578

7572 L07572        JSR      L09C30(PC)
7576 L07576        BNE.S    L075F4
7578 L07578        BSR.S    L07564
                   CMPI.W   #$8111,D1
                   BEQ.S    L075A0
                   CMPI.W   #$810A,D1
                   BEQ.S    L0759C
                   CMPI.W   #$8115,D1
                   BNE.S    L07572
758C L0758C        JSR      L0885E(PC)
                   JSR      L08E58(PC)
                   BEQ.S    L07572
                   CMPI.W   #$810A,D1
                   BNE.S    L0758C
759C L0759C        ADDQ.W   #2,A4
                   BSR.S    L07564
75A0 L075A0        ADDQ.W   #2,A4
                   BSR.S    L07564
                   CMPI.W   #$840A,D1
                   BEQ.S    L07572
                   SUBI.W   #$F000,D1
                   BGE.S    L075BC
75B0 L075B0        MOVE.W   #$8404,D4
                   JSR      L09C02(PC)
                   BNE.S    L07572
                   BRA.S    L075A0

75BC L075BC        MOVEA.L  BV.RIP(A6),A1
75C0 L075C0        SUBQ.W   #6,A1
                   MOVE.W   D1,TOS(A6,A1.L)
                   MOVE.L   2(A6,A4.L),2(A6,A1.L)
                   JSR      L04830(PC)
                   MOVE.W   TOS(A6,A1.L),D1
                   BSR.S    L0764E
                   BLE.S    L075B0
                   MOVE.W   D1,TOS(A6,A1.L)
                   JSR      L04852(PC)
                   MOVE.W   TOS(A6,A1.L),D0
                   ADDI.W   #$F000,D0
                   MOVE.W   D0,0(A6,A4.L)
                   MOVE.L   2(A6,A1.L),2(A6,A4.L)
                   BRA.S    L075B0

75F4 L075F4        MOVE.W   BV.LSBEF(A6),D1
75F8 L075F8        BSR.S    L0764E
                   MOVE.W   D1,BV.LSBEF(A6)
                   MOVE.W   BV.LSBAS(A6),D1
                   BSR.S    L0764E
                   MOVE.W   D1,BV.LSBAS(A6)
                   MOVE.W   BV.LSAFT(A6),D1
                   BSR.S    L0764E
                   MOVE.W   D1,BV.LSAFT(A6)
                   MOVEA.L  BV.LNBAS(A6),A1
                   MOVE.W   TOS(A6,A1.L),D1
                   BSR.S    L0764E
                   MOVE.W   D1,TOS(A6,A1.L)
                   ST       BV.CONT(A6)
                   BSR.S    L07644
                   SUBQ.W   #4,A0
                   MOVE.L   0(A6,A0.L),D1
                   JSR      L050E2(PC)
                   MOVEQ    #0,D2
                   MOVEQ    #0,D5
                   SUBA.L   A0,A0
                   JSR      L0888E(PC)
                   MOVEA.L  D0,A0
                   JSR      L087D2(PC)
                   MOVEQ    #0,D0
                   RTS

7644 L07644        MOVEA.L  BV.VVBAS(A6),A0
7648 L07648        ADDA.L   A3,A0
                   ADDQ.W   #4,A0
                   RTS

764E L0764E        CMP.W    D6,D1
7650 L07650        BLE.S    L07664
                   CMP.W    D1,D5
                   BLT.S    L07664
                   BSR.S    L07644
7658 L07658        CMP.W    0(A6,A0.L),D1
                   ADDQ.W   #4,A0
                   BGT.S    L07658
                   MOVE.W   -2(A6,A0.L),D1
7664 L07664        RTS

Ú------------------------------------------------------------------------------¿
³=BP_CLEAR        CLEAR SUPERBASIC VARIABLES                                   ³
------------------------------------------------------------------------------
³SYNTAX:          CLEAR                                                        ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

7666 BP_CLEAR      MOVEQ    #0,D6
                   MOVEQ    #0,D0
                   MOVE.W   #-1,BV.NXLIN(A6)       ;signal "no next line"
                   BRA.S    L076AE

Ú------------------------------------------------------------------------------¿
³=BP_RUN          START PROGRAM EXECUTION                                      ³
------------------------------------------------------------------------------
³SYNTAX:          line := numeric_expression                                   ³
³                                                                              ³
³                 RUN line                                                     ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

7672 BP_RUN        JSR      CA_GTINT(PC)           ;get integers,D3 = number found
                   BNE.S    L076EC
                   MOVEQ    #6,D6
                   MOVE.W   D7,BV.NXLIN(A6)
                   SUBQ.W   #1,D3
                   BLT.S    L076E2
                   BEQ.S    L07688
                   MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
                   RTS

7688 L07688        MOVE.W   TOS(A6,A1.L),BV.NXLIN(A6)
768E L0768E        MOVE.B   D7,BV.NXSTM(A6)
                   ADDQ.L   #2,BV.RIP(A6)
                   BRA.S    L076E2

Ú------------------------------------------------------------------------------¿
³=BP_MERGE        LOAD and MERGE A SUPERBASIC PROGRAM                          ³
³=BP_MRUN         LOAD,MERGE and RUN A SUPERBASIC PROGRAM                      ³
------------------------------------------------------------------------------
³SYNTAX:          MERGE device                                                 ³
³                 MRUN device                                                  ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

7698 BP_MERGE      BSR.S    L076FE
                   MOVEQ    #14,D6
                   TST.B    BV.SING(A6)
                   BNE.S    L076C4
                   BSR.S    L076FE
76A2 BP_MRUN       MOVEQ    #12,D6                 ;! check address label L076A2
                   BSR.S    L076EE
                   BNE.S    L076DC
                   MOVE.W   D7,BV.NXLIN(A6)
76AE L076AE        TST.B    BV.SING(A6)
                   BNE.S    L076E2
                   MOVE.W   BV.LINUM(A6),BV.NXLIN(A6)
                   MOVE.B   BV.STMNT(A6),BV.NXSTM(A6)
                   BRA.S    L076E2

Ú------------------------------------------------------------------------------¿
³=BP_LOAD         LOAD A SUPERBASIC PROGRAM                                    ³
³=BP_LRUN         LOAD and RUN A SUPERBASIC PROGRAM                            ³
------------------------------------------------------------------------------
³SYNTAX:          LOAD device                                                  ³
³                 LRUN device                                                  ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

76C2 BP_LOAD       MOVEQ    #10,D6
76C4 L076C4        BSR.S    L076EE
                   BRA.S    L076DC

76C8 BP_LRUN       MOVEQ    #8,D6
                   BSR.S    L076EE
                   BNE.S    L076DC
                   MOVE.W   D7,BV.NXLIN(A6)
                   BRA.S    L076E2

Ú------------------------------------------------------------------------------¿
³=BP_NEW          CLEAR SUPERBASIC PROGRAM and VARIABLES                       ³
³=BP_STOP         TERMINATE PROGRAM EXECUTION                                  ³
------------------------------------------------------------------------------
³SYNTAX:          NEW                                                          ³
³                 STOP                                                         ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

76D4 BP_NEW        MOVEQ    #2,D6
                   BRA.S    L076DA

76D8 BP_STOP       MOVEQ    #4,D6
76DA L076DA        MOVEQ    #0,D0
76DC L076DC        MOVE.W   #-1,BV.NXLIN(A6)
76E2 L076E2        SF       BV.CONT(A6)
                   MOVE.W   D6,BV.STOPN(A6)
                   TST.L    D0
76EC L076EC        RTS

76EE L076EE        MOVEQ    #1,D4
76F0 L076F0        JSR      L06408(PC)
                   BNE.S    L076EC
                   MOVE.L   A0,BV.COMCH(A6)
                   MOVEQ    #0,D0                  ;signal "no errors"
                   RTS

76FE L076FE        TST.B    BV.UNRVL(A6)
7702 L07702        BNE.S    L07712
                   MOVE.L   BV.RTP(A6),D0
                   SUB.L    BV.RTBAS(A6),D0
                   BEQ.S    L07712
                   ADDQ.W   #4,A7
                   MOVEQ    #ERR.NI,D0             ;signal "not implemented"
7712 L07712        RTS

Ú------------------------------------------------------------------------------¿
³=BP_RETRY        RE-EXECUTE SUPERBASIC STATEMENT                              ³
³=BP_CONTI        CONTINUE HALTED SUPERBASIC PROGRAM                           ³
------------------------------------------------------------------------------
³SYNTAX:          RETRY                                                        ³
³                 CONTINUE                                                     ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

7714 BP_RETRY      SUBQ.B   #1,BV.CNSTM(A6)
                   BGE.S    BP_CONTI
                   SF       BV.CNSTM(A6)
771E BP_CONTI      MOVEQ    #16,D6
                   BRA.S    L076DA

Ú------------------------------------------------------------------------------¿
³=BP_TURNT        TURN TURTLE TO SPECIFIED ANGLE                               ³
³=BP_TURN         TURN TURTLE BY SPECIFIED ANGLE                               ³
------------------------------------------------------------------------------
³SYNTAX:          angle := numeric_expression {in degrees}                     ³
³                                                                              ³
³                 TURNTO [channel,] angle                                      ³
³                 TURN [channel,] angle                                        ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

7722 BP_TURNT      BSR      L077B6
                   BNE.S    L07762
                   BRA.S    L07738

772A BP_TURN       BSR      L077B6
                   BNE.S    L07762
                   BSR      L077D4
                   JSR      L048D2(PC)
7738 L07738        LEA      L077E4(PC),A3          ;A3 points at list of operations
                   LEA      6(A1),A4
                   SUBQ.W   #6,A1
                   MOVE.W   #$0809,TOS(A6,A1.L)
                   MOVE.L   #$5A000000,2(A6,A1.L)
                   JSR      RI_EXECB(PC)           ;execute list of maths operations
                   MOVE.W   TOS(A6,A1.L),16(A6,A2.L)
                   MOVE.L   2(A6,A1.L),18(A6,A2.L)
7760 L07760        MOVEQ    #0,D0                  ;signal "no errors"
7762 L07762        RTS

Ú------------------------------------------------------------------------------¿
³=BP_PENUP        SWITCH TURTLE GRAPHICS PEN OFF                               ³
³=BP_PENDO        SWITCH TURTLE GRAPHICS PEN ON                                ³
------------------------------------------------------------------------------
³SYNTAX:          PENUP [channel]                                              ³
³                 PENDOWN [channel]                                            ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

7764 BP_PENUP      MOVEQ    #0,D4
                   BRA.S    L0776A

7768 BP_PENDO      MOVEQ    #1,D4
776A L0776A        JSR      L06040(PC)
                   BNE.S    L07762
                   MOVE.B   D4,22(A6,A2.L)
                   BRA.S    L07760

Ú------------------------------------------------------------------------------¿
³=BP_MOVE         MOVE TURTLE IN CURRENT DIRECTION                             ³
------------------------------------------------------------------------------
³SYNTAX:          distance := numeric_expression                               ³
³                                                                              ³
³                 MOVE [channel,] distance                                     ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

7776 BP_MOVE       BSR.S    L077B6
                   BNE.S    L077B4
                   BSR.S    L077D4
                   SUBQ.W   #6,A1
                   MOVE.W   #$07FB,TOS(A6,A1.L)
                   MOVE.L   #$477D1A89,2(A6,A1.L)
                   JSR      L04966(PC)
                   JSR      L067B4(PC)
                   JSR      L067C4(PC)
                   LEA      L077EC(PC),A3          ;A3 points at list of operations
                   LEA      24(A1),A4
                   JSR      RI_EXECB(PC)           ;execute list of maths operations
                   JSR      L067D4(PC)
                   TST.B    22(A6,A2.L)
                   BEQ.S    L07760
                   MOVEQ    #SD.LINE,D0            ;TRAP to draw line
                   TRAP     #4                     ;convert to absolute addresses
                   TRAP     #3
77B4 L077B4        RTS

77B6 L077B6        MOVE.W   #256,D1
77BA L077BA        JSR      BV_CHRIX(PC)           ;reserve space on arithmetic stack
                   JSR      L06040(PC)
                   BNE.S    L077D2
                   MOVE.L   BV.RIP(A6),-(A7)
                   JSR      L05C30(PC)
                   MOVE.L   (A7)+,BV.RIP(A6)
                   TST.L    D0
77D2 L077D2        RTS

77D4 L077D4        SUBQ.W   #6,A1
77D6 L077D6        MOVE.W   16(A6,A2.L),TOS(A6,A1.L)
                   MOVE.L   18(A6,A2.L),2(A6,A1.L)
                   RTS

   List of maths operations for the TURN and TURNTO procedures.

77E4 L077E4        DC.B     $FA
                   DC.B     $F4
                   DC.B     RI.DIV                 ;divide tos into nos
                   DC.B     RI.INT                 ;truncate floating point into word
77E8 L077E8        DC.B     RI.LINT                ;convert back into floating point
                   DC.B     RI.ABS                 ;take absolute value
                   DC.B     RI.SUB                 ;subtract tos from nos
                   DC.B     RI.TERM                ;terminate execution

77EC L077EC        DC.B     $FA
                   DC.B     $F4
                   DC.B     $18
                   DC.B     $0E
                   DC.B     $EE
                   DC.B     $0A
                   DC.B     $FA
                   DC.B     $F4
                   DC.B     $1A
                   DC.B     $0E
                   DC.B     $E8
                   DC.B     $0A
                   DC.W     RI.TERM                ;terminate execution

Ú------------------------------------------------------------------------------¿
³=BP_WIDTH        SET DEFAULT WIDTH ON DEVICE                                  ³
------------------------------------------------------------------------------
³SYNTAX:          line_width := numeric_expression                             ³
³                                                                              ³
³                 WIDTH [channel,] line_width                                  ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

77FA BP_WIDTH      JSR      L078CA(PC)             ;get channel number and following parame
                   BNE.S    L0780A                 ;exit if any errors
                   SUBQ.W   #1,D3                  ;one extra parameter found ?
                   BNE.S    L0780C                 ;exit with error if not

   Copy the width parameter to the appropriate entry in the Superbasic channel
   table.

                   MOVE.W   TOS(A6,A1.L),CH.WIDTH(A6,A2.L)
780A L0780A        RTS

780C L0780C        MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
780E L0780E        RTS

Ú------------------------------------------------------------------------------¿
³=BP_WINDO        REDEFINE CHANNEL'S WINDOW                                    ³
------------------------------------------------------------------------------
³SYNTAX:          width := numeric_expression                                  ³
³                 depth := numeric_expression                                  ³
³                 x := numeric_expression                                      ³
³                 y := numeric_expression                                      ³
³                                                                              ³
³                 WINDOW [channel,] width, depth, x, y                         ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

7810 BP_WINDO      JSR      L078CA(PC)
                   BNE.S    L07834
                   MOVEQ    #SD.WDEF,D4            ;TRAP to re-define window
                   MOVEQ    #$80,D1                ;use a transparent border
                   CLR.W    D2                     ;and zero border width
                   BRA.S    L0782E

Ú------------------------------------------------------------------------------¿
³=BP_BLOCK        FILL A BLOCK WITH COLOUR                                     ³
------------------------------------------------------------------------------
³SYNTAX:          width := numeric_expression                                  ³
³                 depth := numeric_expression                                  ³
³                 x := numeric_expression                                      ³
³                 y := numeric_expression                                      ³
³                 colour := numeric_expression {0 .. 7}                        ³
³                                                                              ³
³                 BLOCK [channel,] width, depth, x, y, colour                  ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

781E BP_BLOCK      JSR      L078CA(PC)
                   BNE.S    L07834
                   MOVEQ    #SD.FILL,D4            ;TRAP to fill a block
                   SUBQ.W   #4,D3
                   JSR      L07866(PC)
                   BNE.S    L07834
782E L0782E        SUBQ.W   #6,A1                  ;retore maths stack pointer
                   JMP      L07856(PC)             ;do the TRAP

7834 L07834        RTS

Ú------------------------------------------------------------------------------¿
³=BP_BORDE        ADD A BORDER TO A WINDOW                                     ³
------------------------------------------------------------------------------
³SYNTAX:          width := numeric_expression                                  ³
³                 colour := numeric_expression {0 .. 7}                        ³
³                                                                              ³
³                 BORDER [channel,] width [, colour]                           ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

7836 BP_BORDE      JSR      L078CA(PC)
                   BNE.S    L07834
                   MOVEQ    #SD.BORDR,D4           ;TRAP to set window border
                   MOVEQ    #$80,D1                ;use a transparent border
                   CMPI.W   #1,D3
                   BLS.S    L0784E
                   SUBQ.W   #1,D3
                   JSR      L07866(PC)
                   BNE.S    L07834
784E L0784E        MOVE.W   TOS(A6,A1.L),D2
                   JMP      L07856(PC)

7856 L07856        MOVE.L   D4,D0
7858 L07858        MOVEQ    #-1,D3                 ;use an infinite timeout
                   MOVE.L   A1,-(A7)
                   TRAP     #4                     ;use absolute values
                   TRAP     #3                     ;do the TRAP
                   MOVEA.L  (A7)+,A1
                   TST.L    D0                     ;set flags for interpreter
                   RTS

7866 L07866        MOVE.W   TOS(A6,A1.L),D1
786A L0786A        SUBQ.L   #2,A1
                   SUBQ.W   #1,D3
                   BEQ.S    L078AC
                   CMPI.W   #7,D1
                   BHI.S    L078B6
                   ORI.W    #$18,D1
                   CMPI.W   #1,D3
                   BEQ.S    L07896
                   ANDI.W   #7,D1
                   MOVE.W   TOS(A6,A1.L),D2
                   SUBQ.L   #2,A1
                   SUBQ.W   #1,D3
                   LSL.W    #3,D1
                   CMPI.W   #7,D2
                   BHI.S    L078B6
                   OR.W     D2,D1
7896 L07896        MOVE.W   TOS(A6,A1.L),D2
                   SUBQ.L   #2,A1
                   SUBQ.W   #1,D3
                   BNE.S    L078B6
                   CMPI.W   #7,D2
                   BHI.S    L078B6
                   EOR.W    D2,D1
                   LSL.W    #3,D1
                   OR.W     D2,D1
78AC L078AC        CMPI.W   #$FF,D1
                   BHI.S    L078B6
78B2 L078B2        MOVEQ    #0,D0                  ;signal "no errors"
                   RTS

78B6 L078B6        MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
78B8 L078B8        RTS

78BA L078BA        CMPI.W   #1,D3
                   BNE.S    L078B6
                   MOVE.W   TOS(A6,A1.L),D1
                   CMP.W    D3,D1
                   BHI.S    L078B6
                   BRA.S    L078B2

78CA L078CA        JSR      L06040(PC)
78CE L078CE        BNE.S    L078E4
78D0 L078D0        JSR      CA_GTINT(PC)           ;get integers,D3 = number found
                   BNE.S    L078E4
                   ADD.L    D3,D3
                   ADD.L    D3,BV.RIP(A6)
                   ADDA.L   D3,A1
                   SUBQ.L   #2,A1
                   LSR.W    #1,D3
                   MOVEQ    #0,D0
78E4 L078E4        RTS

2.23 SuperBASIC functions.

Ú------------------------------------------------------------------------------¿
³=BF_ACOS         RETURN ARC COSINE                                            ³
³=BF_ACOT         RETURN ARC COTANGENT                                         ³
³=BF_ASIN         RETURN ARC SINE                                              ³
³=BF_ATAN         RETURN ARC TANGENT                                           ³
³=BF_COS          RETURN COSINE                                                ³
³=BF_COT          RETURN COTANGENT                                             ³
³=BF_EXP          RETURN EXPONENTIAL                                           ³
³=BF_LN           RETURN NATURAL LOGARITHM                                     ³
³=BF_LOG10        RETURN LOGARITHM TO BASE 10                                  ³
³=BF_SIN          RETURN SINE                                                  ³
³=BF_SQRT         RETURN SQUARE ROOT                                           ³
³=BF_TAN          RETURN TANGENT                                               ³
³=BF_DEG          RETURN ANGLE IN DEGREES                                      ³
------------------------------------------------------------------------------
³SYNTAX:          angle := numeric_expression {in radians}                     ³
³                                                                              ³
³                 ACOS (angle)    ..etc                                        ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

78E6 BF_ACOS       LEA      RI_ACOS(PC),A4
                   BRA.S    L07958

78EC BF_ACOT       LEA      RI_ACOT(PC),A4
                   BRA.S    L07958

78F2 BF_ASIN       LEA      RI_ASIN(PC),A4
                   BRA.S    L07958

78F8 BF_ATAN       LEA      RI_ATAN(PC),A4
                   BRA.S    L07958

78FE BF_COS        LEA      RI_COS(PC),A4
                   BRA.S    L07958

7904 BF_COT        LEA      RI_COT(PC),A4
                   BRA.S    L07958

790A BF_EXP        LEA      RI_EXP(PC),A4
                   BRA.S    L07958

7910 BF_LN         LEA      RI_LN(PC),A4
                   BRA.S    L07958

7916 BF_LOG10      LEA      RI_LOG10(PC),A4
                   BRA.S    L07958

791C BF_SIN        LEA      RI_SIN(PC),A4
                   BRA.S    L07958

7922 BF_SQRT       LEA      RI_SQRT(PC),A4
                   BRA.S    L07958

7928 BF_TAN        LEA      RI_TAN(PC),A4
                   BRA.S    L07958

792E BF_DEG        LEA      RI_DIV(PC),A4
                   BRA.S    L07938

Ú------------------------------------------------------------------------------¿
³=BF_RAD          RETURN ANGLE IN RADIANS                                      ³
------------------------------------------------------------------------------
³SYNTAX:          angle := numeric_expression {in degrees}                     ³
³                                                                              ³
³                 RAD (angle)                                                  ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

7934 BF_RAD        LEA      RI_MULT(PC),A4
7938 L07938        JSR      L05C30(PC)
                   BNE.S    L07970
                   BSR      L079EE
                   SUBQ.W   #6,A1
                   MOVE.W   #$7FB,TOS(A6,A1.L)
                   MOVE.L   #$477D1A89,2(A6,A1.L)
                   BRA.S    L07968

Ú------------------------------------------------------------------------------¿
³=BF_ABS          RETURN ABSOLUTE VALUE OF NUMBER                              ³
------------------------------------------------------------------------------
³SYNTAX:          number := numeric_expression                                 ³
³                                                                              ³
³                 ABS (number)                                                 ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

7954 BF_ABS        LEA      RI_ABS(PC),A4
7958 L07958        JSR      L05C30(PC)
                   BNE.S    L07970
                   MOVEQ    #$30,D1
                   JSR      BV_CHRIX(PC)
                   MOVEA.L  BV.RIP(A6),A1
7968 L07968        JSR      (A4)
796A L0796A        MOVEQ    #2,D4
796C L0796C        MOVE.L   A1,BV.RIP(A6)
7970 L07970        RTS

7972 L07972        MOVEQ    #3,D4
7974 L07974        MOVEQ    #0,D0                  ;signal "no errors"
                   BRA.S    L0796C

7978 L07978        ADDQ.W   #4,A7
                   RTS

Ú------------------------------------------------------------------------------¿
³=BF_RND          RETURN RANDOM NUMBER WITHIN LIMITS                           ³
------------------------------------------------------------------------------
³SYNTAX:          lower_limit := numeric_expression                            ³
³                 upper_limit := numeric_expression                            ³
³                                                                              ³
³                 RND ([lower_limit] [ TO upper_limit])                        ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

797C BF_RND        MOVEQ    #1,D5
                   OR.L     BV.RAND(A6),D5
                   MOVE.L   D5,D6
                   MULU     #$163,D5
                   SWAP     D6
                   MULU     #$163,D6
                   SWAP     D6
                   CLR.W    D6
                   ADD.L    D6,D5
                   MOVE.L   D5,BV.RAND(A6)
                   JSR      CA_GTINT(PC)           ;get integers,D3 = number found
                   BNE.S    L07970
                   SUBQ.W   #1,D3
                   BEQ.S    L079BA
                   BGT.S    L079B4
                   BSR.S    L079EE
                   MOVE.L   D5,D1
                   LSR.L    #1,D1
                   MOVE.W   #$800,D0
79AE L079AE        JSR      L048CC(PC)
                   BRA.S    L0796A

79B4 L079B4        MOVE.W   TOS(A6,A1.L),D3
79B8 L079B8        ADDQ.W   #2,A1
79BA L079BA        MOVE.W   TOS(A6,A1.L),D2
                   SUB.W    D3,D2
                   BLT.S    L07A28
                   ADDQ.W   #1,D2
                   SWAP     D5
                   MULU     D2,D5
                   SWAP     D5
                   ADD.W    D3,D5
79CC L079CC        MOVE.W   D5,TOS(A6,A1.L)
                   BRA.S    L07972

Ú------------------------------------------------------------------------------¿
³=BF_PI           RETURN THE VALUE 3.141593                                    ³
------------------------------------------------------------------------------
³SYNTAX:          PI                                                           ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

79D2 BF_PI         BSR.S    L079EE
                   MOVE.W   #$0802,D0
                   MOVE.L   #$6487ED51,D1
                   BRA.S    L079AE

Ú------------------------------------------------------------------------------¿
³=BF_INT          RETURN INTEGER PART OF NUMBER                                ³
------------------------------------------------------------------------------
³SYNTAX:          number := numeric_expression                                 ³
³                                                                              ³
³                 INT (number)                                                 ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

79E0 BF_INT        JSR      L05C2C(PC)
                   BNE.S    L07970
                   MOVE.L   TOS(A6,A1.L),D1
                   ADDQ.W   #4,A1
                   BRA.S    L07A12

79EE L079EE        JSR      CA_RERIS(PC)
79F2 L079F2        MOVEA.L  BV.RIP(A6),A1
                   RTS

Ú------------------------------------------------------------------------------¿
³=BF_PEEK         RETURN VALUE OF BYTE IN MEMORY                               ³
³=BF_PEEKW        RETURN SIGNED VALUE OF WORD IN MEMORY                        ³
³=BF_PEEKL        RETURN SIGNED VALUE OF LONG WORD IN MEMORY                   ³
------------------------------------------------------------------------------
³SYNTAX:          address := numeric_expression                                ³
³                                                                              ³
³                 PEEK (address)                                               ³
³                 PEEK_W (address)                                             ³
³                 PEEK_L (address)                                             ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

79F8 BF_PEEK       BSR.S    L07A18
                   MOVEQ    #0,D5
                   MOVE.B   (A4),D5
                   BRA.S    L07A06

7A00 BF_PEEKW      BSR.S    L07A18
                   BCS.S    L07A28
                   MOVE.W   (A4),D5
7A06 L07A06        ADDQ.W   #2,A1
                   BRA.S    L079CC

7A0A BF_PEEKL      BSR.S    L07A18
                   BCS.S    L07A28
                   MOVE.L   (A4),D1
7A10 L07A10        ADDQ.W   #4,A1
7A12 L07A12        MOVE.W   #$081F,D0
                   BRA.S    L079AE

7A18 L07A18        JSR      L05C2C(PC)
7A1C L07A1C        BNE.S    L07A90
                   MOVEA.L  TOS(A6,A1.L),A4
                   MOVE.L   A4,D1
                   ROR.W    #1,D1
                   RTS

7A28 L07A28        MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
7A2A L07A2A        RTS

Ú------------------------------------------------------------------------------¿
³=BF_RESPR        RESERVE RESIDENT PROCEDURE SPACE                             ³
------------------------------------------------------------------------------
³SYNTAX:          space := numeric_expression                                  ³
³                                                                              ³
³                 RESPR (space)                                                ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:          ERR.NC   not complete as TRNSP not empty                     ³
³                 ERR.OM   out of memory                                       ³
À------------------------------------------------------------------------------Ù

   This function reserves space in the resident procedure area which lies
   at the top of physical RAM. The amount specified is always rouned to the
   nearest multiple of 8 bytes and a value of zero returns the address of
   the bottom of the area.

7A2C BF_RESPR      BSR.S    L07A18                 ;check for one parameter in brackets
                   MOVEQ    #MT.ALRES,D0           ;TRAP to allocate RESPR space
                   MOVE.L   TOS(A6,A1.L),D1        ;get the amount required
                   MOVEA.L  A1,A4                  ;and save the maths stack pointer
                   TRAP     #1                     ;allocate the space,A0 points at area on
                   MOVE.L   A0,D1                  ;save the start address
                   MOVEA.L  A4,A1                  ;and restore the maths stack pointer
                   TST.L    D0                     ;any errors ?
                   BEQ.S    L07A10                 ;jump forward if not
                   BRA.S    L07A2A                 ;otherwise clean up the stack

Ú------------------------------------------------------------------------------¿
³=BF_BEEPI        RETURN SOUND STATUS                                          ³
------------------------------------------------------------------------------
³SYNTAX:          BEEPING                                                      ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

7A42 BF_BEEPI      BSR.S    L079EE
                   MOVEQ    #1,D1
                   AND.B    SV_SOUND,D1
                   BRA.S    L07A12

Ú------------------------------------------------------------------------------¿
³=BF_EOF          RETURN FILE OR DATA STATEMENT STATUS                         ³
------------------------------------------------------------------------------
³SYNTAX:          EOF [(channel)]                                              ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

7A4E BF_EOF        CMPA.L   A3,A5
                   BNE.S    L07A5C
                   JSR      L06154(PC)
                   SUBQ.B   #1,BV.DAITM(A6)
                   BRA.S    L07A64

7A5C L07A5C        BSR.S    L07ACE
7A5E L07A5E        MOVEQ    #0,D0
                   MOVEQ    #0,D3
                   TRAP     #3
7A64 L07A64        MOVEQ    #-10,D4
                   SUB.L    D0,D4
                   BSR.S    L079EE
                   MOVEQ    #0,D1
                   TST.L    D4
                   BNE.S    L07A12
                   MOVEQ    #1,D1
                   BRA.S    L07A12

Ú------------------------------------------------------------------------------¿
³=BV_VER          RETURN SUPERBASIC VERSION NUMBER                             ³
------------------------------------------------------------------------------
³SYNTAX:          VER$                                                         ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

7A74 BF_VER        BSR      L079EE
                   SUBQ.W   #4,A1
                   MOVE.L   #$024A4D,TOS(A6,A1.L)
                   BRA.S    L07AC6

Ú------------------------------------------------------------------------------¿
³=BV_INKEY        RETURN CHARACTER FROM CHANNEL                                ³
------------------------------------------------------------------------------
³SYNTAX:          time := numeric_expression                                   ³
³                                                                              ³
³                 INKEY$  [|(channel)                                          ³
³                          |(channel, time)                                    ³
³                          |(time)]                                            ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

7A84 BF_INKEY      BSR.S    L07ACE
                   MOVE.L   A0,-(A7)
                   BSR      L079EE
                   JSR      CA_GTINT(PC)           ;get integers,D3 = number found
7A90 L07A90        BNE.S    L07AD6
                   MOVEA.L  (A7)+,A0
                   CMPI.W   #1,D3
                   BGT.S    L07A28
                   BLT.S    L07AA2
                   MOVE.W   TOS(A6,A1.L),D3
                   ADDQ.W   #2,A1
7AA2 L07AA2        MOVEA.L  A1,A4
                   MOVEQ    #1,D0
                   TRAP     #3
                   MOVEA.L  A4,A1
                   ADDQ.L   #1,D0
                   BEQ.S    L07AC0
                   SUBQ.L   #1,D0
                   BNE.S    L07AD8
                   SUBQ.W   #4,A1
7AB4 L07AB4        MOVE.B   D1,2(A6,A1.L)
                   MOVE.W   #1,TOS(A6,A1.L)
                   BRA.S    L07AC6

7AC0 L07AC0        SUBQ.W   #2,A1
7AC2 L07AC2        CLR.W    TOS(A6,A1.L)
7AC6 L07AC6        MOVEQ    #1,D4
                   MOVEQ    #0,D0
                   BRA      L0796C

7ACE L07ACE        MOVEQ    #0,D1
7AD0 L07AD0        JSR      L06042(PC)
                   BEQ.S    L07AD8
7AD6 L07AD6        ADDQ.W   #4,A7
7AD8 L07AD8        RTS

Ú------------------------------------------------------------------------------¿
³=BF_CHR          RETURN ASCII CHARACTER                                       ³
------------------------------------------------------------------------------
³SYNTAX:          character_code := numeric_expression                         ³
³                                                                              ³
³                 CHR$ (character_code)                                        ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

7ADA BF_CHR        BSR      L079EE
                   JSR      L05C28(PC)
                   BNE.S    L07AD8
                   MOVE.W   TOS(A6,A1.L),D1
                   SUBQ.W   #2,A1
                   BRA.S    L07AB4

Ú------------------------------------------------------------------------------¿
³=BF_FILL         RETURN FILLED STRING                                         ³
------------------------------------------------------------------------------
³SYNTAX:          repeat_string := string_expression                           ³
³                 length := numeric_expression                                 ³
³                                                                              ³
³                 FILL$ (repeat_string, length)                                ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

7AEC BF_FILL       SUBQ.W   #8,A5
                   BSR.S    L07B42
                   BEQ      L07A28
                   SUBQ.L   #1,D1
                   BGT.S    L07AFE
                   MOVE.B   2(A6,A1.L),3(A6,A1.L)
7AFE L07AFE        MOVE.W   2(A6,A1.L),D5
                   ADDQ.L   #4,D1
                   BCLR     #0,D1
                   ADDA.L   D1,A1
                   MOVE.L   A1,BV.RIP(A6)
                   MOVEA.L  A5,A3
                   ADDQ.W   #8,A5
                   JSR      L05C28(PC)
                   BNE.S    L07AD8
                   ADDQ.L   #2,BV.RIP(A6)
                   MOVEQ    #0,D4
                   MOVE.W   TOS(A6,A1.L),D4
                   BLT      L07A28
                   BEQ.S    L07AC6
                   MOVE.L   D4,D1
                   BSR.S    L07B66
7B2C L07B2C        SUBQ.W   #2,A1
                   MOVE.W   D5,TOS(A6,A1.L)
                   SUBQ.L   #2,D1
                   BGT.S    L07B2C
                   MOVE.W   D4,TOS(A6,A1.L)
                   BRA.S    L07AC6

Ú------------------------------------------------------------------------------¿
³=BF_LEN          RETURN LENGTH OF STRING                                      ³
------------------------------------------------------------------------------
³SYNTAX:          string := string_expression                                  ³
³                                                                              ³
³                 LEN (string)                                                 ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

7B3C BF_LEN        BSR.S    L07B42
                   MOVE.W   D1,D5
                   BRA.S    L07B5A

7B42 L07B42        JSR      L05C34(PC)
7B46 L07B46        BNE.S    L07AD6
                   MOVEQ    #0,D5
                   MOVEQ    #0,D1
                   MOVE.W   TOS(A6,A1.L),D1
                   RTS

Ú------------------------------------------------------------------------------¿
³=BF_CODE         RETURN ASCII VALUE OF CHARACTER                              ³
------------------------------------------------------------------------------
³SYNTAX:          character := string_expression                               ³
³                                                                              ³
³                 CODE (character)                                             ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

7B52 BF_CODE       BSR.S    L07B42
                   BEQ.S    L07B62
                   MOVE.B   2(A6,A1.L),D5
7B5A L07B5A        ADDQ.L   #1,D1
                   BCLR     #0,D1
                   ADDA.L   D1,A1
7B62 L07B62        BRA      L079CC

7B66 L07B66        ADDQ.L   #3,D1
7B68 L07B68        BCLR     #0,D1
                   MOVE.L   D1,-(A7)
                   JSR      BV_CHRIX(PC)
                   MOVEA.L  BV.RIP(A6),A1
                   MOVE.L   (A7)+,D1
7B78 L07B78        RTS

Ú------------------------------------------------------------------------------¿
³=BF_DIMN         RETURN MAXIMUM SIZE OF DIMENSION                             ³
------------------------------------------------------------------------------
³SYNTAX:          array := identifier                                          ³
³                 index := numeric_expression                                  ³
³                                                                              ³
³                 DIMN (array [,index])                                        ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

7B7A BF_DIMN       MOVE.B   0(A6,A3.L),D1
                   SUBQ.B   #3,D1
                   BNE.S    L07BC2
                   MOVE.L   A3,-(A7)
                   ADDQ.W   #8,A3
                   JSR      CA_GTINT(PC)           ;get integers,D3 = number found
                   MOVEA.L  (A7)+,A3
                   BNE.S    L07B78
                   SUBQ.W   #1,D3
                   BGT.S    L07B78
                   BEQ.S    L07B9C
                   BSR.S    L07BD8
                   SUBQ.W   #2,A1
                   MOVEQ    #1,D1
                   BRA.S    L07BA2

7B9C L07B9C        MOVE.W   TOS(A6,A1.L),D1
7BA0 L07BA0        BLE.S    L07BC6
7BA2 L07BA2        MOVEA.L  4(A6,A3.L),A2
                   ADDA.L   BV.VVBAS(A6),A2
                   MOVE.W   4(A6,A2.L),D2
                   SUB.W    D1,D2
                   BLT.S    L07BC6
                   ADDQ.W   #2,A2
                   LSL.W    #2,D1
                   ADDA.W   D1,A2
                   MOVE.W   0(A6,A2.L),TOS(A6,A1.L)
                   BRA      L07972

7BC2 L07BC2        BSR.S    L07BD8
7BC4 L07BC4        SUBQ.W   #2,A1
7BC6 L07BC6        MOVEQ    #0,D5
                   BRA.S    L07B62

Ú------------------------------------------------------------------------------¿
³=BF_DATE         RETURN CURRENT DATE IN SECONDS                               ³
------------------------------------------------------------------------------
³SYNTAX:          DATE                                                         ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

7BCA BF_DATE       BSR.S    L07BD8
                   MOVEQ    #19,D0
                   TRAP     #1
                   BCLR     #$1F,D1
                   BRA      L07A12

7BD8 L07BD8        BRA      L079EE

Ú------------------------------------------------------------------------------¿
³=BF_KEYRW        RETURN STATE OF ROW OF KEYBOARD                              ³
------------------------------------------------------------------------------
³SYNTAX:          row := numeric_expression {0 .. 7}                           ³
³                                                                              ³
³                 KEYROW (row)                                                 ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

7BDC BF_KEYRW      JSR      L05C28(PC)
                   SUBQ.W   #8,A7
                   BNE.S    L07C1E
                   MOVEA.L  A7,A3
                   MOVE.B   #9,(A3)
                   MOVE.B   #1,1(A3)
                   MOVE.L   #0,2(A3)
                   MOVE.B   1(A6,A1.L),6(A3)
                   MOVE.B   #2,7(A3)
                   MOVE.L   A1,-(A7)
                   MOVEQ    #17,D0
                   TRAP     #1
                   MOVEA.L  (A7)+,A1
                   MOVE.W   D1,TOS(A6,A1.L)
                   MOVEQ    #3,D4
                   MOVEA.L  SV_KEYQ,A2
                   MOVE.L   12(A2),8(A2)
7C1E L07C1E        ADDQ.W   #8,A7
                   RTS

Ú------------------------------------------------------------------------------¿
³=BF_DATES        RETURN CURRENT DATE and TIME                                 ³
³=BF_DAY          RETURN CURRENT DAY OF THE WEEK                               ³
------------------------------------------------------------------------------
³SYNTAX:          number := numeric_expression                                 ³
³                                                                              ³
³                 DATE$ [(number)]                                             ³
³                 DAY$ [(number)]                                              ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     top of arithmetic stack                             ³
³                 A3.L     first parameter in name table (relative)            ³
³                 A5.L     last parameter in name table (relative)             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

7C22 BF_DATES      LEA      CN_DATE(PC),A4         ;get date string routine
                   BRA.S    L07C2C

7C28 BF_DAY        LEA      CN_DAY(PC),A4          ;get day string routine
7C2C L07C2C        JSR      CA_RERIS(PC)
                   CMPA.L   A3,A5
                   BLE.S    L07C42
                   JSR      L05C2C(PC)
                   BNE.S    L07C54
                   MOVE.L   TOS(A6,A1.L),D1
                   ADDQ.L   #4,A1
                   BRA.S    L07C4A

7C42 L07C42        MOVEQ    #19,D0
7C44 L07C44        TRAP     #1
                   MOVEA.L  BV.RIP(A6),A1
7C4A L07C4A        JSR      (A4)
                   MOVEQ    #1,D4
                   MOVE.L   A1,BV.RIP(A6)
                   MOVEQ    #0,D0                  ;signal "no errors"
                   RTS

;part 50
2.24 Interpreter

Ú------------------------------------------------------------------------------¿
³=                                                                             ³
------------------------------------------------------------------------------
³JOB:                                                                          ³
------------------------------------------------------------------------------
³SYNTAX:                                                                       ³
------------------------------------------------------------------------------
³ENTRY:           D7.L     relative pointer to end of buffer + 1               ³
³                 A0.L     relative pointer to buffer containing argument      ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:          ERR.EX   error in expression                                 ³
À------------------------------------------------------------------------------Ù

7C56 L07C56        JSR      CA_RERIS(PC)           ;reserve 32 bytes on maths stack
                   MOVEA.L  BV.RIP(A6),A1          ;point A1 at the top of the maths stack
                   JSR      CN_DTOI(PC)            ;convert the ASCII argument to an intege
                   BNE.S    L07C86                 ;and exit if any errors in expression
                   TST.W    TOS(A6,A1.L)           ;valid argument ?
                   BLE.S    L07C86                 ;exit if argument was negative or zero

   A positive argument has been given so deal with the stack

                   TST.B    BV.UNRVL(A6)           ;unravel stack ?
                   BEQ.S    L07C78                 ;jump forward if there is number need to
7C70 L07C70        ADDA.W   #12,A7                 ;otherwise unravel by reseting it
                   MOVEQ    #1,D0
                   RTS

7C78 L07C78        MOVEQ    #4,D1
                   MOVEQ    #-$73,D4
                   MOVE.W   TOS(A6,A1.L),D5        ;set D5 to the argument
                   JSR      L085F6(PC)
                   ADDQ.L   #2,(A7)                ;take the second of the two return branc
7C86 L07C86        RTS

7C88 L07C88        DC.B     4,5,7,9,12,1,$2D,1,$2B,2,$7E,$7E,19,$4E,$4F,$54

7C98 L07C98        LEA      L07C88(PC),A2
                   JSR      L07F2A(PC)
                   BRA.S    L07CAA
                   MOVEQ    #-$7A,D4
                   JSR      L085E6(PC)
                   ADDQ.L   #2,(A7)
7CAA L07CAA        RTS

                   MOVEQ    #1,D3
                   BRA.S    L07CB2
                   MOVEQ    #0,D3
7CB2 L07CB2        MOVEA.L  A0,A3
                   JSR      L07EE8(PC)
                   BRA.S    L07CDA
                   MOVE.L   A0,D5
                   SUB.L    A3,D5
                   CMPI.W   #$FF,D5
                   BGT.S    L07CDA
                   MOVE.L   A0,-(A7)
                   JSR      L07E06(PC)
                   BRA.S    L07CD8
                   MOVEA.L  (A7)+,A0
                   MOVEQ    #-$78,D4
                   JSR      L085F6(PC)
                   ADDQ.L   #2,(A7)
                   RTS

7CD8 L07CD8        MOVEA.L  (A7)+,A0
7CDA L07CDA        RTS

   Operator table number 1

7CDC L07CDC        DC.B     $16,$17,$19,$1B        ;offsets to the corresponding entries in
                   DC.B     $1D,$1F,$22,$24        ;following table
                   DC.B     $27,$29,$2C,$2F
                   DC.B     $31,$34,$37,$3A
                   DC.B     $3C,$3E,$41,$45
                   DC.B     $49,$4D,$51

7CF3 L07CF3        DC.B     1,'+'
                   DC.B     1,'-'
                   DC.B     1,'*'
                   DC.B     1,'/'
                   DC.B     2,'>='
                   DC.B     1,'>'
                   DC.B     2,'=='
                   DC.B     1,'='
                   DC.B     2,'<>'
                   DC.B     2,'<='
                   DC.B     1,'<'
                   DC.B     2,'||'
                   DC.B     2,'&&'
                   DC.B     2,'^^'
                   DC.B     1,'^'
                   DC.B     1,'&'

   Logical Operators

7D1A L07D1A        DC.B     $12,'OR'
                   DC.B     $13,'AND'
                   DC.B     $13,'XOR'
                   DC.B     $13,'MOD'
                   DC.B     $13,'DIV'
                   DC.B     $15,'INSTR'
                   DC.B     0

7D34 L07D34        LEA      L07CDC(PC),A2          ;point at operator table number one
                   JSR      L07F2A(PC)
                   BRA.S    L07D46
                   MOVEQ    #-$7B,D4
                   JSR      L085E6(PC)
                   ADDQ.L   #2,(A7)
7D46 L07D46        RTS

   DATA FORM HERE

7D48 L07D48        BTST     D2,D6
                   BTST     #14,??
                   BTST     D0,$013B(A4)
                   BCHG     D0,(A4)+
                   BTST     D0,-(A1)
                   MOVE.B   (A4),??
                   DC.W     $4F00

   TO HERE

                   LEA      L07D48(PC),A2
                   JSR      L07F2A(PC)
                   BRA.S    L07D6C
                   MOVEQ    #-$72,D4
                   JSR      L085E6(PC)
                   ADDQ.L   #2,(A7)
7D6C L07D6C        RTS

7D6E L07D6E        MOVEQ    #0,D1
                   MOVEQ    #0,D5
7D72 L07D72        ADDQ.W   #1,D5
                   MOVE.B   0(A6,A0.L),D1
                   ADDQ.W   #1,A0
                   CMPI.B   #$20,D1
                   BEQ.S    L07D72
                   SUBQ.W   #1,A0
                   SUBQ.W   #1,D5
                   BEQ.S    L07D8C
                   MOVEQ    #-$80,D4
                   JSR      L085E6(PC)
7D8C L07D8C        RTS

                   MOVE.B   0(A6,A0.L),D2
                   CMPI.B   #$22,D2
                   BEQ.S    L07D9E
                   CMPI.B   #$27,D2
                   BNE.S    L07DC0
7D9E L07D9E        LEA      1(A0),A2
                   MOVEQ    #-1,D5
                   MOVEQ    #10,D3
7DA6 L07DA6        ADDQ.W   #1,A0
                   ADDQ.W   #1,D5
                   MOVE.B   0(A6,A0.L),D1
                   CMP.B    D3,D1
                   BEQ.S    L07DC0
                   CMP.B    D2,D1
                   BNE.S    L07DA6
                   ADDQ.W   #1,A0
                   MOVEQ    #-$75,D4
                   JSR      L08624(PC)
                   ADDQ.L   #2,(A7)
7DC0 L07DC0        RTS

7DC2 L07DC2        RTS

7DC4 L07DC4        JSR      L07F0E(PC)
                   BNE.S    L07DD6
                   MOVEA.L  BV.TKP(A6),A3
                   CMPI.B   #$80,-2(A6,A3.L)
                   BNE.S    L07DEE
7DD6 L07DD6        MOVEA.L  A0,A2
                   MOVE.L   BV.BFP(A6),D5          ;get buffer running pointer
                   SUBQ.L   #1,D5
                   MOVEA.L  D5,A0
                   SUB.L    A2,D5
                   BEQ.S    L07DEC
                   MOVEQ    #-$74,D4
                   MOVEQ    #0,D2
                   JSR      L08624(PC)
7DEC L07DEC        ADDQ.L   #2,(A7)
7DEE L07DEE        RTS

                   JSR      $4F46(PC)
                   MOVEA.L  BV.RIP(A6),A1          ;point A1 at the top of the maths stack
                   JSR      $3D84(PC)
                   BNE.S    L07E04
                   JSR      L085FE(PC)
                   ADDQ.L   #2,(A7)
7E04 L07E04        RTS

7E06 L07E06        MOVE.L   A2,-(A7)
                   MOVE.B   D5,D2
                   MOVE.B   D2,D1
                   MOVEQ    #5,D3
                   MOVEA.L  BV.NTBAS(A6),A2
                   MOVEA.L  A3,A1
7E14 L07E14        CMPA.L   BV.NTP(A6),A2
                   BGE.S    L07E68
                   TST.L    0(A6,A2.L)
                   BEQ.S    L07E30
                   MOVEA.L  BV.NLBAS(A6),A4
                   ADDA.W   2(A6,A2.L),A4
                   MOVE.B   0(A6,A4.L),D5
                   CMP.B    D2,D5
                   BEQ.S    L07E34
7E30 L07E30        ADDQ.W   #8,A2
                   BRA.S    L07E14
7E34 L07E34        TST.B    D2
                   BEQ.S    L07E56
                   MOVE.B   0(A6,A3.L),D4
                   ADDQ.W   #1,A3
                   BCLR     D3,D4
                   TST.B    D5
                   BEQ.S    L07E60
                   ADDQ.W   #1,A4
                   MOVE.B   0(A6,A4.L),D6
                   BCLR     D3,D6
                   CMP.B    D4,D6
                   BNE.S    L07E60
                   SUBQ.B   #1,D2
                   SUBQ.B   #1,D5
                   BRA.S    L07E34
7E56 L07E56        TST.B    D5
                   BNE.S    L07E60
                   MOVE.L   A2,D5
                   ADDQ.W   #4,A7
                   BRA.S    L07EDE
7E60 L07E60        MOVEA.L  A1,A3
                   MOVE.B   D1,D2
                   ADDQ.W   #8,A2
                   BRA.S    L07E14
7E68 L07E68        MOVEQ    #0,D6
                   MOVEA.L  A3,A0
                   MOVEA.L  (A7)+,A2
                   JSR      L08148(PC)
                   BRA.S    L07E76
                   BRA.S    L07EE6

7E76 L07E76        TST.B    BV.UNRVL(A6)
                   BEQ.S    L07E82
                   ADDQ.W   #8,A7
                   JMP      L07C70(PC)

7E82 L07E82        MOVEQ    #0,D4
                   MOVE.B   D2,D4
                   JSR      $4EE2(PC)
                   MOVE.L   D4,D2
                   MOVE.L   #-1,4(A6,A2.L)
                   MOVEA.L  BV.NLP(A6),A4
                   MOVE.L   A4,D3
                   SUB.L    BV.NLBAS(A6),D3
                   MOVE.W   D3,2(A6,A2.L)
                   ADD.L    A3,D2
                   MOVE.B   -1(A6,D2.L),D3
                   MOVEQ    #0,D1
                   SUBI.B   #$25,D3
                   BLT.S    L07EB6
                   BGT.S    L07EB4
                   ADDQ.W   #1,D1
7EB4 L07EB4        ADDQ.W   #1,D1
7EB6 L07EB6        ADDQ.W   #1,D1
                   MOVE.W   D1,0(A6,A2.L)
                   MOVE.L   A2,D5
                   MOVEQ    #1,D1
                   ADD.W    D4,D1
                   JSR      $4F6C(PC)
                   MOVE.B   D4,0(A6,A4.L)
7ECA L07ECA        ADDQ.W   #1,A4
                   MOVE.B   0(A6,A3.L),0(A6,A4.L)
                   ADDQ.W   #1,A3
                   SUBQ.B   #1,D4
                   BNE.S    L07ECA
                   ADDQ.W   #1,A4
                   MOVE.L   A4,BV.NLP(A6)
7EDE L07EDE        SUB.L    BV.NTBAS(A6),D5
                   LSR.L    #3,D5
                   ADDQ.L   #2,(A7)
7EE6 L07EE6        RTS

7EE8 L07EE8        BSR.S    L07F0E
                   BNE.S    L07F0C
                   CMPI.B   #1,D2
                   BNE.S    L07F0C
7EF2 L07EF2        ADDQ.W   #1,A0
                   BSR.S    L07F0E
                   BEQ.S    L07EF2
                   CMPI.B   #$24,D2
                   BEQ.S    L07F04
                   CMPI.B   #$25,D2
                   BNE.S    L07F0A
7F04 L07F04        TST.B    D3
                   BNE.S    L07F0C
                   ADDQ.W   #1,A0
7F0A L07F0A        ADDQ.L   #2,(A7)
7F0C L07F0C        RTS

7F0E L07F0E        MOVEQ    #0,D1
                   MOVE.B   0(A6,A0.L),D1
                   BLT.S    L07F28
                   LEA      $3C96(PC),A1
                   MOVE.B   0(A1,D1.W),D2
                   CMPI.B   #1,D2
                   BEQ.S    L07F28
                   CMPI.B   #2,D2
7F28 L07F28        RTS

   A2 points at operator table on entry.

7F2A L07F2A        MOVE.L   A0,-(A7)               ;save A0
                   MOVEQ    #0,D5                  ;and clear D5
7F2E L07F2E        MOVEA.L  (A7),A0
                   BSR.S    L07F76
7F32 L07F32        ADDQ.W   #1,D5
                   MOVEA.L  A2,A1                  ;point A1 at table
                   CMP.B    (A1),D5
                   BGT.S    L07F72
                   MOVEQ    #0,D1
                   MOVE.B   0(A1,D5.W),D1
                   ADDA.W   D1,A1
                   MOVE.B   (A1)+,D1
                   CMP.B    (A1)+,D0
                   BNE.S    L07F32
                   MOVE.B   D1,D0
                   SWAP     D1
                   MOVE.B   D0,D1
                   ANDI.B   #$0F,D1
7F52 L07F52        SUBQ.B   #1,D1
                   BLE.S    L07F60
                   ADDQ.W   #1,A0
                   BSR.S    L07F76
                   CMP.B    (A1)+,D0
                   BEQ.S    L07F52
                   BRA.S    L07F2E
7F60 L07F60        SWAP     D1
                   LSR.B    #4,D1
                   ADDQ.W   #1,A0
                   BEQ.S    L07F6E
                   JSR      L07F0E(PC)
                   BEQ.S    L07F2E
7F6E L07F6E        ADDQ.L   #2,4(A7)
7F72 L07F72        ADDQ.W   #4,A7
                   RTS

7F76 L07F76        MOVEQ    #0,D0
                   MOVE.B   0(A6,A0.L),D0
                   BLT.S    L07F8E
                   LEA      $3C96(PC),A3
                   CMPI.B   #1,0(A3,D0.W)
                   BNE.S    L07F8E
                   BCLR     #5,D0
7F8E L07F8E        RTS

7F90 L07F90        DC.W     $FD0A 7c60
                   DC.W     $FE4A 7df0
                   DC.W     $FE4A 7df0
                   DC.W     $FE1C 7dc2
                   DC.W     $FD8E 7d34
                   DC.W     $FCF2 7c98
                   DC.W     $FDB4 7d5a
                   DC.W     $FDE8 7d8e
                   DC.W     $FE1E 7dc4
                   DC.W     $FCB0 7c56
                   DC.W     $FD06 7cac

7FA6 L07FA6        LSR.B    #1,D6
7FA8 L07FA8        JSR      L07D6E(PC)
                   ADD.B    D6,D6                  ; form word offset into table
                   MOVE.W   L07F8E(PC,D6.W),D6
                   JMP      L07FA6(PC,D6.W)

Ú------------------------------------------------------------------------------¿
³=SB_SNTX         Basic syntax analyser                                        ³
------------------------------------------------------------------------------
³JOB:                                                                          ³
------------------------------------------------------------------------------
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

7FB6 SB_SNTX       MOVEQ    #0,D7
                   MOVEQ    #0,D6
                   MOVE.L   (A2)+,-(A7)
                   MOVE.L   (A2),-(A7)
                   MOVEA.L  (A7),A5
                   MOVE.W   (A5),D6
                   ADDA.W   D6,A5
                   MOVEQ    #0,D4
                   JSR      L08282(PC)
                   MOVEA.L  (A6),A0
                   BRA.S    L07FF0

7FCE L07FCE        SUBI.B   #$80,D6
                   LSR.B    #1,D6
                   BNE.S    L07FE0
                   SUBQ.W   #1,A5
                   JSR      L0825C(PC)
                   BRA      L080B0

7FE0 L07FE0        MOVE.L   A5,D4
                   JSR      L08282(PC)
                   ADD.B    D6,D6
                   MOVEA.L  (A7),A5
                   MOVE.W   -2(A5,D6.W),D6
                   ADDA.W   D6,A5
7FF0 L07FF0        JSR      L08260(PC)
7FF4 L07FF4        MOVEQ    #0,D6
                   MOVE.B   (A5)+,D6
                   BEQ.S    L0805C
                   BMI.S    L07FCE
                   BCLR     #6,D6
                   BEQ.S    L0800E
                   MOVEA.L  4(A7),A2
                   JSR      L08148(PC)
                   BRA.S    L08028
                   BRA.S    L08046

800E L0800E        BCLR     #5,D6
                   BEQ.S    L0801C
                   JSR      L08316(PC)
                   BRA.S    L08028
                   BRA.S    L08046

801C L0801C        MOVEA.L  4(A7),A2
                   JSR      L07FA6(PC)
                   BRA.S    L08028
                   BRA.S    L08046

8028 L08028        MOVEA.L  BV.BTP(A6),A2
802C L0802C        MOVEA.L  0(A6,A2.L),A3
                   MOVEA.L  4(A6,A2.L),A0
                   MOVE.L   8(A6,A2.L),D3
                   ADDA.W   #12,A2
                   BLT.S    L0802C
                   ADDQ.W   #1,A5
                   MOVE.L   A3,BV.TKP(A6)
                   BRA.S    L07FF4

8046 L08046        JSR      L0825C(PC)
804A L0804A        MOVEQ    #0,D6
                   MOVE.B   (A5),D6
                   BEQ.S    L080B0
                   BMI.S    L08056
                   ADDA.W   D6,A5
                   BRA.S    L07FF4

8056 L08056        NEG.B    D6
                   SUBA.W   D6,A5
                   BRA.S    L07FF4

805C L0805C        MOVEA.L  BV.BTP(A6),A4
                   CMPA.L   BV.BTBAS(A6),A4
                   BGT.S    L08094
                   MOVEA.L  0(A6,A4.L),A3
                   MOVEA.L  4(A6,A4.L),A0
                   MOVEA.L  8(A6,A4.L),A5
                   ADDA.W   #12,A4
                   MOVE.L   A4,BV.BTP(A6)
                   MOVE.L   A5,D3
                   BGT.S    L08088
                   BEQ.S    L0809A
                   MOVE.L   A0,D4
                   JSR      L08282(PC)
                   BRA.S    L0805C

8088 L08088        BTST     D7,-1(A5)
                   BEQ.S    L08028
                   MOVE.L   -16(A6,A4.L),D3
                   BMI.S    L08028
8094 L08094        ADDQ.W   #8,A7
                   MOVEQ    #ERR.NC,D0             ;signal "not complete"
                   RTS

809A L0809A        MOVEA.L  BV.TGP(A6),A4
                   MOVEA.L  0(A6,A4.L),A5
                   ADDQ.W   #4,A4
                   MOVE.L   A4,BV.TGP(A6)
                   MOVE.L   A5,D3
                   BEQ.S    L08094
                   BRA      L08028

80B0 L080B0        JSR      $4F4C(PC)
                   MOVEA.L  BV.BTP(A6),A4
                   MOVEA.L  BV.TGP(A6),A2
                   SUBQ.W   #8,A4
                   MOVE.L   #$FFFFFFFF,4(A6,A4.L)
                   MOVE.L   0(A6,A2.L),0(A6,A4.L)
                   MOVEA.L  0(A6,A4.L),A5
                   SUBQ.W   #4,A4
                   MOVE.L   BV.TKP(A6),0(A6,A4.L)
                   ADDQ.W   #4,A2
                   MOVE.L   A2,BV.TGP(A6)
                   MOVE.L   A4,BV.BTP(A6)
                   MOVE.L   A5,D3
                   BNE      L0804A
                   ADDQ.W   #8,A7
                   MOVEQ    #0,D0
                   RTS

     L?????        MOVE.L   BV.BTBAS(A6),BV.BTP(A6)
                   MOVE.L   BV.TGBAS(A6),BV.TGP(A6)
                   MOVE.L   BV.TKBAS(A6),BV.TKP(A6)
                   MOVEQ    #$7E,D1
                   JSR      $4F68(PC)
                   MOVEQ    #32,D1                 ;reserve space for 32 bytes on the maths
                   JSR      BV_CHRIX(PC)           ;stack

   now set the top of the parsing temporary graph stack to the top of the maths
   stack.

                   MOVE.L   BV.RIP(A6),BV.TGBAS(A6)
                   SUBI.L   #$20,BV.TGBAS(A6)
                   MOVE.L   BV.TGBAS(A6),BV.TGP(A6)
                   MOVEQ    #$50,D1
                   JSR      $4F54(PC)
                   MOVE.L   BV.TGP(A6),BV.BTBAS(A6)
                   SUBI.L   #$50,BV.BTBAS(A6)
                   MOVE.L   BV.BTBAS(A6),BV.BTP(A6)
                   MOVEQ    #0,D0
                   JSR      $4F2C(PC)
                   MOVE.W   #$0200,D1
                   JMP      $4F4E(PC)

8148 L08148        MOVEM.L  D0-5/A1-5,-(A7)
                   MOVEA.L  A2,A3
                   MOVEA.L  A0,A1
                   MOVEQ    #0,D3
                   MOVEQ    #0,D4
                   MOVEQ    #0,D5
                   MOVEQ    #0,D0
                   LSR.B    #1,D6
                   BEQ.S    L08162
                   JSR      L07D6E(PC)
                   BRA.S    L08168

8162 L08162        ST       D0
                   SWAP     D0
                   MOVEQ    #1,D6
8168 L08168        MOVEQ    #0,D1
                   CMP.B    (A2),D6
                   BGT      L0822A
                   MOVE.B   0(A2,D6.W),D1
                   ADDA.L   D1,A2
                   MOVE.B   (A2)+,D1
                   ROR.L    #4,D1
                   MOVE.B   D1,D4
                   SWAP     D1
                   ROL.W    #4,D1
                   MOVE.B   D1,D3
8182 L08182        SUBQ.B   #1,D4
                   BLT.S    L081DE
                   MOVE.B   (A2)+,D2
                   CMPI.B   #$60,D2
                   BGT.S    L08194
                   ST       D0
                   SF       D5
                   BRA.S    L0819E

8194 L08194        SF       D0
                   TST.B    D5
                   BNE.S    L08182
                   SUBI.B   #$20,D2
819E L0819E        MOVE.B   0(A6,A0.L),D1
                   ADDQ.W   #1,A0
                   CMPI.B   #$60,D1
                   BLE.S    L081AE
                   SUBI.B   #$20,D1
81AE L081AE        CMP.B    D2,D1
                   BEQ.S    L08182
                   TST.B    D0
                   BNE.S    L081BC
                   ST       D5
                   SUBQ.W   #1,A0
                   BRA.S    L08182

81BC L081BC        SWAP     D0
                   TST.B    D0
                   BEQ.S    L0822A
                   SWAP     D5
                   TST.B    D5
                   SWAP     D5
                   BEQ.S    L081CE
                   TST.B    D3
                   BNE.S    L081D6
81CE L081CE        ADDQ.W   #1,D6
                   MOVEA.L  A1,A0
                   MOVEA.L  A3,A2
                   BRA.S    L08168

81D6 L081D6        MOVEA.L  A4,A0
                   SUBQ.B   #1,D3
                   ADDA.L   D4,A2
                   BRA.S    L08212

81DE L081DE        SWAP     D0
                   TST.B    D0
                   BEQ.S    L0821A
                   MOVE.B   0(A6,A0.L),D1
                   BLT.S    L0822A
                   LEA      $3C96(PC),A5
                   CMPI.B   #1,0(A5,D1.W)
                   BEQ.S    L08200
                   CMPI.B   #2,0(A5,D1.W)
                   BEQ.S    L0822A
                   BRA.S    L08222

8200 L08200        SWAP     D5
                   TST.B    D5
                   BNE.S    L0822A
                   TST.B    D3
                   BEQ.S    L0822A
                   ST       D5
                   SWAP     D5
                   SUBQ.B   #1,D3
                   MOVEA.L  A0,A4
8212 L08212        MOVE.B   (A2)+,D4
                   LSR.B    #4,D4
                   BRA      L08182

821A L0821A        MOVEQ    #-$7F,D4
                   MOVE.B   D6,D5
                   JSR      L085E6(PC)
8222 L08222        MOVEM.L  (A7)+,D0-5/A1-5
                   ADDQ.L   #2,(A7)
                   RTS

822A L0822A        MOVEM.L  (A7)+,D0-5/A1-5
                   RTS

Ú------------------------------------------------------------------------------¿
³=SB_CMPER        Error when compiling                                         ³
------------------------------------------------------------------------------
³JOB:                                                                          ³
------------------------------------------------------------------------------
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

8230 SB_CMPER      MOVE.L   8(A6),BV.TKP(A6)
                   MOVEA.L  (A6),A0
                   JSR      L07C56(PC)
                   BRA.S    L08258

823E L0823E        MOVEQ    #-$7F,D4
                   MOVEQ    #$1F,D5
                   JSR      L085E6(PC)
                   JSR      L07DD6(PC)
                   BRA.S    L08258

                   MOVEQ    #-$7C,D4
                   MOVEQ    #10,D5
                   JSR      L085E6(PC)
                   MOVEQ    #0,D0                  ;signal "no errors"
                   RTS

8258 L08258        MOVEQ    #ERR.BL,D0             ;signal "bad line"
                   RTS

825C L0825C        MOVE.L   A5,D4
                   BRA.S    L08262

8260 L08260        MOVEQ    #0,D4
8262 L08262        JSR      $4F4C(PC)
                   MOVEA.L  BV.BTP(A6),A4
                   SUBA.W   #12,A4
                   MOVE.L   D4,8(A6,A4.L)
                   MOVE.L   A0,4(A6,A4.L)
                   MOVE.L   BV.TKP(A6),0(A6,A4.L)
                   MOVE.L   A4,BV.BTP(A6)
                   RTS

8282 L08282        JSR      $4F52(PC)
                   MOVEA.L  BV.TGP(A6),A4
                   SUBQ.W   #4,A4
                   MOVE.L   D4,0(A6,A4.L)
                   MOVE.L   A4,BV.TGP(A6)
                   RTS

Ú------------------------------------------------------------------------------¿
³=SB_FPCBL        FORMAT PRE-COMPILED BASIC LINE                               ³
------------------------------------------------------------------------------
³JOB:                                                                          ³
------------------------------------------------------------------------------
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

8296 SB_FPCBL      MOVEA.L  BV.TKBAS(A6),A0
829A L0829A        CMPA.L   BV.TKP(A6),A0
                   BGE.S    L082BC
                   CMPI.B   #KEY.B,0(A6,A0.L)      ;keyword ?
                   BNE.S    L082AE
                   ADDQ.W   #2,A0
                   BSR.S    L082D6
                   BRA.S    L0829A

82AE L082AE        CMPI.W   #SYM.FSPC,0(A6,A0.L)   ;forced space ?
                   ADDQ.W   #2,A0
                   BNE.S    L0829A
                   BSR.S    L082F2
                   BRA.S    L0829A

82BC L082BC        MOVEA.L  BV.TKBAS(A6),A0
                   CMPI.B   #SPC.B,0(A6,A0.L)      ;space ?
                   BNE.S    L082CC
                   ADDQ.W   #2,A0
                   BSR.S    L082F2
82CC L082CC        CMPI.W   #LNO.W,0(A6,A0.L)      ;line number ?
                   BNE.S    L082F0
                   ADDQ.W   #4,A0
82D6 L082D6        CMPI.B   #SPC.B,0(A6,A0.L)      ;space ?
                   BNE.S    L082F0
                   MOVE.B   1(A6,A0.L),D1
                   ADDQ.W   #2,A0
                   SUBQ.B   #1,D1
                   BGT.S    L082EC
                   BSR.S    L082F2
                   BRA.S    L082F0

82EC L082EC        MOVE.B   D1,-1(A6,A0.L)
82F0 L082F0        RTS

82F2 L082F2        LEA      -2(A0),A2
82F6 L082F6        MOVE.W   0(A6,A0.L),-2(A6,A0.L)
                   ADDQ.W   #2,A0
                   CMPA.L   BV.TKP(A6),A0
                   BLT.S    L082F6
                   SUBQ.L   #2,BV.TKP(A6)
                   MOVEA.L  A2,A0
                   RTS

                   MOVE.W   $A63A(PC),-(A6)
                   MOVE.L   $7B7D(A1),D4
                   MOVE.L   A2,D0
8316 L08316        LSR.B    #1,D6
8318 L08318        MOVE.B   0(A6,A0.L),D1
                   CMP.B    $830B(PC,D6.W),D1
                   BEQ.S    L0832E
                   CMPI.B   #$20,D1
                   BNE.S    L0833A
                   JSR      L07D6E(PC)
                   BRA.S    L08318

832E L0832E        ADDQ.W   #1,A0
                   MOVEQ    #-$7C,D4
                   MOVE.B   D6,D5
                   JSR      L085E6(PC)
                   ADDQ.L   #2,(A7)
833A L0833A        RTS

   first syntax table for commands

833C SB_FSTFC      DC.B     $00,$00,$85,$18
                   DC.B     $00,$00,$83,'D'
                   DC.B     $00,'"',$00,'N'
                   DC.B     $00,$B9,$00,'`'
                   DC.B     $00,'f',$00,$C7
                   DC.B     $00,$CF,$00,$EE
                   DC.B     $01,$05,$01,'n'
                   DC.B     $01,$83,$01,$90
                   DC.B     $01,$A4,$01,$AD
                   DC.B     $01,$BB,$01,$C8
                   DC.B     $01,$C9,$14,$01
                   DC.B     $84,$0F,$8A,$12
                   DC.B     $86,$1E,$88,$09
                   DC.B     'h',$F9,$8C,$05
                   DC.B     $90,$03,$92,$01
                   DC.B     '%',$F1,'5',$00
                   DC.B     $00,'x',$06,'%'
                   DC.B     $EA,'5',$00,$00
                   DC.B     '3',$E5,'%',$E3
                   DC.B     '5',$00,$00,'5'
                   DC.B     $00,'%',$01,$8E
                   DC.B     $DA,$00,'N',$02
                   DC.B     $00,'P',$04,'R'
                   DC.B     $02,$00,'2',$02
                   DC.B     $00,$02,$02,$00
                   DC.B     $80,$94,$00,$00
                   DC.B     'D',$08,'H',$12
                   DC.B     'L',$16,'F',$08
                   DC.B     $00,'2',$02,$00
                   DC.B     $17,$1A,$00,'3'
                   DC.B     $02,$00,$98,$00
                   DC.B     $00,'2',$02,$00
                   DC.B     $02,$00,$00,'\'
                   DC.B     $0E,'^',$13,'`'
                   DC.B     $15,'2',$02,$00
                   DC.B     $9F,'!',$00,'#'
                   DC.B     $11,$00,$80,'3'
                   DC.B     $02,$00,$98,$0D
                   DC.B     $00,$80,''',$0D
                   DC.B     $00,$80,''',$0C
                   DC.B     $00,$96,$0F,$00
                   DC.B     $80,'(',$F0,$00
                   DC.B     $98,$0E,$00,$98
                   DC.B     $00,$00,$9A,$00
                   DC.B     $00,'z',$09,$80
                   DC.B     '(',$EC,$00,$80
                   DC.B     '(',$E1,$00,'3'
                   DC.B     $02,$00,$98,$F4
                   DC.B     $00,'J',$02,$00
                   DC.B     '2',$02,$00,'j'
                   DC.B     $04,$02,$00,$00
                   DC.B     '3',$FC,$00,'f'
                   DC.B     $0A,'d',$08,'l'
                   DC.B     $0C,'j',$11,'"'
                   DC.B     $15,$00,'2',$02
                   DC.B     $00,$02,$00,$00
                   DC.B     $80,'2',$02,$00
                   DC.B     $98,$00,$00,'2'
                   DC.B     $02,$00,$02,$EC
                   DC.B     $00,'n',$00,$96
                   DC.B     $02,$00,'(',$FC
                   DC.B     $80,$00,'B',$02
                   DC.B     $00,'H',$0D,'D'
                   DC.B     $0B,'F',$00,'J'
                   DC.B     $00,'L',$00,'N'
                   DC.B     $02,$00,$80,'2'
                   DC.B     $02,$00,$02,$00
                   DC.B     $00,'b',$16,'p'
                   DC.B     'M','r',$19,'t'
                   DC.B     '!','|','+','~'
                   DC.B     ')','T','*','j'
                   DC.B     '3','v','I',$9E
                   DC.B     'M',$02,'Q',$00
                   DC.B     $80,'2',$02,$00
                   DC.B     $98,$00,$00,'2'
                   DC.B     $02,$00,$9C,$02
                   DC.B     $00,'(',$FC,$80
                   DC.B     $00,'2',$02,$00
                   DC.B     $02,$04,$9C,$02
                   DC.B     $00,'(',$FA,$80
                   DC.B     $00,$12,$00,$00
                   DC.B     'V',$04,'X',$02
                   DC.B     $00,'2',$02,$00
                   DC.B     $98,$00,$00,'2'
                   DC.B     $02,$00,$98,$02
                   DC.B     $00,'T',$02,$00
                   DC.B     'V',$04,'X',$02
                   DC.B     $00,'3',$02,$00
                   DC.B     $98,$02,$00,'('
                   DC.B     $FC,$80,$00,'2'
                   DC.B     $02,$00,$9E,$02
                   DC.B     $00,'"',$02,$00
                   DC.B     $98,$00,$00,$A0
                   DC.B     $00,$00,'+',$02
                   DC.B     $00,$02,$04,'+'
                   DC.B     $07,$00,'(',$FA
                   DC.B     '-',$00,$00,$02
                   DC.B     $02,$00,'(',$FC
                   DC.B     '-',$F7,$00,$98
                   DC.B     $02,$00,'V',$03
                   DC.B     $80,$00,'2',$02
                   DC.B     $00,$98,$00,$00

   Second syntax table for expressions

84D4 SB_SSTFE      DC.B     $0C,$01,'*',$08
                   DC.B     $10,$0C,$04,$0C
                   DC.B     $02,$08,$00,$98
                   DC.B     $02,$00,',',$04
                   DC.B     $00,'*',$05,$80
                   DC.B     $0A,$EB,$00,$A2
                   DC.B     $02,$00,',',$F6
                   DC.B     $00,$02,$02,$00
                   DC.B     '*',$02,$00,$98
                   DC.B     $02,$00,'(',$FC
                   DC.B     ',',$00,$00,$02
                   DC.B     $02,$00,$80,'*'
                   DC.B     $02,$00,$A2,$02
                   DC.B     $00,',',$F8,$00
                   DC.B     $80,$0E,$FE,'&'
                   DC.B     $01,$98,$02,$00
                   DC.B     $0E,$F7,$80,$00
                   DC.B     $1F,' ','$','('
                   DC.B     '+','2','9','>'
                   DC.B     'E','O','X','['
                   DC.B     '^','b','g','m'
                   DC.B     'q','w','',$84
                   DC.B     $89,$8E,$91,$98
                   DC.B     $A2,$A7,$AB,$B1
                   DC.B     $B5,$BA,$BF,$C6

   The keyword token table.

     In the following table, the first byte consists of two parts. The top nibbl
     the number of bytes to follow and the bottom nibble signifies how many of t
     following keywords are matched with this one. e.g.

  END matches with FOR              giving ENDFOR
                   IF                      ENDIF
                   REPEAT                  ENDREPEAT
                   SELECT                  ENDSELECT
                   WHEN                    ENDWHEN
                   DEFINE                  ENDDEFINE

  DEFINE matches with PROCEDURE     giving DEFINE PROCEDURE
                      FUNCTION             DEFINE FUNCTION

  GO matches with TO                giving GOTO
                  SUB                      GOSUB

  WHEN matches with ERROR           giving WHEN ERROR
                    EOF                    WHEN EOF
                    INPUT                  WHEN INPUT

   This shows that even in "JM" Superbasic, it was intended that there be an error
   Trapping facility. Unfortunately this does not work properly.

8538 L08538        DC.B     $36,"END"              ;token 1
                   DC.B     $30,"FOR"              ;      2
                   DC.B     $20,"IF"               ;      3
                   DC.B     $60,"REPeat"           ;      4
                   DC.B     $60,"Select"           ;      5
                   DC.B     $40,"When"             ;      6
                   DC.B     $62,"Define"           ;      7
                   DC.B     $90,"Procedure"        ;      8
                   DC.B     $80,"Function"         ;      9
                   DC.B     $22,"GO"               ;      10
                   DC.B     $20,"TO"               ;      11
                   DC.B     $30,"SUB"              ;      12
                   DC.B     $43,"When"             ;      13
                   DC.B     $50,"Error"            ;      14
                   DC.B     $30,"EOF"              ;      15
                   DC.B     $50,"Input"            ;      16
                   DC.B     $70,"Restore"          ;      17
                   DC.B     $40,"NEXT"             ;      18
                   DC.B     $40,"EXIT"             ;      19
                   DC.B     $40,"ELSE"             ;      20
                   DC.B     $20,"ON"               ;      21
                   DC.B     $60,"Return"           ;      22
                   DC.B     $90,"Remainder"        ;      23
                   DC.B     $40,"DATA"             ;      24
                   DC.B     $30,"DIM"              ;      25
                   DC.B     $50,"LOCal"            ;      26
                   DC.B     $30,"LET"              ;      27
                   DC.B     $40,"THEN"             ;      28
                   DC.B     $40,"STEP"             ;      29
                   DC.B     $60,"Remark"           ;      30
                   DC.B     $70,"MISTake"          ;      31

85E6 L085E6        MOVEQ    #2,D1
                   BSR.S    L08654
                   MOVE.B   D4,0(A6,A3.L)
                   MOVE.B   D5,1(A6,A3.L)
                   ADDQ.W   #2,A3
                   BRA.S    L0864A

85F6 L085F6        MOVEQ    #4,D1
                   MOVEQ    #0,D2
85FA L085FA        BSR.S    L08662
                   BRA.S    L0864A
85FE L085FE        MOVEQ    #6,D1
                   MOVE.L   A1,BV.RIP(A6)          ;update pointer to top of the maths stac
                   BSR.S    L08654
                   MOVEA.L  BV.RIP(A6),A1          ;point A1 at the top of the maths stack
                   ADDQ.L   #6,BV.RIP(A6)          ;and make room for one floating point nu
                   MOVE.W   0(A6,A1.L),D2
                   ADDI.W   #$F000,D2
                   MOVE.W   D2,0(A6,A3.L)
                   MOVE.L   2(A6,A1.L),2(A6,A3.L)
                   ADDQ.W   #6,A3
                   BRA.S    L0864A

8624 L08624        MOVEQ    #1,D1
                   ADD.W    D5,D1
                   BVS.S    L08650
                   ADDQ.W   #4,D1
                   BSR.S    L08662
                   BEQ.S    L0864A
                   MOVE.W   D5,D1
8632 L08632        MOVE.B   0(A6,A2.L),0(A6,A3.L)
                   ADDQ.W   #1,A3
                   ADDQ.W   #1,A2
                   SUBQ.W   #1,D1
                   BNE.S    L08632
                   BTST     D7,D5
                   BEQ.S    L0864A
                   MOVE.B   D7,0(A6,A3.L)
                   ADDQ.W   #1,A3
864A L0864A        MOVE.L   A3,BV.TKP(A6)
                   RTS

8650 L08650        ADDQ.W   #4,A7
                   RTS

8654 L08654        MOVE.B   D2,-(A7)
                   JSR      $4F68(PC)
                   MOVE.B   (A7)+,D2
                   MOVEA.L  BV.TKP(A6),A3
                   RTS

8662 L08662        BSR.S    L08654
                   MOVE.B   D4,0(A6,A3.L)
                   MOVE.B   D2,1(A6,A3.L)
                   MOVE.W   D5,2(A6,A3.L)
                   ADDQ.W   #4,A3
                   RTS

Ú------------------------------------------------------------------------------¿
³=SB_SPFBL        STORE PRE-FORMATTED BASIC LINE                               ³
------------------------------------------------------------------------------
³JOB:                                                                          ³
------------------------------------------------------------------------------
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

8674 SB_SPFBL      MOVEA.L  BV.TKBAS(A6),A1
                   CMPI.B   #$8D,0(A6,A1.L)        ;start of a line number token ?
                   BNE      L0876E
                   MOVE.W   2(A6,A1.L),D2
                   MOVE.L   BV.TKP(A6),D1
                   SUB.L    A1,D1
                   SUBQ.W   #6,D1
                   SEQ      D0
                   ADDQ.W   #6,D1
                   MOVEQ    #0,D6
                   MOVEQ    #0,D5
                   MOVEA.L  BV.PFBAS(A6),A0
                   MOVEQ    #0,D3
                   BRA.S    L086A2

869E L0869E        MOVE.W   2(A6,A0.L),D3
86A2 L086A2        ADD.W    D5,D6
                   ADDA.L   D6,A0
                   MOVE.W   0(A6,A0.L),D5
                   ADDQ.W   #2,A0
                   CMPA.L   BV.PFP(A6),A0
                   BLT.S    L086BA
                   ADDQ.B   #1,D0
                   BGT.S    L08730
                   SUBQ.W   #2,A0
                   BRA.S    L086EA

86BA L086BA        CMP.W    2(A6,A0.L),D2
                   BGT.S    L0869E
                   BEQ.S    L086EC
                   SUBQ.W   #2,A0
                   TST.B    D0
                   BNE.S    L086EA
                   ADDQ.W   #2,D1
                   BSR      L08770
                   BSR.S    L08726
                   SUBQ.W   #2,D1
                   MOVE.W   D1,D5
                   SUB.W    D6,D5
                   MOVE.W   D5,0(A6,A0.L)
                   MOVEQ    #1,D0
86DC L086DC        BSR      L0877E
                   ADD.W    0(A6,A0.L),D6
                   SUB.W    D1,D6
                   MOVE.W   D6,0(A6,A0.L)
86EA L086EA        BRA.S    L08748

86EC L086EC        TST.B    D0
                   BEQ.S    L086F2
                   MOVEQ    #-2,D1
86F2 L086F2        ADD.W    D6,D5
                   LEA      -2(A0),A3
                   ADDA.L   D5,A0
                   CMPA.L   BV.PFP(A6),A0
                   BGE.S    L08728
                   SUB.W    D5,D1
                   BLT.S    L08706
                   BSR.S    L08770
8706 L08706        BSR.S    L08726
                   MOVEA.L  A3,A0
                   ADD.W    D5,D1
                   BGT.S    L0871A
                   ADD.W    0(A6,A0.L),D5
                   SUB.W    D6,D5
                   MOVE.W   D5,0(A6,A0.L)
                   BRA.S    L08748

871A L0871A        MOVE.W   D1,D4
                   SUB.W    D6,D4
                   MOVE.W   D4,0(A6,A0.L)
                   MOVE.W   D5,D6
                   BRA.S    L086DC

8726 L08726        BRA.S    L08792

8728 L08728        LEA      2(A3),A0
                   MOVE.L   A3,BV.PFP(A6)
8730 L08730        SUBQ.W   #2,A0
                   TST.B    D0
                   BLT.S    L08748
                   ADDQ.W   #2,D1
                   BSR.S    L08770
                   SUBQ.W   #2,D1
                   SUB.W    D6,D1
                   MOVE.W   D1,0(A6,A0.L)
                   BSR.S    L0877E
                   MOVE.L   A0,BV.PFP(A6)
8748 L08748        TST.B    BV.ARROW(A6)           ;test arrow status
                   BEQ.S    L0876C                 ;jump forward if number status

   The status was either 1 = up or -1 = down

                   SF       BV.AUTO(A6)            ;turn AUTO MODE on
                   BGT.S    L0875C
                   MOVE.W   D3,BV.EDLIN(A6)
                   BNE.S    L08768
                   BRA.S    L0876C

875C L0875C        CMPA.L   BV.PFP(A6),A0
                   BGE.S    L08768
                   MOVE.W   4(A6,A0.L),BV.EDLIN(A6)
8768 L08768        ST       BV.AUTO(A6)
876C L0876C        ADDQ.L   #2,(A7)
876E L0876E        RTS

8770 L08770        MOVEM.L  D0-3/A0-3,-(A7)
                   JSR      $4F7C(PC)
                   MOVEM.L  (A7)+,D0-3/A0-3
                   RTS

877E L0877E        ADDQ.W   #2,A0
                   MOVE.W   0(A6,A1.L),0(A6,A0.L)
                   ADDQ.W   #2,A1
                   CMPA.L   BV.TKP(A6),A1
                   BLT.S    L0877E
                   ADDQ.W   #2,A0
                   RTS

8792 L08792        MOVEM.L  D0-3/A0-3,-(A7)
                   EXT.L    D1
                   TST.L    D1
                   BEQ.S    L087CC
                   MOVEA.L  BV.PFP(A6),A1
                   BLT.S    L087B6
                   LEA      0(A1,D1.W),A2
87A6 L087A6        SUBQ.W   #2,A1
                   SUBQ.W   #2,A2
                   MOVE.W   0(A6,A1.L),0(A6,A2.L)
                   CMPA.L   A0,A1
                   BGT.S    L087A6
                   BRA.S    L087C8

87B6 L087B6        LEA      0(A0,D1.W),A2
87BA L087BA        MOVE.W   0(A6,A0.L),0(A6,A2.L)
                   ADDQ.W   #2,A0
                   ADDQ.W   #2,A2
                   CMPA.L   A1,A0
                   BLT.S    L087BA
87C8 L087C8        ADD.L    D1,BV.PFP(A6)
87CC L087CC        MOVEM.L  (A7)+,D0-3/A0-3
                   RTS

                   ST       BV.PRINT(A6)
                   MOVEA.L  BV.LNBAS(A6),A1
                   MOVE.L   BV.LNP(A6),D0
                   SUB.L    A1,D0
                   BNE.S    L087EC
                   MOVE.W   D2,D4
                   BEQ.S    L0884C
                   MOVE.W   D2,D6
                   BRA.S    L08830

87EA L087EA        MOVE.W   D4,D2
87EC L087EC        MOVE.W   0(A6,A1.L),D4
                   TST.W    D2
                   BEQ.S    L087EA
                   MOVE.W   BV.LSBAS(A6),D6
                   CMP.W    BV.LSBEF(A6),D2
                   BLT.S    L0884C
                   CMP.W    D4,D2
                   BLT.S    L0881E
                   CMP.W    BV.LSAFT(A6),D2
                   BGT.S    L0884C
                   CMP.W    D6,D2
                   BGT.S    L08816
                   TST.B    D5
                   BGE.S    L08830
                   MOVE.W   BV.LSAFT(A6),D6
                   BRA.S    L08830

8816 L08816        TST.B    D5
                   BLT.S    L0884C
                   MOVE.W   D2,D6
                   BRA.S    L08830

881E L0881E        TST.B    D5
                   BLT.S    L0884C
                   MOVE.W   D2,D4
                   MOVE.W   BV.MAXLN(A6),D0
                   SUB.W    BV.TOTLN(A6),D0
                   BGT.S    L08830
                   SUBQ.W   #1,D6
8830 L08830        MOVE.W   D2,BV.LSFIL(A6)
                   MOVEQ    #$10,D0
                   MOVEQ    #0,D2
                   MOVEQ    #0,D1
                   BSR.S    L08848
                   MOVEQ    #0,D7
                   JSR      $6E68(PC)
                   MOVEQ    #SD.CLRRT,D0           ;TRAP to clear line to right of cursor
                   BSR.S    L08848
                   MOVEQ    #SD.CLRBT,D0           ;TRAP to clear bottom of window
8848 L08848        MOVEQ    #-1,D3                 ;use an infinite timeout
                   TRAP     #3
884C L0884C        RTS

     L?????        ANDI.B   #4,D2
                   ANDI.B   #4,D2
                   SUBI.B   #$FB,D2
                   DC.W     $FB04
                   ANDI.B   #0,D0
                   MOVEQ    #$06,D1
                   MOVE.B   0(A6,A4.L),D0
                   BEQ.S    L08884
                   SUBI.B   #$80,D0
                   CMPI.B   #$70,D0
                   BGE.S    L08882
                   MOVE.B   $884E(PC,D0.W),D1
                   BGE.S    L08882
                   NEG.B    D1
                   ADD.W    2(A6,A4.L),D1
                   BCLR     #0,D1
8882 L08882        ADDA.L   D1,A4
8884 L08884        MOVE.B   0(A6,A4.L),D0
                   MOVE.W   0(A6,A4.L),D1
                   RTS

Ú------------------------------------------------------------------------------¿
³=SB_GQLCI      GET QDOS LIST CHANNEL ID                                       ³
------------------------------------------------------------------------------
³JOB:                                                                          ³
------------------------------------------------------------------------------
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

888E SB_GQLCI      MOVE.L   A1,-(A7)               ;save A1
                   MOVEA.L  BV.CHBAS(A6),A1        ;A1 points at start of SuperBASIC channel
                   ADDA.W   #2*CH.LENCH,A1         ;A1 points at entry in table for #2, then
                   MOVE.L   CH.ID(A6,A1.L),D0      ;get the QDOS channel ID for #2
                   MOVEA.L  (A7)+,A1               ;restore A1
                   RTS

88A2 L088A2        MOVE.L   A5,-(A7)               ;save A5
                   MOVEA.L  A0,A5
                   BSR.S    SB_GQLCI               ;get QDOS channel ID for list channel
                   SEQ      BV.LSANY(A6)           ;checking list status ?
                   BNE.S    L088F4                 ;jump forward if we are
                   MOVEQ    #SD.CHENQ,D0           ;TRAP to read window size or cursor posi
                   LEA      BV.LENLN(A6),A1        ;A1 points at variable for results
                   MOVEQ    #-1,D3                 ;use an infinite timeout
                   TRAP     #3                     ;read size

   the variables from BV.LENLN are set by the above TRAP as follows:-

   BV.LENLN length of window line = window width in characters             0(A1)
   BV.MAXLN maximum number of lines in window = window depth in characters 2(A1)
   BV.TOTLN number of window lines so far = cursor column                  4(A1)

   BV.AUTO and BV.PRINT are at 6(A1) and 7(A1) and are set to the cursor row word
   but this value is overwritten later.

   set the line number table running pointer to the start of the table.

                   MOVE.L   BV.LNBAS(A6),BV.LNP(A6)
                   CLR.W    BV.TOTLN(A6)           ;and set the number of window lines so far
                   MOVEQ    #100,D1
                   JSR      $4F78(PC)

   set the invisible top line number equal to the current line number.

                   MOVE.W   $BV.LINUM(A6),BV.LSBEF(A6)

   set the invisible bottom line number to be the maximum possible line number so
   that the listing will not stop until the last line is reached.

                   MOVE.W   #32767,BV.LSAFT(A6)
                   BRA.S    L088F4

   token expansion handler address table

88D6 TEHA_TBL      DC.W     SB_ESPCT-TEHA_TBL      ;expand space token
                   DC.W     SB_EKEYT-TEHA_TBL      ;expand keyword token
                   DC.W     SB_ENMTE-TEHA_TBL      ;expand name table entry (built in proce
                   DC.W     SB_ENMTE-TEHA_TBL      ;expand name table entry (built in funct
                   DC.W     SB_ESYMT-TEHA_TBL      ;expand symbol token
                   DC.W     SB_EOPST-TEHA_TBL      ;expand operation symbol token
                   DC.W     SB_EMONT-TEHA_TBL      ;expand mono_operation symbol token
                   DC.W     SB_ENMTE-TEHA_TBL      ;expand name table entry (system variabl
                   DC.W     SB_ENAMT-TEHA_TBL      ;expand name token
                   DC.W     SB_ENMTE-TEHA_TBL      ;expand name table entry (short integer)
                   DC.W     SB_ENMTE-TEHA_TBL      ;expand name table entry (long integer)
                   DC.W     SB_ESTRT-TEHA_TBL      ;expand string token
                   DC.W     SB_ETXTT-TEHA_TBL      ;expand text token
                   DC.W     SB_ELNOT-TEHA_TBL      ;expand line number token
                   DC.W     SB_ESEPT-TEHA_TBL      ;expand seperator token

   was checking list status

88F4 L088F4        MOVE.L   (A2),-(A7)
                   ADDQ.W   #2,A4
                   MOVEQ    #0,D4
                   MOVE.B   #$8D,D4                ;start of line number indicator

88FE L088FE        MOVE.L   (A6),BV.BFP(A6)        ;set buffer running pointer to start of
8902 L08902        CMPA.L   BV.PFP(A6),A4          ;program file running pointer = A4 ?
                   BLT.S    L0891C                 ;jump forward if ???
                   TST.B    BV.PRINT(A6)           ;leave token in buffer ?
                   BNE      L089EE                 ;jump forward if not
                   TST.B    BV.AUTO(A6)            ;AUTO or EDIT mode on ?
                   BEQ      L089EE                 ;jump forward if off
                   BSR      L08A3C
891C L0891C        MOVEQ    #$10,D1
                   BSR      L08AAC
                   MOVEA.L  (A7),A1
                   SUBI.B   #SPC.B,D4              ;change to range 0 to 15
                   CMPI.B   #FP.B-SPC.B,D4         ;is it a floating point number ?
                   BGE      L089DE                 ;jump forward if it is
                   ADD.B    D4,D4                  ;double it to form word offset into tabl

   first pick up the offset to the required token expansion handler routine from
   the table and then call the handler.

                   MOVE.W   TEHA_TBL(PC,D4.W),D4
                   JSR      TEHA_TBL(PC,D4.W)

                   CMPI.B   #$8D,D4                ;start of line number ?
                   BNE      L089E0                 ;jump forward if not
                   TST.B    BV.PRINT(A6)           ;print token or leave in buffer ?
                   BEQ      L089EA                 ;jump forward if to leave in buffer
                   TST.B    BV.LSANY(A6)           ;checking list status ?
                   BEQ.S    L089A4                 ;jump forward if not
                   MOVEA.L  (A6),A1                ;A1 points at start of buffer (start of
                   MOVE.L   BV.BFP(A6),D2          ;D2 = buffer running pointer (end of lin
                   SUB.L    A1,D2                  ;find length of line in buffer
                   MOVEA.L  BV.LNP(A6),A2          ;A2 = line number table running pointer

   set the current entry in the line number table to the line number of the bott
   of the list window.

                   MOVE.W   BV.LSBAS(A6),0(A6,A2.L)

   ignore the line number word by reducing the length of the line by two as the
   line number word itself isn't printed.

                   SUBQ.W   #2,D2

   and find out how many window lines will be taken up when this line is printed
   out, by dividing its length by the window character width and then rounding t
   result up.

                   DIVU     BV.LENLN(A6),D2
                   ADDQ.W   #1,D2

   and store the number of screen lines for this basic line in the line number
   table entry.

                   MOVE.W   D2,2(A6,A2.L)

                   ADD.W    BV.TOTLN(A6),D2        ;add to number of window lines used so f
8972 L08972        CMP.W    BV.MAXLN(A6),D2        ;more than maximum number allowed in win
                   BLE.S    L08998                 ;jump forward if ???
                   MOVE.W   BV.LSFIL(A6),D0        ;D0 = line to fill window to when re-lis
                   BEQ.S    L08984                 ;and jump forward if this is zero
                   CMP.W    BV.LSBAS(A6),D0        ;more than bottom line number in window
                   BLT.S    L089D0
8984 L08984        MOVEA.L  BV.LNBAS(A6),A2        ;A2 points at first entry in line number
                   SUB.W    2(A6,A2.L),D2

   set the invisible top line number in the window to the first entry in the lin
   number table.

                   MOVE.W   0(A6,A2.L),BV.LSBEF(A6)
                   ADDQ.L   #4,BV.LNBAS(A6)        ;move line number table base by one entr
                   BRA.S    L08972                 ;and recheck

8998 L08998        MOVE.W   D2,BV.TOTLN(A6)

   increment the line number table running pointer by one entries worth.

                   ADDQ.L   #4,BV.LNP(A6)
                   JSR      $5098(PC)
89A4 L089A4        MOVEQ    #IO.SSTRG,D0           ;TRAP to send a string of bytes
                   MOVEA.L  (A6),A1                ;A1 points at start of line in buffer
                   MOVE.L   BV.BFP(A6),D2          ;D2 points at end of line in buffer
                   SUB.L    A1,D2                  ;form length of line in buffer

   and set A0 to the QDOS channel ID of the list channel.

                   MOVEA.L  A5,A0
                   MOVEQ    #-1,D3                 ;use an infinite timeout
                   TRAP     #4                     ;make every location absolute
                   TRAP     #3                     ;and print the line
                   TST.L    D0                     ;any errors ?
                   BNE.S    L089F0                 ;jump forward if so
                   MOVE.L   D1,D2
                   MOVEQ    #SD.CLRRT,D0           ;TRAP to clear line to the right of the
                   TRAP     #3                     ;clear the remainder of the printed line
                   TAS      BV.BRK(A6)             ;Break key pressed during printing ?
                   BNE      L088FE                 ;process next line of not

   set the invisible bottom line number to be equal to the bottom line number in
   the list window.

                   MOVE.W   BV.LSBAS(A6),BV.LSAFT(A6)
                   BRA.S    L089EE

   set the invisible bottom line number to be equal to the bottom line number in
   the list window.

89D0 L089D0        MOVE.W   BV.LSBAS(A6),BV.LSAFT(A6)
                   MOVE.W   -4(A6,A2.L),BV.LSBAS(A6)
                   BRA.S    L089EE
89DE L089DE        BSR.S    L08A02
89E0 L089E0        JSR      L0885E(PC)
                   MOVE.W   D0,D4
                   BRA      L08902

89EA L089EA        SUBQ.L   #1,4(A6)
89EE L089EE        MOVEQ    #0,D0
89F0 L089F0        ADDQ.W   #4,A7
                   MOVEA.L  A5,A0
                   MOVEA.L  (A7)+,A5
                   RTS

89F8 L089F8        JSR      $4F46(PC)
                   MOVEA.L  BV.RIP(A6),A1          ;point A1 at the top of the maths stack
                   RTS

8A02 L08A02        BSR.S    L089F8
                   MOVE.W   0(A6,A4.L),D2
                   SUBI.W   #$F000,D2
                   SUBQ.W   #6,A1
                   MOVE.W   D2,0(A6,A1.L)
                   MOVE.L   2(A6,A4.L),2(A6,A1.L)
                   MOVEA.L  4(A6),A0
                   JSR      $3F66(PC)
                   BRA      L08B50

Ú------------------------------------------------------------------------------¿
³=SB_ELNOT        EXPAND LINE NUMBER TOKEN                                     ³
------------------------------------------------------------------------------
³JOB:                                                                          ³
------------------------------------------------------------------------------
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

8A24 SB_ELNOT      BSR.S    L089F8
                   MOVE.W   2(A6,A4.L),D1
                   TST.B    BV.PRINT(A6)
                   BNE.S    L08A48
                   TST.B    BV.AUTO(A6)
                   BEQ.S    L08A48
                   CMP.W    BV.EDLIN(A6),D1
                   BEQ.S    L08A48
8A3C L08A3C        BSR.S    L089F8
                   MOVE.W   BV.EDLIN(A6),D1
                   BSR.S    L08A62
8A44 L08A44        ADDQ.W   #4,A7
                   BRA.S    L089EE

8A48 L08A48        TST.B    BV.LSANY(A6)
                   BEQ.S    L08A74
                   CMP.W    D6,D1
                   BLE.S    L08A5E
                   TST.W    BV.LSFIL(A6)
                   BNE.S    L08A5E
                   MOVE.W   D1,BV.LSAFT(A6)
                   BRA.S    L08A44
8A5E L08A5E        MOVE.W   D1,BV.LSBAS(A6)
8A62 L08A62        SUBQ.W   #2,A1
                   MOVE.W   D1,0(A6,A1.L)
                   MOVEA.L  BV.BFP(A6),A0
                   JSR      $3EC4(PC)
                   BRA      L08B02
8A74 L08A74        CMP.W    D6,D1
                   BGT.S    L08A44
                   BRA.S    L08A62

8A7A L08A7A        DC.B     $3F,$3F,$3F,$3F

Ú------------------------------------------------------------------------------¿
³=SB_ENMTE        EXPAND NAME TABLE ENTRY                                      ³
³=SB_ENAMT        EXPAND NAME TOKEN                                            ³
------------------------------------------------------------------------------
³JOB:                                                                          ³
------------------------------------------------------------------------------
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

8A7E SB_ENMTE      MOVEQ    #4,D1
                   LEA      L08A7A(PC),A1
                   BRA      L08B46

8A88 SB_ENAMT      MOVE.W   2(A6,A4.L),D2
                   LSL.L    #3,D2
                   MOVEA.L  BV.NTBAS(A6),A1
                   ADDA.W   D2,A1
                   MOVE.W   2(A6,A1.L),D2
                   BLT.S    L08A7E
                   MOVEA.L  BV.NLBAS(A6),A1
                   ADDA.W   D2,A1
                   MOVEQ    #0,D1
                   MOVE.B   0(A6,A1.L),D1
                   ADDQ.W   #1,A1
                   BRA      L08B40

8AAC L08AAC        SUBA.L   BV.PFBAS(A6),A4
                   SUBA.L   BV.PFBAS(A6),A1
                   MOVEM.L  D1/A1/A4,-(A7)
                   JSR      $4F64(PC)
                   MOVEA.L  4(A6),A0
                   MOVEM.L  (A7)+,D1/A1/A4
                   ADDA.L   BV.PFBAS(A6),A1
                   ADDA.L   BV.PFBAS(A6),A4
                   RTS

Ú------------------------------------------------------------------------------¿
³=SB_ESTRT        EXPAND STRING TOKEN                                          ³
³=SB_ETXTT        EXPAND TEXT TOKEN                                            ³
³=SB_ESPCT        EXPAND SPACE TOKEN                                           ³
------------------------------------------------------------------------------
³JOB:                                                                          ³
------------------------------------------------------------------------------
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

8ACE SB_ESTRT      BSR.S    L08AD2
                   BSR.S    SB_ETXTT               ;call expand text token to expand string
8AD2 L08AD2        MOVE.B   1(A6,A4.L),D2
                   BRA.S    L08B38

8AD8 SB_ETXTT      MOVE.W   2(A6,A4.L),D1
                   BEQ.S    L08AF2
                   LEA      4(A4),A1
                   BRA.S    L08B40

8AE4 SB_ESPCT      MOVE.B   1(A6,A4.L),D1
                   BSR.S    L08AAC
8AEA L08AEA        MOVEQ    #" ",D2
                   BSR.S    L08B38
                   SUBQ.B   #1,D1
                   BGT.S    L08AEA
8AF2 L08AF2        RTS

Ú------------------------------------------------------------------------------¿
³=SB_ESEPT        EXPAND SEPERATOR TOKEN                                       ³
³=SB_EOPST        EXPAND OPERATION SYMBOL TOKEN                                ³
³=SB_EKEYT        EXPAND KEYWORD TOKEN                                         ³
³=SB_EMONT        EXPAND MONO-OPERATION SYMBOL TOKEN                           ³
------------------------------------------------------------------------------
³JOB:                                                                          ³
------------------------------------------------------------------------------
³SYNTAX:                                                                       ³
------------------------------------------------------------------------------
*ACTION:
Ú------------------------------------------------------------------------------¿
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

8AF4 SB_ESEPT      LEA      L08B58(PC),A1
                   BRA.S    L08B0A

8AFA SB_EOPST      LEA      L08B7A(PC),A1
                   BRA.S    L08B0A

8B00 SB_EKEYT      BSR.S    L08B0A
8B02 L08B02        MOVEQ    #" ",D2
                   BRA.S    L08B38

8B06 SB_EMONT      LEA      L08B6A(PC),A1
8B0A L08B0A        MOVE.B   1(A6,A4.L),D1
                   MOVE.B   0(A1,D1.W),D1
                   ADDA.L   D1,A1
                   MOVE.B   (A1)+,D1
                   LSR.L    #4,D1
                   BRA.S    L08B46

8B1A L08B1A        DC.B     "="
                   DC.B     ":"
                   DC.B     "#"
                   DC.B     ","
                   DC.B     "("
                   DC.B     ")"
                   DC.B     "{"
                   DC.B     "}"
                   DC.B     " "
                   DC.B     10

Ú------------------------------------------------------------------------------¿
³=SB_ESYMT        EXPAND SYMBOL TOKEN                                          ³
------------------------------------------------------------------------------
³JOB:                                                                          ³
------------------------------------------------------------------------------
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

8B24 SB_ESYMT      MOVE.B   1(A6,A4.L),D1
                   MOVE.B   $8B1A-1(PC,D1.W),D2
                   MOVEQ    #0,D4
                   SUB.B    D2,D1
                   BNE.S    L08B38
                   ADDQ.W   #4,A4
                   MOVE.B   #$8D,D4
8B38 L08B38        MOVE.B   D2,0(A6,A0.L)
                   ADDQ.W   #1,A0
                   BRA.S    L08B50

8B40 L08B40        BSR      L08AAC
                   ADDA.L   A6,A1
8B46 L08B46        MOVE.B   (A1)+,0(A6,A0.L)
                   ADDQ.W   #1,A0
                   SUBQ.W   #1,D1
                   BGT.S    L08B46
8B50 L08B50        MOVE.L   A0,BV.BFP(A6)
                   MOVEQ    #0,D0
                   RTS

   Operator table number 2

8B58 L08B58        DC.B     5                      ;number of offsets to follow
                   DC.B     6
                   DC.B     8
                   DC.B     10
                   DC.B     12
                   DC.B     14
                   DC.B     $10,","
                   DC.B     $10,";"
                   DC.B     $10,"\"
                   DC.B     $10,"!"
                   DC.B     $20,"TO",0

   mono-operation symbol table

8B6A L08B6A        DC.B     4                      ;number of offsets to follow
                   DC.B     5
                   DC.B     7
                   DC.B     9
                   DC.B     12
                   DC.B     $10,"-"
                   DC.B     $10,"+"
                   DC.B     $20,"~~"
                   DC.B     $30,"NOT"

8B7A L08B7A        DC.B     22                     ;number of offsets to follow
                   DC.B     23
                   DC.B     25
                   DC.B     27
                   DC.B     29
                   DC.B     31
                   DC.B     34
                   DC.B     36
                   DC.B     39
                   DC.B     41
                   DC.B     44
                   DC.B     47
                   DC.B     49
                   DC.B     52
                   DC.B     55
                   DC.B     58
                   DC.B     60
                   DC.B     62
                   DC.B     65
                   DC.B     69
                   DC.B     73
                   DC.B     77
                   DC.B     81
                   DC.B     $10,"+"
                   DC.B     $10,"-"
                   DC.B     $10,"*"
                   DC.B     $10,"/"
                   DC.B     $20,">="
                   DC.B     $10,">"
                   DC.B     $20,"=="
                   DC.B     $10,"="
                   DC.B     $20,"<>"
                   DC.B     $20,"<="
                   DC.B     $10,"<"
                   DC.B     $20,"||"
                   DC.B     $20,"&&"
                   DC.B     $20,"^^"
                   DC.B     $10,"^"
                   DC.B     $10,"and"
                   DC.B     $20,"OR"
                   DC.B     $30,"AND"
                   DC.B     $30,"XOR"
                   DC.B     $30,"MOD"
                   DC.B     $30,"DIV"
                   DC.B     $50,"INSTR",0

8BD2 L08BD2        ANDI.B   #%00001111,1(A6,A2.L)
                   TST.L    4(A6,A2.L)
                   BGE.S    L08BE2
                   MOVEQ    #ERR.BN,D0             ;signal "bad name"
                   RTS

8BE2 L08BE2        JSR      $4F58(PC)
                   MOVEA.L  BV.NTP(A6),A3
                   ADDQ.L   #8,BV.NTP(A6)
                   MOVE.W   0(A6,A2.L),0(A6,A3.L)
                   MOVE.W   D4,2(A6,A3.L)
                   MOVEA.L  4(A6,A2.L),A2
                   ADDA.L   BV.VVBAS(A6),A2
                   MOVE.W   4(A6,A2.L),D1
                   LSL.L    #2,D1
                   ADDQ.W   #6,D1
                   JSR      $6C88(PC)
8C0C L08C0C        MOVE.W   0(A6,A2.L),0(A6,A0.L)
                   ADDQ.W   #2,A2
                   ADDQ.W   #2,A0
                   SUBQ.W   #2,D1
                   BGT.S    L08C0C
8C1A L08C1A        JSR      L09B92(PC)
                   CMPI.W   #SYM.EQ,D1             ;equals sign ?
                   BEQ.S    L08C42
                   CMPI.W   #SYM.LBKT,D1           ;left round bracket ?
                   BNE      L08CAE
                   ADDQ.W   #2,A4
                   MOVEA.L  A4,A0
                   LEA      8(A3),A5
                   JSR      $5CDC(PC)
                   LEA      -8(A5),A3
                   MOVEA.L  A0,A4
                   BNE.S    L08C7A
                   BRA.S    L08C1A
8C42 L08C42        ADDQ.W   #2,A4
                   CMPI.B   #2,0(A6,A3.L)
                   BEQ.S    L08C64
                   CMPI.B   #1,1(A6,A3.L)
                   BGT.S    L08CB2
                   MOVEA.L  4(A6,A3.L),A2
                   ADDA.L   BV.VVBAS(A6),A2
                   CMPI.W   #1,4(A6,A2.L)
                   BGT.S    L08CB2
8C64 L08C64        MOVEA.L  A4,A0
                   MOVE.B   1(A6,A3.L),D0
                   MOVE.L   A3,-(A7)
                   JSR      $54FA(PC)
                   MOVEA.L  (A7)+,A3
                   MOVEA.L  A0,A4
                   BNE.S    L08C7A
                   JSR      $6C12(PC)
8C7A L08C7A        CMPI.B   #3,0(A6,A3.L)
                   BNE.S    L08C96
                   MOVEA.L  4(A6,A3.L),A2
                   ADDA.L   BV.VVBAS(A6),A2
                   MOVE.L   D0,-(A7)
                   MOVE.L   A3,-(A7)
                   JSR      L0920A(PC)
                   MOVEA.L  (A7)+,A3
                   MOVE.L   (A7)+,D0
8C96 L08C96        CLR.L    0(A6,A3.L)
                   CLR.L    4(A6,A3.L)
                   ADDQ.W   #8,A3
                   CMPA.L   BV.NTP(A6),A3
                   BNE.S    L08CAA
                   SUBQ.L   #8,BV.NTP(A6)
8CAA L08CAA        TST.L    D0
                   RTS

8CAE L08CAE        MOVEQ    #-$11,D0
                   BRA.S    L08C7A

8CB2 L08CB2        MOVEQ    #-$13,D0
                   BRA.S    L08C7A

8CB6 L08CB6        JSR      $4F5E(PC)
                   MOVEA.L  BV.RTP(A6),A5
                   TST.B    D5
                   BEQ.S    L08CEE
                   MOVE.L   D4,D3
                   MOVEA.L  BV.NTP(A6),A3
                   MOVE.L   A3,0(A6,A5.L)
                   MOVE.L   A3,4(A6,A5.L)
                   MOVE.L   A3,8(A6,A5.L)
                   MOVE.W   4(A6,A2.L),D4
                   BEQ      L08D6C
                   MOVE.W   D4,12(A6,A5.L)
                   MOVE.B   1(A6,A2.L),$0E(A6,A5.L)
                   SF       $0F(A6,A5.L)
                   ADDA.W   #$10,A5
8CEE L08CEE        MOVE.B   D5,0(A6,A5.L)
                   MOVE.B   BV.STMNT(A6),1(A6,A5.L)
                   MOVE.W   BV.LINUM(A6),2(A6,A5.L)
                   MOVE.L   BV.INLIN(A6),4(A6,A5.L)
                   ADDQ.W   #8,A5
                   MOVE.L   A5,BV.RTP(A6)
                   TST.B    D5
                   BEQ.S    L08D62
                   CMPI.B   #3,D5
                   BEQ.S    L08D5A
                   MOVEA.L  A4,A0
                   JSR      $5BB4(PC)
                   MOVEA.L  BV.RTP(A6),A5
                   MOVE.L   BV.NTP(A6),-$14(A6,A5.L)
                   MOVE.L   BV.NTP(A6),-$10(A6,A5.L)
                   TST.L    D0
                   BNE.S    L08D3C
                   MOVE.W   0(A6,A0.L),D1
                   CMPI.B   #2,D5
                   BEQ.S    L08D4C
                   BSR.S    L08DAA
                   BEQ.S    L08D58
8D3C L08D3C        BSR      L08F86
                   SUBI.L   #$18,BV.RTP(A6)
                   MOVEQ    #ERR.BP,D0             ;signal "bad parameter"
                   RTS

8D4C L08D4C        CMPI.W   #SYM.RBKT,D1           ;right round bracket ?
                   BNE.S    L08D3C
                   ADDQ.W   #2,A0
                   MOVE.L   A0,8(A7)
8D58 L08D58        MOVEA.L  A0,A4
8D5A L08D5A        ST       -9(A6,A5.L)
                   MOVEA.L  -$18(A6,A5.L),A3
8D62 L08D62        TST.B    BV.SING(A6)
                   BEQ.S    L08D80
                   BSR.S    L08D70
                   BEQ.S    L08D80
8D6C L08D6C        MOVEQ    #ERR.NF,D0             ;signal "not found"
                   RTS

8D70 L08D70        MOVEA.L  BV.PFBAS(A6),A4
                   SF       BV.SING(A6)
                   CLR.W    BV.LNGTH(A6)
                   JMP      L09F42(PC)

8D80 L08D80        TST.B    D5
                   BEQ      L0976A
                   BSR      L08F2E
                   BSR      L08E64
8D8E L08D8E        BSR.S    L08DDE
                   BEQ.S    L08DAE
                   MOVEA.L  BV.RTP(A6),A5
                   MOVE.L   BV.NTP(A6),-$10(A6,A5.L)
                   TST.L    D0
                   BNE.S    L08DA8
                   ADDQ.W   #4,A7
                   JMP      L09ED0(PC)

                   MOVEQ    #0,D0                  ;signal "no errors"
8DA8 L08DA8        RTS

8DAA L08DAA        BRA      L08E58
8DAE L08DAE        ADDQ.W   #2,A4
                   BSR.S    L08E2E
                   CMPI.B   #$88,D0                ;start of name token ?
                   BNE.S    L08DD0
                   BSR.S    L08E32
                   BSR.S    L08E2E
                   CMPI.W   #SYM.LBKT,D1           ;left round bracket ?
                   BNE.S    L08DD0
                   ADDQ.B   #1,0(A6,A2.L)
                   SUBQ.W   #4,A4
                   JSR      L090B6(PC)
                   BNE.S    L08DA8
                   BSR.S    L08E2E
8DD0 L08DD0        CMPI.W   #SYM.COM,D1            ;comma token ?
                   BEQ.S    L08DAE
                   BSR.S    L08DAA
                   BEQ.S    L08D8E
                   MOVEQ    #ERR.BL,D0             ;signal "bad line"
                   RTS

8DDE L08DDE        JSR      L09C30(PC)
                   BNE.S    L08DFA
                   BSR.S    L08E2E
                   MOVEQ    #0,D0
                   CMPI.W   #KEY.RMRK,D1           ;REMark token ?
                   BEQ.S    L08DDE
                   CMPI.W   #KEY.DATA,D1           ;DATA token ?
                   BEQ.S    L08DDE
                   CMPI.W   #KEY.LOCL,D1           ;LOCal token ?
                   RTS

8DFA L08DFA        MOVEQ    #ERR.EF,D0             ;signal "end of file"
                   RTS

8DFE L08DFE        MOVEQ    #0,D0
                   MOVE.W   2(A6,A4.L),D0
                   LSL.L    #3,D0
                   MOVEA.L  BV.NTBAS(A6),A2
                   ADDA.L   D0,A2
                   MOVE.W   0(A6,A2.L),D0
                   MOVE.W   0(A6,A3.L),0(A6,A2.L)
                   MOVE.W   D0,0(A6,A3.L)
                   MOVE.L   4(A6,A2.L),D0
                   MOVE.L   4(A6,A3.L),4(A6,A2.L)
                   MOVE.L   D0,4(A6,A3.L)
                   ADDQ.W   #8,A3
                   ADDQ.W   #4,A4
                   RTS

8E2E L08E2E        JMP      L09B92(PC)

8E32 L08E32        MOVEA.L  BV.NTP(A6),A3
                   MOVE.B   #2,0(A6,A3.L)
                   MOVE.W   #$FFFF,2(A6,A3.L)
                   MOVE.L   #$FFFFFFFF,4(A6,A3.L)
                   BSR.S    L08DFE
                   MOVE.B   -7(A6,A3.L),1(A6,A2.L)
                   MOVE.L   A3,BV.NTP(A6)
                   RTS

8E58 L08E58        CMPI.W   #SYM.LF,D1             ;line feed symbol token ?
                   BEQ.S    L08E62
                   CMPI.W   #SYM.COL,D1            ; colon symbol token ?
8E62 L08E62        RTS

8E64 L08E64        BSR.S    L08E2E
                   ADDQ.W   #2,A4
                   BSR.S    L08E2E
                   ADDQ.W   #2,A4
                   BSR.S    L08E2E
                   TST.W    D3
                   BLT.S    L08E78
                   CMP.W    2(A6,A4.L),D3
                   BNE.S    L08E86
8E78 L08E78        ADDQ.W   #4,A4
                   BSR.S    L08E2E
                   CMPI.W   #SYM.LBKT,D1           ;left bracket symbol token ?
                   BEQ.S    L08E92
                   BSR.S    L08E58
                   BEQ.S    L08E8C
8E86 L08E86        ADDQ.W   #4,A7
8E88 L08E88        MOVEQ    #ERR.NF,D0             ;signal "not found"
                   RTS

8E8C L08E8C        MOVEA.L  -$14(A6,A5.L),A3
                   RTS

8E92 L08E92        ADDQ.W   #2,A4
8E94 L08E94        BSR.S    L08E2E
                   CMPI.B   #$88,D0                ;start of a name token ?
                   BNE.S    L08EB0
                   CMPA.L   -$14(A6,A5.L),A3
                   BLT.S    L08EAA
                   BSR.S    L08E32
                   MOVE.L   A3,-$14(A6,A5.L)
                   BRA.S    L08E94
8EAA L08EAA        BSR      L08DFE
                   BRA.S    L08E94
8EB0 L08EB0        CMPI.W   #SYM.RBKT,D1           ;right round bracket symbol token ?
                   BNE.S    L08E92
8EB6 L08EB6        RTS

8EB8 L08EB8        MOVEA.L  BV.RTP(A6),A5
                   CMPA.L   BV.RTBAS(A6),A5
                   BLE.S    L08E88
                   MOVE.B   -8(A6,A5.L),D5
                   BEQ.S    L08EEA
                   MOVE.B   D5,D0
                   SUBQ.B   #2,D0
                   BLT.S    L08EE6
                   MOVE.B   -10(A6,A5.L),D0
                   MOVEA.L  A4,A0
                   JSR      $54FA(PC)
                   MOVEA.L  A0,A4
                   BLT.S    L08EB6
                   BEQ.S    L08EE2
                   MOVEQ    #ERR.XP,D0             ;signal "error in expression"
                   RTS

8EE2 L08EE2        MOVEA.L  BV.RTP(A6),A5
8EE6 L08EE6        BSR.S    L08F36
                   BNE.S    L08EB6
8EEA L08EEA        MOVE.L   -4(A6,A5.L),BV.INLIN(A6)
                   MOVE.W   -6(A6,A5.L),D4
                   BSR.S    L08F2E
                   MOVE.L   -4(A6,A5.L),BV.INLIN(A6)
                   MOVE.B   -7(A6,A5.L),D4
                   JSR      L096FC(PC)
                   SUBQ.W   #8,A5
                   TST.B    D5
                   BEQ.S    L08F0E
                   SUBA.W   #$10,A5
8F0E L08F0E        SF       BV.UNRVL(A6)
                   MOVE.L   A5,BV.RTP(A6)
                   MOVEQ    #0,D0
                   SUBQ.B   #2,D5
                   BLT.S    L08F2A
                   MOVEA.L  BV.NTP(A6),A5
                   MOVE.B   #1,-8(A6,A5.L)
                   ADDQ.W   #8,A7
                   MOVEA.L  (A7)+,A0
8F2A L08F2A        TST.L    D0
                   RTS

8F2E L08F2E        JSR      L09694(PC)
                   JMP      L09F42(PC)
8F36 L08F36        CMPA.L   BV.PFBAS(A6),A4
                   BLE.S    L08F42
                   CMPA.L   BV.PFP(A6),A4
                   BLT.S    L08F46
8F42 L08F42        BSR      L08D70
8F46 L08F46        TST.B    -9(A6,A5.L)
                   BEQ.S    L08F86
                   MOVE.W   -12(A6,A5.L),D4
                   MOVEA.L  -$14(A6,A5.L),A3
                   BSR.S    L08F2E
8F56 L08F56        BSR      L08DDE
                   BNE.S    L08F6E
8F5C L08F5C        MOVE.W   #NAM.W,D4              ;name token
                   JSR      L09C02(PC)
                   BNE.S    L08F56
                   BSR      L08DFE
                   SUBQ.W   #4,A4
                   BRA.S    L08F5C
8F6E L08F6E        MOVE.W   -12(A6,A5.L),D4
                   MOVEA.L  -$18(A6,A5.L),A3
                   TST.B    D0
                   BEQ.S    L08F7E
                   BSR      L08D70
8F7E L08F7E        BSR.S    L08F2E
                   MOVEQ    #-1,D3
                   BSR      L08E64
8F86 L08F86        MOVEA.L  -$18(A6,A5.L),A3
                   MOVEA.L  -$10(A6,A5.L),A5
                   JSR      $5178(PC)
                   BNE.S    L08F2A
                   MOVEA.L  BV.RTP(A6),A5
                   RTS

                   BSR.S    L08FB0
                   RTS

   Message

8F9E L08F9E        ORI.B    #$52,(A0)
                   DC.W     $4F43
                   MOVE.L   D6,$4E20(A7)

     L?????        BLS.S    L09016
                   BCS.S    L0900D
                   MOVEQ    #$65,D1
                   BCC.S    L08FBA
8FB0 L08FB0        MOVEA.L  BV.CHBAS(A6),A0
                   MOVEA.L  0(A6,A0.L),A0
                   LEA      L08F9E(PC),A1
                   JSR      $3A22(PC)
8FC0 L08FC0        MOVEA.L  BV.RTP(A6),A5
                   CMPA.L   BV.RTBAS(A6),A5
                   BLE.S    L08FF6
                   MOVE.B   -8(A6,A5.L),D5
                   BEQ.S    L08FD8
                   BSR      L08F36
                   SUBA.W   #$10,A5
8FD8 L08FD8        SUBQ.W   #8,A5
                   MOVE.L   A5,BV.RTP(A6)
                   SUBQ.B   #2,D5
                   BLT.S    L08FC0
                   MOVEA.L  BV.NTP(A6),A5
                   SUBQ.W   #8,A5
8FE8 L08FE8        MOVEQ    #0,D2
                   JSR      $5732(PC)
                   BNE.S    L08FE8
                   MOVE.L   A5,BV.NTP(A6)
                   BRA.S    L08FC0
8FF6 L08FF6        SF       BV.UNRVL(A6)
                   MOVEA.L  (A7)+,A3
                   MOVEA.L  (A7)+,A5
                   TRAP     #$                     ;??????????????
                   MOVEA.L  $64(A6),A1
                   ADDA.L   A6,A1
                   SUBQ.W   #4,A1
                   MOVE.L   A1,USP
                   MOVE.W   #0,SR
                   MOVE.L   A5,-(A7)
                   MOVE.L   A3,-(A7)
                   ST       BV.SING(A6)
9016 L09016        TST.B    BV.UNDO(A6)
                   BNE      L09D10
                   RTS

9020 L09020        MOVE.L   A4,-(A7)
                   JSR      L092B6(PC)
                   BLT.S    L09040
9028 L09028        ADDQ.W   #2,A4
                   JSR      L09B92(PC)
                   MOVE.L   A4,-(A7)
                   JSR      L092B6(PC)
                   CMPA.L   (A7)+,A4
                   BNE.S    L0903E
                   TST.B    D0
                   BGE.S    L09028
                   BRA.S    L09040
903E L0903E        MOVEQ    #0,D0
9040 L09040        MOVEA.L  (A7)+,A4
                   RTS

9044 L09044        MOVEQ    #0,D6
                   MOVE.L   A4,D3
9048 L09048        MOVE.W   0(A6,A4.L),D1
                   CMPI.W   #KEY.GO,D1             ;GO keyword token ?
                   BEQ.S    L0906E
                   JSR      L08E58(PC)
                   BEQ.S    L09070
                   CMPI.W   #SYM.EQ,D1             ;equals symbol token ?
                   BNE.S    L09068
                   TST.B    D6
                   BNE.S    L09068
                   ADDQ.W   #2,A4
                   MOVE.L   A4,D3
                   MOVEQ    #1,D6
9068 L09068        JSR      L0885E(PC)
                   BRA.S    L09048
906E L0906E        MOVEQ    #-1,D0
9070 L09070        MOVEA.L  D3,A4
                   RTS

9074 L09074        JSR      L09C30(PC)
                   BNE.S    L09090
                   JSR      L09B92(PC)
                   CMPI.W   #KEY.END,D1            ;END keyword token ?
                   BNE.S    L09074
                   ADDQ.W   #2,A4
                   JSR      L09B92(PC)
                   CMPI.W   #KEY.DEF,D1            ;DEFine keyword token ?
                   BNE.S    L09074
9090 L09090        MOVEQ    #0,D0                  ;signal "no errors"
                   RTS

                   MOVEM.L  D4-6/A5,-(A7)
                   SUBQ.W   #2,A4
909A L0909A        ADDQ.W   #2,A4
                   JSR      L09B92(PC)
                   BSR.S    L090B6
                   BNE.S    L090B0
                   JSR      L09B92(PC)
                   CMPI.W   #SYM.COM,D1            ;comma symbol token ?
                   BEQ.S    L0909A
                   MOVEQ    #0,D0                  ;signal "no errors"
90B0 L090B0        MOVEM.L  (A7)+,D4-6/A5
                   RTS

90B6 L090B6        MOVEQ    #0,D4
                   MOVE.W   2(A6,A4.L),D4
                   ADDQ.W   #4,A4
                   JSR      L09B92(PC)
                   ADDQ.W   #2,A4
                   MOVEQ    #0,D5
                   MOVEA.L  (A6),A5
                   MOVEA.L  A4,A0
90CA L090CA        MOVE.L   A5,-(A7)
                   JSR      $54F8(PC)
                   MOVEA.L  (A7)+,A5
                   MOVEA.L  A0,A4
                   BNE.S    L0914E
                   ADDQ.L   #1,D5
                   MOVE.W   0(A6,A1.L),0(A6,A5.L)
                   BLT.S    L09148
                   ADDQ.W   #4,A5
                   ADDQ.L   #2,BV.RIP(A6)
                   ADDQ.W   #2,A0
                   CMPI.W   #SYM.COM,-2(A6,A0.L)   ;comma symbol token ?
                   BEQ.S    L090CA
                   CMPI.W   #SYM.RBKT,-2(A6,A0.L)  ;right round bracket symbol tok
                   BNE.S    L0914C
                   LSL.L    #3,D4
                   MOVEA.L  BV.NTBAS(A6),A3
                   ADDA.L   D4,A3
                   CMPI.B   #3,0(A6,A3.L)
                   BNE.S    L09150
                   MOVE.B   1(A6,A3.L),D6
                   CMPI.B   #1,D6
                   BNE.S    L09126
                   MOVE.W   -4(A6,A5.L),D1
                   ADDQ.W   #1,D1
                   BCLR     #0,D1
                   MOVE.W   D1,-4(A6,A5.L)
                   BLE.S    L09148
                   MOVEQ    #2,D1
                   BRA.S    L09128
9126 L09126        MOVEQ    #1,D1
9128 L09128        MOVE.L   D5,D0
                   MOVEQ    #1,D2
912C L0912C        SUBQ.W   #4,A5
                   MOVE.W   D2,2(A6,A5.L)
                   SUBQ.L   #1,D0
                   BEQ.S    L09154
                   MOVE.L   D1,D3
                   MOVEQ    #1,D1
                   ADD.W    0(A6,A5.L),D3
                   MULU     D3,D2
                   MOVE.L   D2,D3
                   SWAP     D3
                   TST.W    D3
                   BEQ.S    L0912C
9148 L09148        MOVEQ    #ERR.OR,D0             ;signal "out of range"
                   RTS

914C L0914C        MOVEQ    #ERR.XP,D0             ;signal "error in expression"
914E L0914E        RTS

9150 L09150        MOVEQ    #ERR.BN,D0             ;signal "bad name"
                   RTS

9154 L09154        MOVEA.L  A0,A4
                   MOVE.L   4(A6,A3.L),D4
                   BLT.S    L0915E
                   BSR.S    L091CC
915E L0915E        MOVE.L   D5,D1
                   LSL.L    #2,D1
                   ADDQ.L   #6,D1
                   MOVE.L   A3,-(A7)
                   JSR      $4EF0(PC)
                   MOVEA.L  (A7)+,A3
                   MOVE.L   A0,D1
                   SUB.L    BV.VVBAS(A6),D1
                   MOVE.L   D1,4(A6,A3.L)
                   MOVE.L   A0,-(A7)
                   MOVE.W   D5,4(A6,A0.L)
                   ADDQ.W   #6,A0
917E L0917E        MOVE.L   0(A6,A5.L),0(A6,A0.L)
                   ADDQ.W   #4,A5
                   ADDQ.W   #4,A0
                   SUBQ.L   #1,D5
                   BGT.S    L0917E
                   MOVEA.L  (A6),A5
                   MOVEQ    #1,D1
                   ADD.W    0(A6,A5.L),D1
                   MULU     2(A6,A5.L),D1
                   SUBQ.B   #2,D6
                   BLT.S    L091AA
                   BEQ.S    L091A2
                   ADD.L    D1,D1
                   BRA.S    L091AA
91A2 L091A2        ADD.L    D1,D1
                   MOVE.L   D1,D0
                   ADD.L    D1,D1
                   ADD.L    D0,D1
91AA L091AA        MOVE.L   A3,-(A7)
                   JSR      $4EF0(PC)
                   MOVEA.L  (A7)+,A3
                   MOVE.L   A0,D2
                   SUB.L    BV.VVBAS(A6),D2
                   MOVEA.L  (A7)+,A2
                   MOVE.L   D2,0(A6,A2.L)
91BE L091BE        CLR.W    0(A6,A0.L)
                   ADDQ.W   #2,A0
                   SUBQ.L   #2,D1
                   BGT.S    L091BE
                   MOVEQ    #0,D0
                   RTS

91CC L091CC        MOVEA.L  BV.VVBAS(A6),A2
                   ADDA.L   D4,A2
                   MOVEQ    #1,D2
                   ADD.W    6(A6,A2.L),D2
                   MULU     8(A6,A2.L),D2
                   MOVE.B   D6,D1
                   SUBQ.B   #2,D1
                   BLT.S    L091F0
                   BEQ.S    L091E8
                   ADD.L    D2,D2
                   BRA.S    L091F0
91E8 L091E8        ADD.L    D2,D2
                   MOVE.L   D2,D1
                   ADD.L    D2,D2
                   ADD.L    D1,D2
91F0 L091F0        MOVE.L   D2,D1
                   MOVEA.L  BV.VVBAS(A6),A0
                   ADDA.L   0(A6,A2.L),A0
                   MOVE.L   A3,-(A7)
                   MOVE.L   A2,-(A7)
                   JSR      $50E2(PC)
                   MOVEA.L  (A7)+,A2
                   BSR.S    L0920A
                   MOVEA.L  (A7)+,A3
                   RTS

920A L0920A        MOVEQ    #0,D1
                   MOVE.W   4(A6,A2.L),D1
                   LSL.L    #2,D1
                   ADDQ.L   #6,D1
                   MOVEA.L  A2,A0
                   JMP      $50E2(PC)
                   MOVEQ    #0,D4
921C L0921C        JSR      L092B6(PC)
                   BGE.S    L09228
                   TST.B    BV.INLIN(A6)
                   BNE.S    L09272
9228 L09228        JSR      L09C30(PC)
                   BNE.S    L09272
                   JSR      L09B92(PC)
                   CMPI.B   #$81,D0                ;start of a keyword token ?
                   BNE.S    L0921C
                   ADDQ.W   #2,A4
                   CMPI.B   #3,D1
                   BNE.S    L0925A
                   JSR      L09020(PC)
                   BLT.S    L09256
                   TST.B    BV.INLIN(A6)
                   BNE.S    L09256
924C L0924C        JSR      L092B6(PC)
                   BLT.S    L09228
                   ADDQ.W   #2,A4
                   BRA.S    L0924C
9256 L09256        ADDQ.W   #1,D4
                   BRA.S    L0921C
925A L0925A        CMPI.B   #1,D1
                   BNE.S    L0921C
                   JSR      L09B92(PC)
                   CMPI.W   #KEY.IF,D1             ;IF keyword token ?
                   BNE.S    L0921C
                   TST.B    D4
                   BEQ.S    L09272
                   SUBQ.W   #1,D4
                   BRA.S    L0921C
9272 L09272        MOVEQ    #0,D0
                   RTS

                   JSR      L09B92(PC)
                   CMPI.W   #KEY.DEF,D1            ;DEFine keyword token ?
                   BEQ      L08EB8
                   MOVEQ    #6,D5
                   CMPI.W   #KEY.REP,D1            ;REPeat keyword token ?
                   BEQ.S    L09292
                   MOVEQ    #7,D5
                   CMPI.W   #KEY.FOR,D1            ;FOR keyword token ?
                   BNE.S    L092AE
9292 L09292        ADDQ.W   #2,A4
                   JSR      L09790(PC)
                   BNE.S    L092B0
                   CMP.B    D5,D1
                   BNE.S    L092B2
                   MOVE.W   BV.LINUM(A6),8(A6,A2.L)
                   MOVE.B   BV.STMNT(A6),$0B(A6,A2.L)
                   JMP      L099A0(PC)
92AE L092AE        MOVEQ    #0,D0                  ;signal "no errors"
92B0 L092B0        RTS

92B2 L092B2        MOVEQ    #ERR.NF,D0             ;signal "not found"
                   RTS

92B6 L092B6        MOVEQ    #0,D0
                   MOVE.W   0(A6,A4.L),D1
                   CMPI.W   #SYM.COL,D1            ;colon symbol token ?
                   BEQ.S    L092E0
                   CMPI.W   #SYM.LF,D1             ;linefeed symbol token ?
                   BEQ.S    L092DE
                   MOVEQ    #1,D0
                   CMPI.W   #KEY.THEN,D1           ;THEN keyword token ?
                   BEQ.S    L092E0
                   MOVEQ    #2,D0
                   CMPI.W   #KEY.ELSE,D1           ;ELSE keyword token ?
                   BEQ.S    L092E0
                   JSR      L0885E(PC)
                   BRA.S    L092B6
92DE L092DE        MOVEQ    #ERR.NC,D0             ;signal "not complete"
92E0 L092E0        RTS

   Message

92E2 L092E2        ORI.B    #$74,??
                   MOVEA.L  $696E(A4),A0

     L?????        BCS.S    L0930C
                   ST       BV.SING(A6)
                   BRA.S    L092F4

92F2 L092F2        MOVEQ    #-1,D0
92F4 L092F4        MOVEA.L  BV.CHBAS(A6),A0
                   MOVEA.L  0(A6,A0.L),A0
                   MOVE.W   #-1,BV.NXLIN(A6)
                   TST.B    BV.SING(A6)
                   BNE.S    L0934E
                   MOVE.L   D0,-(A7)
                   LEA      L092E2(PC),A1
                   JSR      $3A22(PC)
                   MOVEA.L  A0,A5
                   MOVEA.W  #$68,A1
                   MOVEA.L  (A6),A0
                   JSR      $3EC4(PC)
                   MOVE.B   #" ",0(A6,A0.L)
                   ADDQ.W   #1,D1
                   MOVEA.L  (A6),A1
                   MOVE.W   D1,D2
                   MOVEA.L  A5,A0
                   MOVEQ    #7,D0
                   MOVEQ    #-1,D3
                   TRAP     #4
                   TRAP     #3

                   MOVE.L   (A7)+,D0
9336 L09336        MOVE.W   BV.LINUM(A6),BV.CNLNO(A6)
                   MOVE.B   BV.STMNT(A6),BV.CNSTM(A6)
                   MOVE.B   BV.INLIN(A6),BV.CNINL(A6)
                   MOVE.W   BV.INDEX(A6),BV.CNIND(A6)
934E L0934E        JSR      $3872(PC)
                   MOVE.L   BV.RTP(A6),D0
                   SUB.L    BV.RTBAS(A6),D0
                   SNE      BV.UNRVL(A6)
                   MOVEQ    #-1,D0                 ;signal "no errors"
                   RTS

                   JSR      L09790(PC)
                   BNE      L093FA
                   MOVE.W   8(A6,A2.L),D4
                   BEQ.S    L09386
                   JSR      L09694(PC)
                   BNE.S    L09384
                   JSR      L09F42(PC)
                   BNE.S    L09384
                   MOVE.B   $0B(A6,A2.L),D4
                   JSR      L096FC(PC)
9384 L09384        BRA.S    L093F8
9386 L09386        MOVE.W   -2(A6,A4.L),D4
                   MOVEQ    #7,D5
                   SUB.B    D1,D5
938E L0938E        JSR      L092B6(PC)
                   BLT.S    L0939C
                   ADDQ.W   #2,A4
                   ADDQ.B   #1,BV.STMNT(A6)
                   BRA.S    L093BE
939C L0939C        TST.B    BV.INLIN(A6)
                   BEQ.S    L093B0
                   SF       BV.INLIN(A6)
                   MOVE.W   BV.LINUM(A6),D0
                   CMP.W    6(A6,A2.L),D0
                   BEQ.S    L093F8
93B0 L093B0        TST.B    BV.SING(A6)
                   BNE.S    L093F8
                   ADDQ.W   #2,A4
                   JSR      L09F42(PC)
                   BNE.S    L093F8
93BE L093BE        JSR      L09B92(PC)
                   CMPI.W   #KEY.END,D1            ;END keyword token ?
                   BNE.S    L0938E
                   ADDQ.W   #2,A4
                   JSR      L09B92(PC)
                   TST.B    D5
                   BEQ.S    L093DA
                   CMPI.W   #KEY.REP,D1            ;REPeat keyword token ?
                   BNE.S    L0938E
                   BRA.S    L093E0
93DA L093DA        CMPI.W   #KEY.FOR,D1            ;FOR keyword token ?
                   BNE.S    L0938E
93E0 L093E0        ADDQ.W   #2,A4
                   JSR      L09B92(PC)
                   CMP.W    2(A6,A4.L),D4
                   BNE.S    L0938E
                   MOVE.W   BV.LINUM(A6),8(A6,A2.L)
                   MOVE.B   BV.STMNT(A6),$0B(A6,A2.L)
93F8 L093F8        MOVEQ    #0,D0                  ;signal "no errors"
93FA L093FA        RTS

93FC L093FC        MOVEQ    #0,D5
93FE L093FE        BSR.S    L09444
                   BNE.S    L09454
                   JSR      L09B92(PC)
                   CMPI.B   #$81,D0
                   BNE.S    L093FE
                   ADDQ.W   #2,A4
                   CMPI.B   #1,D1
                   BNE.S    L09424
                   JSR      L09B92(PC)
                   CMPI.W   #KEY.SEL,D1            ;SELect keyword token ?
                   BNE.S    L093FE
                   SUBQ.W   #1,D5
                   BLT.S    L09454
                   BRA.S    L093FE
9424 L09424        CMPI.B   #5,D1
                   BNE.S    L093FE
                   JSR      L09020(PC)
                   BLT.S    L09436
                   TST.B    BV.INLIN(A6)
                   BEQ.S    L0943A
9436 L09436        ADDQ.W   #1,D5
                   BRA.S    L093FE
943A L0943A        JSR      L092B6(PC)
                   BLT.S    L093FE
                   ADDQ.W   #2,A4
                   BRA.S    L0943A
9444 L09444        JSR      L09C30(PC)
                   BNE.S    L09462
                   TST.B    D0
                   BEQ.S    L09454
                   TST.B    BV.INLIN(A6)
                   BNE.S    L09458
9454 L09454        MOVEQ    #0,D0                  ;signal "no errors"
                   RTS

9458 L09458        SUBQ.W   #8,A4
                   MOVE.W   2(A6,A4.L),D0
                   SUB.W    D0,BV.LNGTH(A6)
9462 L09462        TST.B    BV.INLIN(A6)
                   BGT.S    L0946C
                   SF       BV.INLIN(A6)
946C L0946C        MOVEQ    #1,D0
                   RTS

9470 L09470        MOVEQ    #0,D5
9472 L09472        JSR      L09444(PC)
                   BNE.S    L094EA
                   JSR      L09B92(PC)
                   CMPI.W   #SYM.EQ,D1             ;equals symbol token ?
                   BNE.S    L0948A
                   ADDQ.W   #2,A4
                   TST.B    D5
                   BEQ.S    L094EC
                   BRA.S    L09472
948A L0948A        CMPI.B   #$81,D0
                   BNE.S    L09472
                   CMPI.B   #$15,D1
                   BNE.S    L094B4
                   TST.B    D5
                   BNE.S    L09472
                   JSR      L09044(PC)
                   BLT.S    L09472
                   MOVEA.L  A4,A3
94A2 L094A2        SUBQ.W   #2,A3
                   CMPI.W   #NAM.W,0(A6,A3.L)      ;name token ?
                   BNE.S    L094A2
                   CMP.W    2(A6,A3.L),D4
                   BNE.S    L09472
                   BRA.S    L094EC
94B4 L094B4        CMPI.B   #5,D1
                   BNE.S    L094D4
                   JSR      L09020(PC)
                   BLT.S    L094C6
                   TST.B    BV.INLIN(A6)
                   BEQ.S    L094CA
94C6 L094C6        ADDQ.W   #1,D5
                   BRA.S    L09472
94CA L094CA        JSR      L092B6(PC)
                   BLT.S    L09472
                   ADDQ.W   #2,A4
                   BRA.S    L094CA
94D4 L094D4        CMPI.B   #1,D1
                   BNE.S    L09472
                   ADDQ.W   #2,A4
                   JSR      L09B92(PC)
                   CMPI.W   #KEY.SEL,D1            ;SELect keyword token ?
                   BNE.S    L09472
                   SUBQ.W   #1,D5
                   BGE.S    L09472
94EA L094EA        RTS

94EC L094EC        MOVEQ    #0,D0                  ;signal "no errors"
                   RTS

                   MOVEA.L  A4,A5
                   JSR      L09B92(PC)
                   MOVEQ    #0,D4
                   MOVE.W   2(A6,A4.L),D4
                   ADDQ.W   #4,A4
                   JSR      L09020(PC)
                   BLT.S    L0950E
                   MOVE.B   #1,BV.INLIN(A6)
                   MOVE.W   D4,BV.INDEX(A6)
950E L0950E        JSR      L09688(PC)
                   MOVE.B   0(A6,A2.L),D2
                   MOVEQ    #6,D1
                   SUBQ.B   #2,D2
                   BEQ.S    L0952A
                   MOVEQ    #12,D1
                   SUBQ.B   #4,D2
                   BEQ.S    L0952A
                   SUBQ.B   #1,D2
                   BEQ.S    L09552
                   MOVEQ    #-$0C,D0
                   RTS

952A L0952A        MOVE.L   A2,-(A7)
                   MOVE.L   4(A6,A2.L),D2
                   BLT.S    L0953C
                   MOVEA.L  BV.VVBAS(A6),A0
                   ADDA.L   D2,A0
                   JSR      $50E2(PC)
953C L0953C        MOVEQ    #$1A,D1
                   JSR      $4EF0(PC)
                   SUBA.L   BV.VVBAS(A6),A0
                   MOVEA.L  (A7)+,A2
                   MOVE.B   #7,0(A6,A2.L)
                   MOVE.L   A0,4(A6,A2.L)
9552 L09552        JSR      L09924(PC)
                   JSR      L09B92(PC)
                   MOVE.L   A4,D0
                   SUB.L    A5,D0
                   MOVE.L   D7,12(A6,A2.L)
                   MOVE.L   D7,$10(A6,A2.L)
                   MOVE.L   D7,$14(A6,A2.L)
                   MOVE.W   D0,$18(A6,A2.L)
                   JSR      L0957E(PC)
                   BGT.S    L09576
                   RTS

9576 L09576        MOVEQ    #0,D5
                   JMP      L0938E(PC)
                   BCHG     D0,D0
957E L0957E        MOVE.L   A4,-(A7)
                   MOVE.W   0(A6,A4.L),D1
                   JSR      L08E58(PC)
                   BNE.S    L0958E
                   MOVEQ    #1,D0
                   BRA.S    L0959C
958E L0958E        CMPI.W   #SYM.EQ,D1             ;equals symbol token ?
                   BEQ.S    L095A0
                   CMPI.W   #SYM.COM,D1            ;comma symbol token ?
                   BEQ.S    L095A0
                   MOVEQ    #ERR.OR,D0             ;signal "out of range"
959C L0959C        ADDQ.W   #4,A7
                   RTS

95A0 L095A0        ADDQ.W   #2,A4
                   MOVEA.L  A4,A0
                   MOVE.L   D4,D6
                   JSR      $54F4(PC)
                   MOVEA.L  A0,A4
                   BNE.S    L0959C
                   BSR      L09674
                   MOVE.W   0(A6,A1.L),0(A6,A2.L)
                   MOVE.L   2(A6,A1.L),2(A6,A2.L)
                   ADDQ.L   #6,BV.RIP(A6)
                   CMPI.W   #KEY.TO,0(A6,A4.L)     ; TO keyword token ?
                   BEQ.S    L095EA
                   MOVE.W   0(A6,A2.L),12(A6,A2.L)
                   MOVE.L   2(A6,A2.L),$0E(A6,A2.L)
                   MOVE.W   D7,$12(A6,A2.L)
                   MOVE.L   D7,$14(A6,A2.L)
                   MOVE.L   A4,D0
                   SUB.L    (A7)+,D0
                   ADD.W    D0,$18(A6,A2.L)
                   BRA      L0966C
95EA L095EA        ADDQ.W   #2,A4
                   MOVEA.L  A4,A0
                   JSR      $54F4(PC)
                   MOVEA.L  A0,A4
95F4 L095F4        BNE.S    L0959C
                   BSR.S    L09674
                   MOVE.W   0(A6,A1.L),12(A6,A2.L)
                   MOVE.L   2(A6,A1.L),$0E(A6,A2.L)
                   ADDQ.L   #6,BV.RIP(A6)
                   CMPI.W   #KEY.STEP,0(A6,A4.L)   ; STEP keyword token ?
                   BEQ.S    L09628
                   MOVE.B   #8,$12(A6,A2.L)
                   MOVE.B   $957C(PC),$13(A6,A2.L)
                   MOVE.L   D7,$14(A6,A2.L)
                   MOVE.B   $957D(PC),$14(A6,A2.L)
                   BRA.S    L09646
9628 L09628        ADDQ.W   #2,A4
                   MOVEA.L  A4,A0
                   JSR      $54F4(PC)
                   MOVEA.L  A0,A4
                   BNE.S    L095F4
                   BSR.S    L09674
                   MOVE.W   0(A6,A1.L),$12(A6,A2.L)
                   MOVE.L   2(A6,A1.L),$14(A6,A2.L)
                   ADDQ.L   #6,BV.RIP(A6)
9646 L09646        MOVE.L   A4,D0
                   SUB.L    (A7)+,D0
                   ADD.W    D0,$18(A6,A2.L)
                   JSR      $4F46(PC)
                   MOVEA.L  BV.RIP(A6),A1          ;point A1 at the top of the maths stack
                   SUBQ.W   #6,A1
                   MOVE.L   2(A6,A2.L),2(A6,A1.L)
                   MOVE.W   0(A6,A2.L),0(A6,A1.L)
                   JSR      L09A2A(PC)
                   BRA.S    L0966E
                   BRA.S    L09670
966C L0966C        MOVEQ    #0,D0                  ;signal "no errors"
966E L0966E        RTS

9670 L09670        BRA      L0957E
9674 L09674        MOVE.L   D6,D4
9676 L09676        BSR.S    L09688
                   MOVE.B   0(A6,A2.L),D1
                   MOVE.L   4(A6,A2.L),D0
                   MOVEA.L  BV.VVBAS(A6),A2
                   ADDA.L   D0,A2
                   RTS

9688 L09688        MOVE.L   D4,D0
                   MOVEA.L  BV.NTBAS(A6),A2
                   LSL.L    #3,D0
                   ADDA.W   D0,A2
                   RTS


;part51

9694 L09694        TST.B    BV.SING(A6)
                   BEQ.S    L096A0
                   MOVEA.L  BV.TKBAS(A6),A4
                   BRA.S    L096F8
96A0 L096A0        CMPI.W   #SYM.LF,0(A6,A4.L)
                   BEQ.S    L096AE
                   JSR      L0885E(PC)
                   BRA.S    L096A0
96AE L096AE        ADDQ.W   #2,A4
                   MOVEQ    #0,D1
                   MOVEQ    #0,D2
                   CMP.W    BV.LINUM(A6),D4
                   BLE.S    L096DE
96BA L096BA        CMPA.L   BV.PFP(A6),A4
                   BLT.S    L096C4
                   JMP      L09F6C(PC)
96C4 L096C4        CMP.W    4(A6,A4.L),D4
                   BLE.S    L096F8
96CA L096CA        MOVE.W   4(A6,A4.L),D2
                   MOVE.W   0(A6,A4.L),D1
                   ADDQ.W   #2,A4
                   ADD.W    D1,BV.LNGTH(A6)
                   ADDA.W   BV.LNGTH(A6),A4
                   BRA.S    L096BA
96DE L096DE        SUBA.W   BV.LNGTH(A6),A4
                   SUBQ.W   #2,A4
                   MOVE.W   0(A6,A4.L),D1
                   SUB.W    D1,BV.LNGTH(A6)
                   CMP.W    4(A6,A4.L),D4
                   BGT.S    L096CA
                   CMPA.L   BV.PFBAS(A6),A4
                   BGT.S    L096DE
96F8 L096F8        MOVEQ    #0,D0
                   RTS

96FC L096FC        CMP.B    BV.STMNT(A6),D4
                   BLE.S    L09710
                   JSR      L092B6(PC)
                   BLT.S    L09710
                   ADDQ.W   #2,A4
                   ADDQ.B   #1,BV.STMNT(A6)
                   BRA.S    L096FC
9710 L09710        MOVEQ    #0,D0
                   RTS

                   MOVEQ    #1,D4
                   BRA.S    L0972A
                   JSR      L09044(PC)
                   BGE      L093FC
                   BSR.S    L09778
                   MOVE.W   0(A6,A1.L),D4
                   BLE.S    L09774
                   ADDQ.W   #2,A4
972A L0972A        JSR      L09B92(PC)
                   CMPI.B   #$0B,D1
                   SEQ      D5
9734 L09734        MOVE.W   0(A6,A4.L),D1
                   JSR      L08E58(PC)
                   BEQ.S    L09774
                   ADDQ.W   #2,A4
                   BSR.S    L09778
                   BGT.S    L09734
                   SUBQ.W   #1,D4
                   BNE.S    L09734
                   MOVE.W   0(A6,A1.L),D4
                   TST.B    D5
                   BEQ      L08CB6
                   SF       BV.INLIN(A6)
                   TST.B    BV.SING(A6)
                   BEQ.S    L0976A
                   SF       BV.SING(A6)
                   MOVEA.L  BV.PFBAS(A6),A4
                   JSR      L09F42(PC)
                   BNE.S    L09770
976A L0976A        JSR      L09694(PC)
                   SUBQ.W   #2,A4
9770 L09770        MOVEQ    #0,D0
                   RTS

9774 L09774        MOVEQ    #-4,D0
                   RTS

9778 L09778        MOVEA.L  A4,A0
                   JSR      $54F8(PC)
                   MOVEA.L  A0,A4
                   BLT.S    L0978C
                   BGT.S    L0978A
                   ADDQ.L   #2,BV.RIP(A6)          ;restore the pointer to the maths stack
                   MOVEQ    #0,D0                  ;signal "no errors"
978A L0978A        RTS

978C L0978C        ADDQ.W   #4,A7
                   RTS

9790 L09790        JSR      L09B92(PC)
                   MOVEQ    #0,D4
                   MOVE.W   2(A6,A4.L),D4
                   ADDQ.W   #4,A4
979C L0979C        JSR      L09676(PC)
                   MOVEQ    #0,D0
                   MOVE.B   D1,D0
                   SUBQ.B   #6,D0
                   BEQ.S    L097AE
                   SUBQ.B   #1,D0
                   BEQ.S    L097AE
                   MOVEQ    #-7,D0
97AE L097AE        RTS

                   MOVEA.L  A4,A0
                   JSR      $54F4(PC)
                   MOVEA.L  A0,A4
                   BNE      L09842
                   JSR      L09020(PC)
                   BLT.S    L097CC
                   TST.B    BV.INLIN(A6)
                   BNE.S    L097CC
                   ST       BV.INLIN(A6)
97CC L097CC        ADDQ.L   #6,BV.RIP(A6)
                   TST.W    0(A6,A1.L)
                   BNE.S    L09840
                   MOVEQ    #0,D4
97D8 L097D8        JSR      L092B6(PC)
                   BGE.S    L097E4
                   TST.B    BV.INLIN(A6)
                   BNE.S    L09840
97E4 L097E4        JSR      L09C30(PC)
                   BNE.S    L09840
                   JSR      L09B92(PC)
                   CMPI.B   #KEY.B,D0
                   BNE.S    L097D8
                   ADDQ.W   #2,A4
                   CMPI.B   #3,D1
                   BNE.S    L09816
                   JSR      L09020(PC)
                   BLT.S    L09812
                   TST.B    BV.INLIN(A6)
                   BNE.S    L09812
9808 L09808        JSR      L092B6(PC)
                   BLT.S    L097E4
                   ADDQ.W   #2,A4
                   BRA.S    L09808
9812 L09812        ADDQ.W   #1,D4
                   BRA.S    L097D8
9816 L09816        CMPI.B   #1,D1
                   BNE.S    L0982E
                   JSR      L09B92(PC)
                   CMPI.W   #KEY.IF,D1
                   BNE.S    L097D8
                   TST.B    D4
                   BEQ.S    L09840
                   SUBQ.W   #1,D4
                   BRA.S    L097D8
982E L0982E        CMPI.B   #$14,D1
                   BNE.S    L097D8
                   TST.B    D4
                   BEQ.S    L0983E
                   ADDQ.B   #1,BV.STMNT(A6)
                   BRA.S    L097D8
983E L0983E        SUBQ.W   #2,A4
9840 L09840        MOVEQ    #0,D0
9842 L09842        RTS

    data from here...

                   DC.W     $F9F4
                   DC.W     $FC6E
                   DC.W     $FF2E
                   MOVEP.L  $05E2(A6),D2
                   BTST     D4,??
                   DC.W     $F7F2
                   ORI.B    #0,D0
                   DC.W     $FE92
                   ORI.B    #0,D0
                   ORI.B    #0,D0
                   ORI.B    #0,D0
                   BCLR     D2,$0116
                   DC.W     $FAE0
                   DC.W     $F998
                   DC.W     $FE96
                   DC.W     $F636
                   ORI.B    #$4A,D0
                   DC.W     $F812
                   ORI.L    #$D60000,(A6)+
                   ORI.B    #$4A,D0
                   ORI.L    #$70001036,(A6)+

   to here

                   AND.B    D1,D4
                   ADDQ.W   #2,A4
                   ADD.B    D0,D0
                   MOVE.W   L09842(PC,D0.W),D0
                   BEQ.S    L09896
                   JMP      L09882(PC,D0.W)
9896 L09896        MOVEQ    #-7,D0
                   RTS

989A L0989A        MOVEA.L  A2,A3
                   ANDI.B   #$0F,1(A6,A3.L)
                   MOVE.L   A3,-(A7)
                   MOVE.B   1(A6,A3.L),-(A7)
                   JSR      $737C(PC)
                   BNE.S    L0991C
                   CMPI.W   #SYM.LBKT,D1
                   BNE.S    L098E8
                   CMPI.B   #1,1(A6,A3.L)
                   BNE.S    L0991A
                   MOVE.L   4(A6,A3.L),D0
                   BLT.S    L0991A
                   MOVEA.L  BV.VVBAS(A6),A2
                   ADDA.L   D0,A2
                   MOVE.L   D0,-(A7)
                   LEA      2(A4),A0
                   JSR      $5EA0(PC)
                   MOVEA.L  A0,A4
                   MOVEA.L  BV.VVBAS(A6),A2
                   ADDA.L   (A7)+,A2
                   BNE.S    L0991C
                   JSR      L09B92(PC)
                   CMPI.W   #SYM.EQ,D1
                   BNE.S    L0991A
                   SF       (A7)
98E8 L098E8        CMPI.W   #SYM.EQ,D1
                   BNE.S    L0991A
                   ADDQ.W   #2,A4
                   MOVE.B   (A7),D0
                   MOVEA.L  A4,A0
                   SUBA.L   BV.VVBAS(A6),A2
                   MOVE.L   A2,-(A7)
                   JSR      $54FA(PC)
                   MOVEA.L  BV.VVBAS(A6),A2
                   ADDA.L   (A7)+,A2
                   MOVEA.L  A0,A4
                   BNE.S    L09914
                   MOVE.B   (A7)+,D0
                   MOVEA.L  (A7)+,A3
                   MOVE.B   D0,1(A6,A3.L)
                   JMP      $6C12(PC)
9914 L09914        BLT.S    L0991C
                   MOVEQ    #-$11,D0
                   BRA.S    L0991C
991A L0991A        MOVEQ    #-$0C,D0
991C L0991C        ADDQ.W   #6,A7
                   RTS

                   MOVEQ    #-$15,D0
                   RTS

9924 L09924        MOVEA.L  4(A6,A2.L),A2
                   ADDA.L   BV.VVBAS(A6),A2
                   MOVE.W   D7,0(A6,A2.L)
                   MOVE.L   D7,2(A6,A2.L)
                   MOVE.W   BV.LINUM(A6),D1
                   MOVE.B   BV.STMNT(A6),D0
                   CMP.W    6(A6,A2.L),D1
                   BNE.S    L09948
                   CMP.B    $0A(A6,A2.L),D0
                   BEQ.S    L09954
9948 L09948        MOVE.W   D1,6(A6,A2.L)
                   MOVE.L   D7,8(A6,A2.L)
                   MOVE.B   D0,$0A(A6,A2.L)
9954 L09954        MOVEQ    #0,D0
                   RTS

                   JSR      L09B92(PC)
                   CMPI.B   #NAM.W,D0
                   BNE.S    L09994
9962 L09962        MOVEQ    #0,D4
                   MOVE.W   2(A6,A4.L),D4
                   ADDQ.W   #4,A4
                   JSR      L09B92(PC)
                   JSR      L09688(PC)
                   MOVE.B   0(A6,A2.L),D0
                   CMPI.B   #3,D0
                   BEQ      L08BD2
                   CMPI.B   #8,D0
                   BEQ      L09D18
                   MOVEQ    #1,D5
                   CMPI.B   #4,D0
                   BEQ      L08CB6
                   JMP      L0989A(PC)
9994 L09994        MOVEQ    #-$13,D0
                   RTS

                   JSR      L09790(PC)
                   BLT      L09A28
99A0 L099A0        MOVE.L   D4,D6
                   CMPI.B   #6,D1
                   BEQ.S    L099FA
                   MOVE.L   A2,-(A7)
                   JSR      $4F46(PC)
                   MOVEA.L  (A7),A2
                   MOVEA.L  BV.RIP(A6),A1          ;point A1 at the top of the maths stack
                   SUBA.W   #12,A1
                   MOVE.L   $14(A6,A2.L),2(A6,A1.L)
                   BEQ.S    L09A04
                   MOVE.W   $12(A6,A2.L),0(A6,A1.L)
                   MOVE.W   0(A6,A2.L),6(A6,A1.L)
                   MOVE.L   2(A6,A2.L),8(A6,A1.L)
                   JSR      $48D2(PC)
                   BLT.S    L099FC
                   MOVE.L   A1,BV.RIP(A6)          ;restore the pointer to the maths stack
                   JSR      $4ACE(PC)
                   MOVEA.L  (A7),A2
                   BSR.S    L09A2A
                   BRA.S    L099FC
                   BRA.S    L09A00
                   MOVEA.L  (A7)+,A2
                   MOVE.W   0(A6,A0.L),0(A6,A2.L)
                   MOVE.L   2(A6,A0.L),2(A6,A2.L)
                   ADDQ.L   #6,BV.RIP(A6)
99FA L099FA        BRA.S    L09A0A
99FC L099FC        ADDQ.W   #4,A7
                   RTS

9A00 L09A00        ADDQ.L   #6,BV.RIP(A6)
9A04 L09A04        MOVEA.L  (A7)+,A2
                   MOVEQ    #1,D3
                   BRA.S    L09A0C
9A0A L09A0A        MOVEQ    #0,D3
9A0C L09A0C        BSR.S    L09A72
                   BNE.S    L09A28
                   TST.B    BV.INLIN(A6)
                   BGT.S    L09A1A
                   SF       BV.INLIN(A6)
9A1A L09A1A        CMPI.B   #$7F,BV.STMNT(A6)
                   BNE.S    L09A26
                   SF       BV.INLIN(A6)
9A26 L09A26        MOVEQ    #0,D0
9A28 L09A28        RTS

9A2A L09A2A        MOVE.L   A2,-(A7)
                   SUBQ.W   #6,A1
                   MOVE.L   $0E(A6,A2.L),2(A6,A1.L)
                   MOVE.W   12(A6,A2.L),0(A6,A1.L)
                   JSR      $48C4(PC)
                   MOVEA.L  (A7)+,A2
                   BLT.S    L09A70
                   MOVEQ    #$0D,D1
                   ADD.W    0(A6,A1.L),D1
                   CMP.W    $12(A6,A2.L),D1
                   BGT.S    L09A54
                   LEA      12(A2),A0
                   BRA.S    L09A6C
9A54 L09A54        MOVEA.L  BV.RIP(A6),A0          ;point A0 at the top of the maths stack
                   TST.B    2(A6,A1.L)
                   BLT.S    L09A66
                   TST.B    $14(A6,A2.L)
                   BLT.S    L09A6C
                   BRA.S    L09A6E
9A66 L09A66        TST.B    $14(A6,A2.L)
                   BLT.S    L09A6E
9A6C L09A6C        ADDQ.L   #2,(A7)
9A6E L09A6E        ADDQ.L   #2,(A7)
9A70 L09A70        RTS

9A72 L09A72        MOVE.B   BV.STMNT(A6),-(A7)
                   MOVE.L   BV.LINUM(A6),-(A7)
                   MOVE.L   A4,-(A7)
                   MOVE.W   6(A6,A2.L),D4
                   JSR      L09694(PC)
                   BNE.S    L09AD0
                   JSR      L09F46(PC)
                   BNE.S    L09AD0
                   MOVE.B   $0A(A6,A2.L),D4
                   JSR      L096FC(PC)
                   JSR      L09B92(PC)
                   CMPI.W   #KEY.FOR,D1
                   BEQ.S    L09AA4
                   CMPI.W   #KEY.REP,D1
                   BNE.S    L09AD0
9AA4 L09AA4        ADDQ.W   #2,A4
                   MOVEA.L  A4,A5
                   JSR      L09B92(PC)
                   CMP.W    2(A6,A4.L),D6
                   BNE.S    L09AD0
                   TST.B    D3
                   BEQ.S    L09ACA
                   MOVEA.L  A5,A4
                   ADDA.W   $18(A6,A2.L),A4
                   MOVE.L   D6,D4
                   JSR      L0957E(PC)
                   BLT.S    L09AD2
                   BEQ.S    L09ACA
                   MOVEQ    #0,D0
                   BRA.S    L09AD2
9ACA L09ACA        ADDA.W   #$0A,A7
                   RTS

9AD0 L09AD0        MOVEQ    #-7,D0
9AD2 L09AD2        MOVEA.L  (A7)+,A4
                   MOVE.L   (A7)+,BV.LINUM(A6)
                   MOVE.B   (A7)+,BV.STMNT(A6)
                   TST.L    D0
                   RTS

9AE0 L09AE0        MOVE.L   A4,-(A7)
                   MOVE.B   BV.SING(A6),D6
                   BEQ.S    L09AF2
                   MOVEA.L  BV.TKBAS(A6),A4
                   MOVEQ    #0,D5
                   BRA.S    L09B14
9AF0 L09AF0        SF       D6
9AF2 L09AF2        TST.B    BV.EDIT(A6)
                   SF       BV.EDIT(A6)
                   BEQ.S    L09B10
                   MOVEA.L  BV.PFBAS(A6),A4
9B00 L09B00        TST.B    D6
                   BNE.S    L09AF0
                   MOVE.W   4(A6,A4.L),D5
                   ADDQ.W   #6,A4
                   CMPA.L   BV.PFP(A6),A4
                   BLT.S    L09B14
9B10 L09B10        MOVEA.L  (A7)+,A4
                   RTS

9B14 L09B14        BSR.S    L09B92
                   CMPI.B   #NAM.W,D0
                   BEQ.S    L09B4C
                   CMPI.B   #KEY.B,D0
                   BNE.S    L09B82
                   ADDQ.W   #2,A4
                   CMPI.B   #$14,D1
                   BEQ.S    L09B14
                   CMPI.B   #2,D1
                   BNE.S    L09B34
                   BSR.S    L09B92
                   BRA.S    L09B5A
9B34 L09B34        CMPI.B   #4,D1
                   BNE.S    L09B44
                   BSR.S    L09B92
                   CMPI.B   #$88,D0
                   BNE.S    L09B82
                   BRA.S    L09B5A
9B44 L09B44        CMPI.B   #$1B,D1
                   BNE.S    L09B60
                   BSR.S    L09B92
9B4C L09B4C        MOVE.L   A4,D4
                   ADDQ.W   #4,A4
                   BSR.S    L09B92
                   CMPI.W   #SYM.EQ,D1
                   BNE.S    L09B82
                   MOVEA.L  D4,A4
9B5A L09B5A        MOVEQ    #2,D1
9B5C L09B5C        BSR.S    L09BA4
                   BRA.S    L09B82
9B60 L09B60        CMPI.B   #7,D1
                   BNE.S    L09B7A
                   BSR.S    L09B92
                   MOVE.W   D1,D4
                   ADDQ.W   #2,A4
                   BSR.S    L09B92
                   MOVEQ    #4,D1
                   CMPI.B   #8,D4
                   BEQ.S    L09B5C
                   MOVEQ    #5,D1
                   BRA.S    L09B5C
9B7A L09B7A        CMPI.B   #$19,D1
                   BNE.S    L09B82
                   BSR.S    L09BF0
9B82 L09B82        JSR      L092B6(PC)
                   BGE.S    L09B8E
                   ADDQ.W   #2,A4
                   BRA      L09B00
9B8E L09B8E        ADDQ.W   #2,A4
                   BRA.S    L09B14
9B92 L09B92        MOVE.W   0(A6,A4.L),D1
                   MOVE.B   0(A6,A4.L),D0
                   CMPI.B   #SPC.B,D0
                   BNE.S    L09BEE
                   JMP      L0885E(PC)
9BA4 L09BA4        MOVEQ    #0,D0
                   MOVE.W   2(A6,A4.L),D0
                   LSL.L    #3,D0
                   MOVEA.L  BV.NTBAS(A6),A0
                   ADDA.L   D0,A0
                   MOVE.B   0(A6,A0.L),D0
                   CMP.B    D0,D1
                   BEQ.S    L09BDE
                   SUBQ.B   #2,D0
                   BLT.S    L09BDE
                   BEQ.S    L09BCE
                   SUBQ.B   #1,D0
                   BEQ.S    L09BEE
                   SUBQ.B   #2,D0
                   BGT.S    L09BCE
                   CMPI.B   #4,D1
                   BGE.S    L09BDE
9BCE L09BCE        MOVEA.L  A0,A2
                   MOVEM.L  D1/A0,-(A7)
                   JSR      $51FA(PC)
                   MOVEM.L  (A7)+,D1/A0
                   BNE.S    L09BEE
9BDE L09BDE        MOVE.B   D1,0(A6,A0.L)
                   SUBQ.B   #4,D1
                   BEQ.S    L09BEA
                   SUBQ.B   #1,D1
                   BNE.S    L09BEE
9BEA L09BEA        MOVE.W   D5,4(A6,A0.L)
9BEE L09BEE        RTS

9BF0 L09BF0        MOVEQ    #0,D3
                   SUBQ.W   #2,A4
9BF4 L09BF4        MOVE.W   #NAM.W,D4
                   BSR.S    L09C02
                   BNE.S    L09C2E
                   MOVEQ    #3,D1
                   BSR.S    L09BA4
                   BRA.S    L09BF4
9C02 L09C02        MOVEQ    #0,D3
9C04 L09C04        JSR      L0885E(PC)
                   CMP.W    D4,D1
                   BNE.S    L09C12
                   TST.B    D3
                   BEQ.S    L09C2E
                   BRA.S    L09C04
9C12 L09C12        CMPI.W   #SYM.LBKT,D1
                   BNE.S    L09C1C
                   ADDQ.B   #1,D3
                   BRA.S    L09C04
9C1C L09C1C        CMPI.W   #SYM.RBKT,D1
                   BNE.S    L09C26
                   SUBQ.B   #1,D3
                   BRA.S    L09C04
9C26 L09C26        JSR      L08E58(PC)
                   BNE.S    L09C04
                   MOVEQ    #1,D1
9C2E L09C2E        RTS

9C30 L09C30        JSR      L092B6(PC)
                   BGE.S    L09C62
                   TST.B    BV.SING(A6)
                   BNE.S    L09C60
                   ADDQ.W   #2,A4
                   CMPA.L   BV.PFP(A6),A4
                   BLT.S    L09C48
                   JMP      L09F6C(PC)
9C48 L09C48        MOVE.W   0(A6,A4.L),D0
                   ADD.W    D0,BV.LNGTH(A6)
                   MOVE.W   4(A6,A4.L),BV.LINUM(A6)
                   MOVEQ    #1,D0
                   MOVE.B   D0,BV.STMNT(A6)
                   ADDQ.W   #6,A4
                   MOVEQ    #0,D1
9C60 L09C60        RTS

9C62 L09C62        ADDQ.W   #2,A4
                   ADDQ.B   #1,BV.STMNT(A6)
                   MOVEQ    #0,D0
                   RTS

9C6C L09C6C        JSR      L09B92(PC)
                   CMPI.W   #KEY.RMND,D1
                   BEQ.S    L09CF0
                   BSR.S    L09CAE
                   CMPI.W   #KEY.TO,0(A6,A4.L)
                   BEQ.S    L09C94
                   BSR.S    L09CF8
                   MOVE.W   0(A6,A1.L),D0
                   BEQ.S    L09CEC
                   ADDI.W   #$18,D0
                   SUB.W    -6(A6,A1.L),D0
                   BLE.S    L09CEC
                   BRA.S    L09CC8
9C94 L09C94        BSR.S    L09CF8
                   TST.B    2(A6,A1.L)
                   BGT.S    L09CC8
                   ADDQ.W   #2,A4
                   ADDQ.L   #6,BV.RIP(A6)
                   BSR.S    L09CAE
                   BSR.S    L09CF8
                   TST.B    2(A6,A1.L)
                   BLT.S    L09CC8
                   BRA.S    L09CEC
9CAE L09CAE        MOVEA.L  A4,A0
                   SUBA.L   BV.VVBAS(A6),A2
                   MOVE.L   A2,-(A7)
                   JSR      $54F4(PC)
                   MOVEA.L  BV.VVBAS(A6),A2
                   ADDA.L   (A7)+,A2
                   MOVEA.L  A0,A4
                   BEQ.S    L09CF6
                   ADDQ.W   #4,A7
                   RTS

9CC8 L09CC8        ADDQ.L   #6,BV.RIP(A6)
9CCC L09CCC        MOVE.W   0(A6,A4.L),D0
                   CMPI.W   #SYM.COM,D0
                   BNE.S    L09CDA
                   ADDQ.W   #2,A4
                   BRA.S    L09C6C
9CDA L09CDA        CMPI.W   #SYM.LF,D0
                   BEQ.S    L09CF4
                   CMPI.W   #SYM.COL,D0
                   BEQ.S    L09CF4
                   JSR      L0885E(PC)
                   BRA.S    L09CCC
9CEC L09CEC        ADDQ.L   #6,BV.RIP(A6)
9CF0 L09CF0        MOVEQ    #0,D0
                   RTS

9CF4 L09CF4        MOVEQ    #-1,D0
9CF6 L09CF6        RTS

9CF8 L09CF8        SUBQ.W   #6,A1
                   MOVE.L   2(A6,A2.L),2(A6,A1.L)
                   MOVE.W   0(A6,A2.L),0(A6,A1.L)
                   JSR      $48C4(PC)
                   BEQ.S    L09D0E
                   ADDQ.W   #4,A7
9D0E L09D0E        RTS

9D10 L09D10        MOVEA.L  BV.TKPOS(A6),A4
                   MOVEA.L  BV.PTEMP(A6),A2
9D18 L09D18        SF       BV.UNDO(A6)
                   MOVE.L   A4,BV.TKPOS(A6)
                   MOVE.L   A2,BV.PTEMP(A6)
                   MOVE.L   4(A6,A2.L),D4
                   MOVEA.L  A4,A0
                   MOVE.L   BV.NTP(A6),D0
                   SUB.L    BV.NTBAS(A6),D0
                   MOVE.L   D0,-(A7)
                   JSR      $5BB4(PC)
                   BNE.S    L09D46
                   MOVE.W   0(A6,A0.L),D1
                   JSR      L08E58(PC)
                   BEQ.S    L09D54
                   MOVEQ    #-$0F,D0
9D46 L09D46        MOVE.L   BV.NTBAS(A6),D1
                   ADD.L    (A7)+,D1
                   MOVE.L   D1,BV.NTP(A6)
                   TST.L    D0
                   RTS

9D54 L09D54        MOVE.L   A5,D0
                   SUB.L    BV.NTBAS(A6),D0
                   MOVE.L   D0,-(A7)
                   MOVEA.L  A0,A4
                   MOVEA.L  BV.NTBAS(A6),A3
                   ADDA.L   4(A7),A3
                   MOVEA.L  D4,A2
                   MOVEA.L  BV.RIP(A6),A1          ;point A1 at the top of the maths stack
                   SUBA.L   BV.RIBAS(A6),A1
                   MOVEM.L  D5-7/A1/A4,-(A7)
                   MOVE.L   BV.LINUM(A6),-(A7)
                   MOVE.B   BV.STMNT(A6),-(A7)
                   MOVE.L   BV.INLIN(A6),-(A7)
                   JSR      (A2)
                   MOVE.L   D0,D2
                   MOVE.L   (A7)+,BV.INLIN(A6)
                   MOVE.B   (A7)+,BV.STMNT(A6)
                   MOVE.L   (A7)+,BV.LINUM(A6)
                   MOVEM.L  (A7)+,D5-7/A1/A4
                   ADDA.L   BV.RIBAS(A6),A1
                   MOVE.L   A1,BV.RIP(A6)          ;restore the pointer to the maths stack
                   MOVEA.L  BV.NTBAS(A6),A5
                   MOVEA.L  A5,A3
                   ADDA.L   (A7)+,A5
                   ADDA.L   (A7)+,A3
                   JSR      $5178(PC)
                   MOVE.L   D2,D0
                   TST.B    BV.UNDO(A6)
                   BNE      L08FB0
                   RTS

9DB6 L09DB6        MOVE.B   #$7F,BV.STMNT(A6)
                   MOVEQ    #0,D4
                   MOVE.W   BV.INDEX(A6),D4
                   JSR      L0979C(PC)
                   BGE      L099A0
                   RTS

                   MOVEQ    #0,D0
                   RTS

                   JSR      L09B92(PC)
                   CMPI.B   #$88,D0
                   BNE.S    L09E0A
                   MOVEQ    #0,D4
                   MOVE.W   2(A6,A4.L),D4
                   ADDQ.W   #4,A4
                   JSR      L09020(PC)
                   BLT.S    L09DF2
                   MOVE.B   #1,BV.INLIN(A6)
                   MOVE.W   D4,BV.INDEX(A6)
9DF2 L09DF2        JSR      L09688(PC)
                   MOVE.B   0(A6,A2.L),D2
                   MOVEQ    #6,D1
                   SUBQ.B   #2,D2
                   BEQ.S    L09E0E
                   SUBQ.B   #4,D2
                   BEQ.S    L09E36
                   MOVEQ    #$1A,D1
                   SUBQ.B   #1,D2
                   BEQ.S    L09E0E
9E0A L09E0A        MOVEQ    #-$0C,D0
                   RTS

9E0E L09E0E        MOVE.L   A2,-(A7)
                   MOVE.L   4(A6,A2.L),D2
                   BLT.S    L09E20
                   MOVEA.L  BV.VVBAS(A6),A0
                   ADDA.L   D2,A0
                   JSR      $50E2(PC)
9E20 L09E20        MOVEQ    #12,D1
                   JSR      $4EF0(PC)
                   SUBA.L   BV.VVBAS(A6),A0
                   MOVEA.L  (A7)+,A2
                   MOVE.L   A0,4(A6,A2.L)
                   MOVE.B   #6,0(A6,A2.L)
9E36 L09E36        JMP      L09924(PC)
                   CLR.W    BV.DALNO(A6)
                   MOVEA.L  A4,A0
                   JSR      $54F8(PC)
                   MOVEA.L  A0,A4
                   BLT.S    L09E62
                   BGT.S    L09E54
                   ADDQ.L   #2,BV.RIP(A6)
                   MOVE.W   0(A6,A1.L),BV.DALNO(A6)
9E54 L09E54        MOVE.B   #1,BV.DASTM(A6)
                   MOVE.B   #1,BV.DAITM(A6)
                   MOVEQ    #0,D0
9E62 L09E62        RTS

                   JSR      L09B92(PC)
                   CMPI.W   #KEY.ON,D1
                   BNE.S    L09E74
                   ADDQ.W   #2,A4
                   JSR      L09B92(PC)
9E74 L09E74        MOVEQ    #0,D4
                   MOVE.W   2(A6,A4.L),D4
                   ADDQ.W   #4,A4
                   JSR      L09676(PC)
                   TST.L    D0
                   BLT.S    L09EB2
                   JSR      L09020(PC)
                   BLT.S    L09EA2
                   TST.B    BV.INLIN(A6)
                   BNE.S    L09E94
                   ST       BV.INLIN(A6)
9E94 L09E94        JSR      L09B92(PC)
                   CMPI.W   #SYM.EQ,D1
                   BNE.S    L09EA2
                   ADDQ.W   #2,A4
                   BRA.S    L09EA8
9EA2 L09EA2        JSR      L09470(PC)
                   BNE.S    L09EAE
9EA8 L09EA8        JSR      L09C6C(PC)
                   BLT.S    L09EA2
9EAE L09EAE        MOVEQ    #0,D0
                   RTS

9EB2 L09EB2        MOVEQ    #-$11,D0
                   RTS

9EB6 L09EB6        MOVEA.L  BV.PFBAS(A6),A4
                   SF       BV.INLIN(A6)
                   TST.B    BV.SING(A6)
                   BNE.S    L09EC8
9EC4 L09EC4        BSR.S    L09F42
                   BNE.S    L09F08
9EC8 L09EC8        MOVEQ    #1,D0
                   JSR      $4F2C(PC)
                   MOVEQ    #0,D0
9ED0 L09ED0        JSR      L09B92(PC)
                   CMPI.B   #KEY.B,D0
                   BNE.S    L09EE0
                   JSR      L09882(PC)
                   BRA.S    L09EFA
9EE0 L09EE0        CMPI.B   #$88,D0                ;name token ?
                   BNE.S    L09EEC
                   JSR      L09962(PC)
                   BRA.S    L09EFA
9EEC L09EEC        CMPI.B   #SYM.B,D0
                   BNE.S    L09EF8
                   JSR      L0A1AE(PC)
                   BRA.S    L09EFA
9EF8 L09EF8        MOVEQ    #-$13,D0
9EFA L09EFA        TST.L    D0
                   BNE      L092F4
                   TAS      BV.BRK(A6)
                   BEQ      L092F2
9F08 L09F08        TAS      BV.CONT(A6)
                   BEQ      L09F92
                   TST.B    BV.SING(A6)
                   BNE.S    L09F1C
                   CMPA.L   BV.PFBAS(A6),A4
                   BLE.S    L09EB6
9F1C L09F1C        JSR      L092B6(PC)
                   BGE.S    L09F3A
                   TST.B    BV.INLIN(A6)
                   BLE.S    L09F2E
                   JSR      L09DB6(PC)
                   BRA.S    L09EFA
9F2E L09F2E        TST.B    BV.SING(A6)
                   ADDQ.W   #2,A4
                   BEQ.S    L09EC4
                   BSR.S    L09F70
                   BRA.S    L09F68
9F3A L09F3A        ADDQ.W   #2,A4
                   ADDQ.B   #1,BV.STMNT(A6)
                   BRA.S    L09EC8
9F42 L09F42        SF       BV.INLIN(A6)
9F46 L09F46        TST.B    BV.SING(A6)
                   BNE.S    L09F62
                   CMPA.L   BV.PFP(A6),A4
                   BGE.S    L09F6C
                   MOVE.W   0(A6,A4.L),D0
                   ADD.W    D0,BV.LNGTH(A6)
                   MOVE.W   4(A6,A4.L),BV.LINUM(A6)
                   ADDQ.W   #6,A4
9F62 L09F62        MOVE.B   #1,BV.STMNT(A6)
9F68 L09F68        MOVEQ    #0,D0
                   RTS

9F6C L09F6C        SF       BV.CONT(A6)
9F70 L09F70        MOVE.W   #$FFFF,BV.NXLIN(A6)
                   MOVE.W   #4,BV.STOPN(A6)
                   RTS

   data from here ...

9F7E LO9F7E        DC.W     $0032                  ;9FC4
                   DC.W     $010E                  ;A0A0
                   DC.W     $0200                  ;A192
                   DC.W     $009E                  ;A030
                   DC.W     $010E
                   DC.W     $010E
                   DC.W     $0208                  ;A19A
                   DC.W     $0208
                   DC.W     $01D8                  ;A14A
                   DC.W     $010C                  ;A09E

9F92 L09F92        MOVE.W   BV.STOPN(A6),D1
                   MOVE.W   L09F7E(PC,D1.W),D1
                   JMP      L09F92(PC,D1.W)
                   JSR      L092F4(PC)
                   MOVEA.L  BV.RTP(A6),A0
                   SF       BV.AUTO(A6)
9FAA L09FAA        CMPA.L   BV.RTBAS(A6),A0
                   BLE.S    L09FCE
                   MOVE.B   -8(A6,A0.L),D0
                   BEQ.S    L09FC0
                   MOVE.L   -$18(A6,A0.L),BV.NTP(A6)
                   SUBA.W   #$10,A0
9FC0 L09FC0        SUBQ.W   #8,A0
                   BRA.S    L09FAA
9FC4 L09FC4        TST.B    BV.UNRVL(A6)
                   BEQ.S    L09FCE
                   JSR      L08FB0(PC)
9FCE L09FCE        BSR      L0A05A
                   JSR      $513C(PC)
                   MOVEA.L  BV.NTBAS(A6),A0
9FDA L09FDA        MOVE.B   0(A6,A0.L),D0
                   SUBQ.B   #1,D0
                   BEQ.S    L0A01C
                   SUBQ.B   #3,D0
                   BLT.S    L09FEE
                   SUBQ.B   #2,D0
                   BLT.S    L0A024
                   SUBQ.B   #2,D0
                   BGE.S    L0A024
9FEE L09FEE        MOVE.W   2(A6,A0.L),D0
                   BLT.S    L0A01C
                   BSR      L0A090
                   MOVE.B   -1(A6,A1.L),D0
                   MOVEQ    #1,D1
                   SUBI.B   #$25,D0
                   BLT.S    L0A00A
                   BGT.S    L0A008
                   ADDQ.W   #1,D1
A008 L0A008        ADDQ.W   #1,D1
A00A L0A00A        MOVE.B   D1,1(A6,A0.L)
                   MOVE.B   D7,0(A6,A0.L)
                   MOVE.L   #$FFFFFFFF,4(A6,A0.L)
                   BRA.S    L0A024
A01C L0A01C        MOVE.L   D7,0(A6,A0.L)
                   MOVE.L   D7,4(A6,A0.L)
A024 L0A024        ADDQ.W   #8,A0
                   CMPA.L   BV.NTP(A6),A0
                   BLT.S    L09FDA
                   ST       BV.EDIT(A6)
A030 L0A030        TST.B    BV.UNRVL(A6)
                   BEQ.S    L0A052
                   MOVE.W   BV.NXLIN(A6),BV.PTEMP(A6)
                   MOVE.W   BV.STOPN(A6),BV.PTEMP+2(A6)
                   JSR      L08FB0(PC)
                   MOVE.W   BV.PTEMP(A6),BV.NXLIN(A6)
                   MOVE.W   BV.PTEMP+2(A6),BV.STOPN(A6)
A052 L0A052        JSR      L09AE0(PC)
                   BRA      L0A1A4

Ú------------------------------------------------------------------------------¿
³=                                                                             ³
------------------------------------------------------------------------------
³JOB:                                                                          ³
------------------------------------------------------------------------------
³ENTRY:       D7.L     = 0                                                     ³
³                                                                              ³
³EXIT:        A?.L                                                             ³
³                                                                              ³
³ERRORS:      none                                                             ³
À------------------------------------------------------------------------------Ù

   Reclaim all the memory used by the SuperBASIC tables and stacks.

A05A L0A05A        MOVE.L   D7,BV.DALNO(A6)        ;set current DATA line number to zero
                   MOVE.B   #1,BV.DAITM(A6)        ;and the current DATA item number to be the first
                   MOVE.L   BV.VVBAS(A6),BV.VVP(A6);clear out the variable value area
                   MOVE.L   BV.RTBAS(A6),BV.RTP(A6);and clear out the return stack

   Set D0 to the offset to the last of the stack pointer SuperBASIC system variables
   from the start of the system variables and scan back through the pointers,
   resetting each one in turn.

                   MOVEQ    #BV.RIP,D0             ;the last of the SuperBASIC stack pointers
A072 L0A072        MOVE.L   BV.RIBAS(A6),0(A6,D0.W);reset it
                   SUBQ.W   #4,D0                  ;point at the previous pointer in the list
                   CMPI.B   #BV.BTP,D0             ;has the first of the stack pointers been reached ?
                   BGE.S    L0A072                 ;reset the previous pointer if not
                   SF       BV.UNRVL(A6)           ;otherwise signal "need to unravel stack"
                   MOVE.L   D7,BV.VVFRE(A6)        ;set first free space in variable value table
                   JSR      $5098(PC)              ;reclaim the spare space above the return stack
                   JMP      $5090(PC)              ;reclaim the spare space above the variable value area

Ú------------------------------------------------------------------------------¿
³=                                                                             ³
------------------------------------------------------------------------------
³JOB:                                                                          ³
------------------------------------------------------------------------------
³ENTRY:       D0.W     offset to the name from the start of the name list      ³
³                                                                              ³
³EXIT:        A1.L     relative pointer to the next name in the name list      ³
³                                                                              ³
³ERRORS:      none                                                             ³
À------------------------------------------------------------------------------Ù

   Point A1 at the name after a name in the name list given the offset to the name
   in D0.W.

A090 L0A090        MOVEA.L  BV.NLBAS(A6),A1        ;point A1 at the start of the name list
                   ADDA.W   D0,A1                  ;add offset into list to required name
                   MOVEQ    #1,D0
                   ADD.B    0(A6,A1.L),D0          ;get the length of the name
                   ADDA.W   D0,A1                  ;and point A1 at the next name in the list
A09E L0A09E        RTS

Ú------------------------------------------------------------------------------¿
³=                                                                             ³
------------------------------------------------------------------------------
³JOB:                                                                          ³
------------------------------------------------------------------------------
³ENTRY:       D7.L                                                             ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

   Close all the channels bar the first three and redraw the screen as for a "NEW".

A0A0 L0A0A0        MOVEA.L  BV.CHP(A6),A3          ;SuperBASIC channel table running pointer
                   MOVEA.L  BV.CHBAS(A6),A2        ;start of channel table
                   ADDA.W   #3*CH.LENCH,A2         ;step past the first three channels
                   MOVE.L   A2,BV.CHP(A6)          ;and update the running pointer
A0B0 L0A0B0        CMPA.L   A3,A2                  ;has the end of the channel table been reached ?
                   BGE.S    L0A0C6                 ;jump forward to redraw the screen if so
                   MOVE.L   CH.ID(A6,A2.L),D0      ;otherwise get the QDOS channel ID for the channel
                   BLT.S    L0A0C0                 ;and try the next channel if this channel is unused
                   MOVEA.L  D0,A0                  ;get the channel ID ready for the TRAP
                   MOVEQ    #IO.CLOSE,D0           ;TRAP to close a channel
                   TRAP     #2                     ;close it

A0C0 L0A0C0        ADDA.W   #CH.LENCH,A2           ;point at the next channel block
                   BRA.S    L0A0B0                 ;and check the channel

   Read the display mode and type and redaw the screen.

A0C6 L0A0C6        MOVEQ    #MT.DMODE,D0           ;TRAP to read or set the display mode
                   MOVEQ    #-1,D1                 ;signal "return display mode"
                   MOVEQ    #-1,D2                 ;signal "return display type"
                   TRAP     #1                     ;and read them

   D1 now contains the display mode and D2 the display type.

                   MOVEQ    #MT.DMODE,D0           ;TRAP to read or set the display mode
                   TRAP     #1                     ;set it to redraw the screen

   Reset the running pointer to the line number table to point to the start of
   the table in order to clear it. Then do the same for the program file running
   pointer. This has the effect of clearing out the basic program without reclaiming
   the space used by the old one.

                   MOVE.L   BV.LNBAS(A6),BV.LNP(A6);reset the line number table running pointer
                   CLR.W    BV.LSBAS(A6)           ;and signal "no current statement"
                   BSR      L0A05A                 ;reclaim the memory used by the stacks and tables
                   MOVE.L   BV.PFBAS(A6),BV.PFP(A6);and clear out the program file

                   MOVEQ    #0,D0
                   MOVEQ    #0,D5
                   MOVEA.L  BV.NTBAS(A6),A0        ;point A0 at the start of the name table
                   MOVEQ    #8,D1                  ;and set D1 to the length of one entry
A0F0 L0A0F0        CMPA.L   BV.NTP(A6),A0          ;end of name table reached ?
                   BEQ.S    L0A148                 ;jump forward if so
                   CMP.B    NTB.TYPE(A6,A0.L),D1
                   BGT.S    L0A106
                   TST.B    D5
                   BNE.S    L0A114
                   MOVE.W   NTB.OFFN(A6,A0.L),D0   ;get the offset to the name in the name list
                   BRA.S    L0A144

A106 L0A106        TST.B    D5
                   BNE.S    L0A144
                   MOVEA.L  A0,A2                  ;move pointer 
                   BSR.S    L0A090                 ;point past this variable's name
                   MOVEA.L  A1,A3
                   ST       D5
                   BRA.S    L0A144

A114 L0A114        MOVE.L   NTB.TYPE(A6,A0.L),0(A6,A2.L)
                   MOVE.L   NTB.OFFV(A6,A0.L),4(A6,A2.L)
                   MOVE.W   2(A6,A2.L),D0
                   BSR      L0A090
                   SUBA.W   D0,A1
                   MOVE.L   A3,D2
                   SUB.L    BV.NLBAS(A6),D2
                   MOVE.W   D2,2(A6,A2.L)
                   ADDQ.W   #8,A2

   Copy D0 words at (A1.L) to (A3.L)

A136 L0A136        MOVE.B   0(A6,A1.L),0(A6,A3.L)
                   ADDQ.W   #1,A1
                   ADDQ.W   #1,A3
                   SUBQ.W   #1,D0
                   BGT.S    L0A136

A144 L0A144        ADDQ.W   #8,A0
                   BRA.S    L0A0F0

A148 L0A148        TST.B    D5
A14A L0A14A        BEQ.S    L0A154
                   MOVE.L   A2,BV.NTP(A6)
                   MOVE.L   A3,BV.NLP(A6)
A154 L0A154        JSR      CA_RECHP(PC)           ;reclaim space above channel table
                   JSR      CA_RENLP(PC)           ;reclaim space above name list
                   JSR      CA_RENTP(PC)           ;reclaim space above name table
                   JSR      CA_REPFP(PC)           ;reclaim space above program file
                   JSR      $513C(PC)
                   BRA.S    L0A18C

                   CLR.W    BV.STOPN(A6)
                   MOVE.W   BV.CNLNO(A6),BV.NXLIN(A6)
                   MOVE.B   BV.CNSTM(A6),BV.NXSTM(A6)
                   MOVE.W   #$FFFF,BV.CNLNO(A6)
                   MOVE.B   BV.CNINL(A6),BV.INLIN(A6)
                   MOVE.W   BV.CNIND(A6),BV.INDEX(A6)
A18C L0A18C        SF       BV.COMLN(A6)
                   BRA.S    L0A1AA

A192 L0A192        MOVEQ    #0,D0
                   JSR      L09336(PC)
                   BRA.S    L0A1AA

A19A L0A19A        TST.B    BV.UNRVL(A6)
                   BEQ.S    L0A1A4
                   JSR      L08FB0(PC)
A1A4 L0A1A4        MOVE.B   BV.SING(A6),BV.COMLN(A6)
A1AA L0A1AA        MOVEQ    #0,D0
                   RTS

A1AE L0A1AE        CMPI.W   #SYM.EQ,D1
                   BNE.S    L0A1BA
                   ADDQ.W   #2,A4
                   JMP      L093FC(PC)
A1BA L0A1BA        MOVEQ    #0,D0
                   RTS

A1BE L0A1BE        MOVEQ    #-$13,D0
                   RTS

2.25 Fonts.

   Default font for characters 32 to 127

A1C2 FONT_1        DC.B     %00011111
                   DC.B     %01100000
                   DC.B     %01010100
                   DC.B     %00101000
                   DC.B     %01010100
                   DC.B     %00101000
                   DC.B     %01010100
                   DC.B     %00101000
                   DC.B     %01010100
                   DC.B     %00101000
                   DC.B     %01010100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00101000
                   DC.B     %00101000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00101000
                   DC.B     %00101000
                   DC.B     %01111100
                   DC.B     %00101000
                   DC.B     %01111100
                   DC.B     %00101000
                   DC.B     %00101000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111000
                   DC.B     %01010000
                   DC.B     %01010000
                   DC.B     %00111000
                   DC.B     %00010100
                   DC.B     %00010100
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01100100
                   DC.B     %01100100
                   DC.B     %00001000
                   DC.B     %00010000
                   DC.B     %00100000
                   DC.B     %01001100
                   DC.B     %01001100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00100000
                   DC.B     %01010000
                   DC.B     %01010000
                   DC.B     %00100000
                   DC.B     %01010100
                   DC.B     %01001000
                   DC.B     %00110100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000100
                   DC.B     %00001000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00001000
                   DC.B     %00000100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01000000
                   DC.B     %00100000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00100000
                   DC.B     %01000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %01010100
                   DC.B     %00111000
                   DC.B     %00010000
                   DC.B     %00111000
                   DC.B     %01010100
                   DC.B     %00010000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %01111100
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00011000
                   DC.B     %00011000
                   DC.B     %00001000
                   DC.B     %00010000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01111100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00011000
                   DC.B     %00011000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000100
                   DC.B     %00000100
                   DC.B     %00001000
                   DC.B     %00010000
                   DC.B     %00100000
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01001100
                   DC.B     %01010100
                   DC.B     %01100100
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00110000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %00000100
                   DC.B     %00001000
                   DC.B     %00010000
                   DC.B     %00100000
                   DC.B     %01111100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %00000100
                   DC.B     %00011000
                   DC.B     %00000100
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00001000
                   DC.B     %00011000
                   DC.B     %00101000
                   DC.B     %01001000
                   DC.B     %01111100
                   DC.B     %00001000
                   DC.B     %00001000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01111100
                   DC.B     %01000000
                   DC.B     %01111000
                   DC.B     %00000100
                   DC.B     %00000100
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00011000
                   DC.B     %00100000
                   DC.B     %01000000
                   DC.B     %01111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01111100
                   DC.B     %00000100
                   DC.B     %00001000
                   DC.B     %00010000
                   DC.B     %00100000
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00111100
                   DC.B     %00000100
                   DC.B     %00001000
                   DC.B     %00110000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00011000
                   DC.B     %00011000
                   DC.B     %00000000
                   DC.B     %00011000
                   DC.B     %00011000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00011000
                   DC.B     %00011000
                   DC.B     %00000000
                   DC.B     %00011000
                   DC.B     %00011000
                   DC.B     %00001000
                   DC.B     %00010000
                   DC.B     %00000100
                   DC.B     %00001000
                   DC.B     %00010000
                   DC.B     %00100000
                   DC.B     %00010000
                   DC.B     %00001000
                   DC.B     %00000100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01111100
                   DC.B     %00000000
                   DC.B     %01111100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01000000
                   DC.B     %00100000
                   DC.B     %00010000
                   DC.B     %00001000
                   DC.B     %00010000
                   DC.B     %00100000
                   DC.B     %01000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %00000100
                   DC.B     %00001000
                   DC.B     %00010000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01001100
                   DC.B     %01010100
                   DC.B     %01001100
                   DC.B     %01000000
                   DC.B     %00110000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01111100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01111100
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %01111000
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %01111100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01111100
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %01111000
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %01001100
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01111100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000100
                   DC.B     %00000100
                   DC.B     %00000100
                   DC.B     %00000100
                   DC.B     %00000100
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01000100
                   DC.B     %01001000
                   DC.B     %01010000
                   DC.B     %01100000
                   DC.B     %01010000
                   DC.B     %01001000
                   DC.B     %01000100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %01111100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01000100
                   DC.B     %01101100
                   DC.B     %01010100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01100100
                   DC.B     %01010100
                   DC.B     %01001100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01111000
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01010100
                   DC.B     %01001000
                   DC.B     %00110100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01111000
                   DC.B     %01010000
                   DC.B     %01001000
                   DC.B     %01000100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01000000
                   DC.B     %00111000
                   DC.B     %00000100
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01111100
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00101000
                   DC.B     %00010000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01010100
                   DC.B     %01010100
                   DC.B     %00101000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00101000
                   DC.B     %00010000
                   DC.B     %00101000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00101000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01111100
                   DC.B     %00000100
                   DC.B     %00001000
                   DC.B     %00010000
                   DC.B     %00100000
                   DC.B     %01000000
                   DC.B     %01111100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00011100
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00011100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %00100000
                   DC.B     %00010000
                   DC.B     %00001000
                   DC.B     %00000100
                   DC.B     %00000100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01110000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %01110000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00101000
                   DC.B     %01000100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01111100
                   DC.B     %00000000
                   DC.B     %00011000
                   DC.B     %00100100
                   DC.B     %00100000
                   DC.B     %01110000
                   DC.B     %00100000
                   DC.B     %00100000
                   DC.B     %01111100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00110100
                   DC.B     %01001100
                   DC.B     %01000100
                   DC.B     %01001100
                   DC.B     %00110100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %01111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111100
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %00111100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000100
                   DC.B     %00000100
                   DC.B     %00111100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00111100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01111100
                   DC.B     %01000000
                   DC.B     %00111100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00011000
                   DC.B     %00100100
                   DC.B     %00100000
                   DC.B     %01110000
                   DC.B     %00100000
                   DC.B     %00100000
                   DC.B     %00100000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00111100
                   DC.B     %00000100
                   DC.B     %00111000
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %01111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00001000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00100000
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %01000100
                   DC.B     %01001000
                   DC.B     %01110000
                   DC.B     %01001000
                   DC.B     %01000100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00001000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01101000
                   DC.B     %01010100
                   DC.B     %01010100
                   DC.B     %01010100
                   DC.B     %01010100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01111000
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00111100
                   DC.B     %00000100
                   DC.B     %00000100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01011000
                   DC.B     %01100100
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111000
                   DC.B     %01000000
                   DC.B     %00111000
                   DC.B     %00000100
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00111000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00001100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00111100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00101000
                   DC.B     %00010000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01010100
                   DC.B     %00101000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01000100
                   DC.B     %00101000
                   DC.B     %00010000
                   DC.B     %00101000
                   DC.B     %01000100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00111100
                   DC.B     %00000100
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01111100
                   DC.B     %00001000
                   DC.B     %00010000
                   DC.B     %00100000
                   DC.B     %01111100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00001000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00100000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00001000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00100000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00001000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00100000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010100
                   DC.B     %00101000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01011100
                   DC.B     %01100100
                   DC.B     %01011100
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000

Ú------------------------------------------------------------------------------¿
   Default font for characters 127 to 191
Ú------------------------------------------------------------------------------¿

A52E FONT_2        DC.B     %01111111
                   DC.B     %01000000
                   DC.B     %01010100
                   DC.B     %00101000
                   DC.B     %01010100
                   DC.B     %00101000
                   DC.B     %01010100
                   DC.B     %00101000
                   DC.B     %01010100
                   DC.B     %00101000
                   DC.B     %01010100
                   DC.B     %01000100
                   DC.B     %00000000
                   DC.B     %00110100
                   DC.B     %01001100
                   DC.B     %01000100
                   DC.B     %01001100
                   DC.B     %00110100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010100
                   DC.B     %00101000
                   DC.B     %00000000
                   DC.B     %00111100
                   DC.B     %01000100
                   DC.B     %01001100
                   DC.B     %00110100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00101000
                   DC.B     %00010000
                   DC.B     %00111100
                   DC.B     %01000100
                   DC.B     %01001100
                   DC.B     %00110100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00001000
                   DC.B     %00010000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01111100
                   DC.B     %01000000
                   DC.B     %00111100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01000100
                   DC.B     %00000000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010100
                   DC.B     %00101000
                   DC.B     %00000000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111100
                   DC.B     %01001100
                   DC.B     %01010100
                   DC.B     %01100100
                   DC.B     %01111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01000100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00111100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111100
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %00111100
                   DC.B     %00010000
                   DC.B     %00100000
                   DC.B     %00010100
                   DC.B     %00101000
                   DC.B     %00000000
                   DC.B     %01111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111100
                   DC.B     %01010000
                   DC.B     %01111100
                   DC.B     %01010000
                   DC.B     %01011100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00101100
                   DC.B     %01010000
                   DC.B     %01011100
                   DC.B     %01010000
                   DC.B     %00101100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00001000
                   DC.B     %00010000
                   DC.B     %00110100
                   DC.B     %01001100
                   DC.B     %01000100
                   DC.B     %01001100
                   DC.B     %00110100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00100000
                   DC.B     %00010000
                   DC.B     %00110100
                   DC.B     %01001100
                   DC.B     %01000100
                   DC.B     %01001100
                   DC.B     %00110100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00101000
                   DC.B     %00000000
                   DC.B     %00111100
                   DC.B     %01000100
                   DC.B     %01001100
                   DC.B     %00110100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01000100
                   DC.B     %00000000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01111100
                   DC.B     %01000000
                   DC.B     %00111100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00100000
                   DC.B     %00010000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01111100
                   DC.B     %01000000
                   DC.B     %00111100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00101000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01111100
                   DC.B     %01000000
                   DC.B     %00111100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01000100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00001000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00001000
                   DC.B     %00010000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00001000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00100000
                   DC.B     %00010000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00001000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00101000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00001000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00001000
                   DC.B     %00010000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00100000
                   DC.B     %00010000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00101000
                   DC.B     %00000000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00001000
                   DC.B     %00010000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00111100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00100000
                   DC.B     %00010000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00111100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00101000
                   DC.B     %00000000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00111100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01011000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01011000
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %00000000
                   DC.B     %00001000
                   DC.B     %00111100
                   DC.B     %01001000
                   DC.B     %01001000
                   DC.B     %01001000
                   DC.B     %00111100
                   DC.B     %00001000
                   DC.B     %00000000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00101000
                   DC.B     %00010000
                   DC.B     %01111100
                   DC.B     %00010000
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00100000
                   DC.B     %00010000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01000100
                   DC.B     %00010000
                   DC.B     %00101000
                   DC.B     %01000100
                   DC.B     %01111100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010100
                   DC.B     %00101000
                   DC.B     %00010000
                   DC.B     %00101000
                   DC.B     %01000100
                   DC.B     %01111100
                   DC.B     %01000100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00101000
                   DC.B     %00010000
                   DC.B     %00101000
                   DC.B     %01000100
                   DC.B     %01111100
                   DC.B     %01000100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00001000
                   DC.B     %00010000
                   DC.B     %01111100
                   DC.B     %01000000
                   DC.B     %01111100
                   DC.B     %01000000
                   DC.B     %01111100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010100
                   DC.B     %00101000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00110100
                   DC.B     %01000100
                   DC.B     %01001100
                   DC.B     %01010100
                   DC.B     %01100100
                   DC.B     %01000100
                   DC.B     %01011000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01000100
                   DC.B     %00000000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %00010000
                   DC.B     %00100000
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %01000100
                   DC.B     %01100100
                   DC.B     %01010100
                   DC.B     %01001100
                   DC.B     %01000100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111100
                   DC.B     %01001000
                   DC.B     %01001000
                   DC.B     %01111100
                   DC.B     %01001000
                   DC.B     %01001000
                   DC.B     %01001100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111100
                   DC.B     %01001000
                   DC.B     %01001000
                   DC.B     %01001100
                   DC.B     %01001000
                   DC.B     %01001000
                   DC.B     %00111100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00100100
                   DC.B     %01011000
                   DC.B     %01001000
                   DC.B     %01011000
                   DC.B     %00100100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01000000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01111100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01000000
                   DC.B     %00100000
                   DC.B     %00100000
                   DC.B     %00010000
                   DC.B     %00011000
                   DC.B     %00101000
                   DC.B     %01000100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %01100100
                   DC.B     %01011100
                   DC.B     %01000000
                   DC.B     %01000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111100
                   DC.B     %01101000
                   DC.B     %00101000
                   DC.B     %00101000
                   DC.B     %00101000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00111000
                   DC.B     %01010100
                   DC.B     %01010100
                   DC.B     %01010100
                   DC.B     %00111000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00100000
                   DC.B     %01000000
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %00000100
                   DC.B     %00111000
                   DC.B     %01000000
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01000000
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %00000100
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %00000000
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %01000100
                   DC.B     %00111000
                   DC.B     %01000100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010100
                   DC.B     %00101000
                   DC.B     %01010000
                   DC.B     %00101000
                   DC.B     %00010100
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %01010000
                   DC.B     %00101000
                   DC.B     %00010100
                   DC.B     %00101000
                   DC.B     %01010000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00101000
                   DC.B     %00010000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00000000
                   DC.B     %01111100
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00110000
                   DC.B     %01111100
                   DC.B     %00110000
                   DC.B     %00010000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00011000
                   DC.B     %01111100
                   DC.B     %00011000
                   DC.B     %00010000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00111000
                   DC.B     %01111100
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00000000
                   DC.B     %00000000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %00010000
                   DC.B     %01111100
                   DC.B     %00111000
                   DC.B     %00010000
                   DC.B     %00000000
                   DC.B     %00000000


;part 99
2.26 Low level device routines.

2.26.1 Microdrive low level routines

Ú------------------------------------------------------------------------------¿
³=MD_FORMT        FORMAT A MICRODRIVE MEDIUM (TRAP #2 WITH D0 = $03)           ³
------------------------------------------------------------------------------
³ENTRY:           A0.L     pointer to medium name                              ³
³                                                                              ³
³EXIT:            D1.W     number of good sectors                              ³
³                 D2.W     total number of sector on media                     ³
³                 A0       corrupted                                           ³
³                 D3,A1,A2 and A3 preserved                                    ³
³                                                                              ³
³ERRORS:          ERR.OM   out of memory                                       ³
³                 ERR.NF   device not found                                    ³
³                 ERR.IU   device in use                                       ³
³                 ERR.FF   format failed                                       ³
À------------------------------------------------------------------------------Ù

   TRAP handler alters registers so that A6 now points at system variables.
   A1 points at channel defintion block. D1 = drive no.

A77A MD_FORMT      TST.B    SV.MDRUN(A6)           ;any microdrives already turning ?
                   BEQ.S    L0A784                 ;jump forward if not
                   MOVEQ    #ERR.IU,D0             ;signal "in use"
                   RTS

A784 L0A784        MOVE.L   D1,D7                  ;copy drive number to D7
A786 L0A786        MOVEA.L  A1,A4                  ;A4 points at medium name string
                   MOVE.L   #$480,D1               ;length of format definition block
                   JSR      MM_ALCHP               ;find the space,A0 points at header on e
                   BEQ.S    L0A798                 ;jump forward if number errors
                   RTS

   Note that the allocate heap space call clears the area allocated.
   First, build up the sector header. This consists of 14 bytes which
   contain the following information :-

   1.     "invisible" $FF byte
   2.     sector number byte
   3.     10 bytes of cartridge name
   4.     random number word
   5.     two bytes of checksum

A798 L0A798        LEA      16(A0),A0              ;A0 points at start of area after header
A79C L0A79C        MOVEA.L  A0,A5                  ;and copy to A5
                   MOVEQ    #-1,D0                 ;"invisible" $FF  and sector number
                   MOVE.W   D0,(A0)+

   Set up the area for the medium name by filling with space characters.

                   MOVEQ    #9,D1                  ;10 bytes to set
A7A4 L0A7A4        MOVE.B   #" ",(A0)+             ;set to ascii space
                   DBF      D1,L0A7A4

   Then set up the random no.
   The medium name is usually given in a the form such as a word then:

        "MDV1_MEDIUMNAME"

   So copy the actual name after the underscore to the header only.

                   MOVE.W   SV.RAND(A6),(A0)       ;copy system random number to header
                   SUBA.W   #10,A0                 ;point back at start of medium name
                   MOVE.W   (A4)+,D1               ;get name length
                   ADDQ.W   #5,A4                  ;A4 points at medium name string
                   SUBQ.W   #5,D1                  ;ignore device name,drive number and "_"
                   CMPI.W   #10,D1                 ;length ok ?
                   BLS.S    L0A7C2                 ;jump forward if so otherwise
                   MOVEQ    #10,D1                 ;use the first ten characters only
A7C2 L0A7C2        MOVE.B   (A4)+,(A0)+            ;copy to header character by character
                   SUBQ.W   #1,D1                  ;reduce length count
                   BGT.S    L0A7C2

   Now set up the 4 byte block header. This consists of the following:-

   1.     file number byte               = $FD "unused sector"
   2.     block number byte              = 0
   3.     two bytes of checksum

                   LEA      14(A5),A0              ;A0 points at end of header defined abov
                   MOVE.L   #$FD000C10,(A0)+       ;set all four bytes in one go

   Then the 606 byte long dummy sector. This is slightly longer then the
   normal sector length to allow for timing inaccuracies.
   $AA55 in binary is %1010101001010101.

                   ADDQ.W   #6,A0                  ;step past file length,access and type
                   MOVE.W   D0,(A0)+
                   MOVE.W   #$012A,D1              ;299 words to set
A7DA L0A7DA        MOVE.W   #$AA55,(A0)+           ;set to alternate one's and zero's
                   DBF      D1,L0A7DA

                   MOVE.W   #$0F0E,$021A(A5)       ;finally set the two checksum bytes.
                   MOVE.W   D7,D1                  ;get drive number
                   LEA      PC_MCTRL,A3            ;A3 points at microdrive control registe
                   MOVEQ    #%00010000,D0          ;mask for ?
                   JSR      TIMER1
                   ORI.W    #$0700,SR              ;disable interrupts
                   JSR      MD_SELCT               ;switch on the microdrive motor

   Wait until the microdrive gets up to speed.

                   MOVE.L   #$1E848,D0             ;allow ????? ms
A808 L0A808        SUBQ.L   #1,D0                  ;decrement count
                   BNE.S    L0A808                 ;try again unless finished

   Now send out the dummy sector headers,blocks and sectors one by one
   until 256 sectors have been written to the cartridge.

                   MOVE.B   #%00001010,(A3)        ;signal "?"
A810 L0A810        MOVEA.L  A5,A1                  ;A1 points at sector header
                   MOVEQ    #13,D1                 ;length of sector header - 1

   Wait for the interblock gap to pass.

                   MOVE.W   #$479,D0
A818 L0A818        DBF      D0,L0A818

   Now send the sector header.

                   JSR      MD_SENDH(PC)           ;send the sector header
                   MOVE.W   #$0261,D1              ;length of block header + sector

   Wait for the header block/sector gap to pass.

                   MOVE.W   #$047B,D0
A828 L0A828        DBF      D0,L0A828

   Finnally send the actual dummy sector.

                   JSR      MD_SENDH(PC)           ;send the sector
                   SUBQ.B   #1,-$026F(A1)          ;decrement sector count
                   BCC.S    L0A810                 ;try next sector if greater than 0

   All the sectors have been written to the cartridge so try to read them
   back and find out which one's are faulty.

                   MOVE.B   #%00000010,(A3)        ;signal "?"
                   CLR.L    -(A7)
                   MOVEQ    #0,D5                  ;prepare D5
A83E L0A83E        MOVE.W   #$00FF,D5              ;set up byte pair for microdrive map
A842 L0A842        MOVEA.L  A5,A1                  ;1 points at start of sector header buff
                   JSR      MD_SECTR(PC)           ;read in the sector header

   These are the return points for the three read sector header errors.

                   BRA.S    L0A860                 ;branch if bad medium
                   BRA.S    L0A85C                 ;branch if bad header
                   JSR      L0AA16(PC)
                   BRA.S    L0A85C

A852 L0A852        ADD.W    D7,D7
                   SUBQ.B   #1,0(A1,D7.W)
                   TST.W    D7
                   BEQ.S    L0A864
A85C L0A85C        DBF      D5,L0A842
A860 L0A860        BRA      L0A8FA

A864 L0A864        TST.L    D5
A866 L0A866        BLT.S    L0A86C
                   MOVEQ    #-1,D5
                   BRA.S    L0A83E

A86C L0A86C        MOVEQ    #0,D5
A86E L0A86E        SUBQ.B   #1,(A1)
A870 L0A870        CMPI.B   #$FE,(A1)
                   BGT.S    L0A882
                   BEQ.S    L0A87A
                   ADDQ.W   #1,(A7)
A87A L0A87A        MOVE.B   D5,3(A7)
                   MOVE.B   (A1),D4
                   MOVEA.L  A1,A4
A882 L0A882        ADDQ.W   #2,A1
                   ADDQ.B   #1,D5
                   BCC.S    L0A86E
                   ST       (A4)
                   ADDQ.B   #2,D4
                   BEQ.S    L0A890
                   SUBQ.W   #1,(A7)
A890 L0A890        CMPI.W   #$C8,(A7)
                   BLT.S    L0A8FA
                   LEA      14(A5),A1
                   MOVEQ    #0,D0
A89C L0A89C        CLR.L    (A1)+
                   ADDQ.B   #1,D0
                   BPL.S    L0A89C
                   LEA      $270(A5),A1
                   MOVE.B   #$F8,(A1)
                   MOVE.L   (A7),D1
                   ADD.W    D1,D1
                   SUBI.W   #16,D1
A8B2 L0A8B2        SUBQ.W   #2,D1
                   CMPI.B   #$FD,0(A1,D1.W)
                   BNE.S    L0A8B2
                   CLR.B    0(A1,D1.W)
                   MOVE.W   D1,$1FE(A1)
                   LSR.W    #1,D1
                   MOVE.B   D1,(A7)
                   MOVEQ    #0,D2
                   JSR      L0A99C(PC)
                   BRA.S    L0A8FA

A8D0 L0A8D0        LEA      $270(A5),A1
                   MOVE.W   (A1),-(A7)
                   JSR      MD_WRITE(PC)
                   ADDQ.W   #2,A7
                   MOVE.B   (A7),D2
                   JSR      L0A99C(PC)
                   BRA.S    L0A8FA

A8E4 L0A8E4        LEA      14(A5),A1
                   MOVE.L   #64,(A1)
                   CLR.W    -(A7)
                   JSR      MD_WRITE(PC)
                   ADDQ.W   #2,A7
                   MOVEQ    #0,D7
                   BRA.S    L0A8FC

A8FA L0A8FA        MOVEQ    #-14,D7
A8FC L0A8FC        JSR      MD_DESEL               ;switch all the microdrive motors off
A902 L0A902        LEA      -$0010(A5),A0
                   JSR      MM_RECHP               ;release the space
                   JSR      CLRTMODE
                   ANDI.W   #$F0FF,SR              ;enable interrupts
                   CLR.B    (A7)
                   MOVE.W   (A7)+,D1
                   MOVE.W   (A7)+,D2
                   MOVE.L   D7,D0
                   RTS

A920 MD_SENDH      LEA      L0A926(PC),A4
A924 L0A924        BRA.S    L0A95E

A926 L0A926        MOVEQ    #10,D4
A928 L0A928        BRA.S    L0A954

Ú------------------------------------------------------------------------------¿
³=MD_WRITE        WRITE A MICRODRIVE SECTOR           (VECTOR $126)            ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     start of buffer containing sector                   ³
³                 A3.L     address of microdrive control register              ³
³                                                                              ³
³EXIT:            A1.L     updated pointer to buffer                           ³
³                 D1-6,A0,A2 and A4 corrupted                                  ³
³                 A3.L     preserved                                           ³
³                                                                              ³
³ERRORS:          none                                                         ³
À------------------------------------------------------------------------------Ù

   The stack should contain a word with the following information:-

   1.     high byte = file number
   2.     low byte  = block number

A92A MD_WRITE      MOVE.B   #%00001010,(A3)
A92E L0A92E        MOVE.W   #$5C9,D0
A932 L0A932        DBF      D0,L0A932
                   MOVEA.L  A1,A0
                   LEA      4(A7),A1
                   MOVEQ    #1,D1
                   LEA      L0A944(PC),A4
                   BRA.S    L0A95E

A944 L0A944        MOVEA.L  A0,A1
A946 L0A946        MOVE.W   #$1FF,D1
                   MOVEQ    #5,D5
                   LEA      L0A952(PC),A4
                   BRA.S    L0A96C

A952 L0A952        MOVEQ    #2,D4
A954 L0A954        MOVEQ    #$30,D0
A956 L0A956        DBF      D0,L0A956
A95A L0A95A        MOVE.B   D4,(A3)
                   RTS

A95E L0A95E        MOVEQ    #14,D0
A960 L0A960        MOVE.B   D0,(A3)
                   MOVE.B   D0,(A3)
                   MOVEQ    #1,D6
                   LEA      2(A3),A2
                   MOVEQ    #9,D5
A96C L0A96C        MOVEQ    #0,D4
A96E L0A96E        BSR.S    L0A994
                   SUBQ.B   #1,D5
                   BGE.S    L0A96E
                   MOVEQ    #-1,D4
                   BSR.S    L0A994
                   BSR.S    L0A994
                   MOVE.W   #$F0F,D3
                   MOVEQ    #0,D4
A980 L0A980        MOVE.B   (A1)+,D4
                   ADD.W    D4,D3
                   BSR.S    L0A994
                   DBF      D1,L0A980
                   MOVE.W   D3,D4
                   BSR.S    L0A994
                   LSR.W    #8,D4
                   BSR.S    L0A994
                   JMP      (A4)

A994 L0A994        BTST     D6,(A3)
A996 L0A996        BNE.S    L0A994
                   MOVE.B   D4,(A2)
                   RTS

A99C L0A99C        MOVEQ    #0,D5
A99E L0A99E        MOVEA.L  A5,A1
A9A0 L0A9A0        BSR.S    MD_SECTR
                   RTS

A9A4 L0A9A4        BRA.S    L0A99E

A9A6 L0A9A6        CMP.B    D7,D2
                   BEQ.S    L0A9B0
                   ADDQ.B   #1,D5
                   BCC.S    L0A99E
                   RTS

A9B0 L0A9B0        ADDQ.L   #2,(A7)
A9B2 L0A9B2        RTS

Ú------------------------------------------------------------------------------¿
³=MD_SECTR        READ A MICRODRIVE SECTOR HEADER     (VECTOR $12A)            ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     start of buffer for header                          ³
³                 A3.L     address of microdrive control register              ³
³                                                                              ³
³EXIT:            D7.B     sector number                                       ³
³                 A1.L     one past end of buffer                              ³
³                 D1-6,A0,A2 and A4 corrupted                                  ³
³                 A3       preserved                                           ³
³                                                                              ³
³ERRORS:          none     multiple returns (3) are used instead               ³
À------------------------------------------------------------------------------Ù

A9B4 MD_SECTR      JSR      L0AA94(PC)
A9B8 L0A9B8        RTS

A9BA L0A9BA        ADDQ.L   #2,(A7)
                   MOVEQ    #13,D1
                   BSR.S    L0AA3E
                   BRA.S    L0A9D2

A9C2 L0A9C2        CMPI.B   #$FF,-14(A1)
                   BNE.S    L0A9D2
                   MOVEQ    #0,D7
                   MOVE.B   -13(A1),D7
                   ADDQ.L   #2,(A7)
A9D2 L0A9D2        RTS

Ú------------------------------------------------------------------------------¿
³=MD_READ         READ A MICRODRIVE SECTOR            (VECTOR $124)            ³
³=MD_VERIN        VERIFY A MICRODRIVE SECTOR          (VECTOR $128)            ³
------------------------------------------------------------------------------
³ENTRY:           A1.L     start of buffer for header                          ³
³                 A3.L     address of microdrive control register              ³
³                                                                              ³
³EXIT:            D1.L     file number                                         ³
³                 D2.L     block number                                        ³
³                 D7.B     sector number                                       ³
³                 A1.L     updated pointer                                     ³
³                 D3-6,A0,A2 and A4 corrupted                                  ³
³                 A3       preserved                                           ³
³                                                                              ³
³ERRORS:          none     multiple returns (2) are used instead               ³
À------------------------------------------------------------------------------Ù

A9D4 MD_READ       LEA      L0AA3E(PC),A0
                   BRA.S    L0A9DE

A9DA MD_VERIN      LEA      L0AA5A(PC),A0
A9DE L0A9DE        JSR      L0AA94(PC)
                   RTS

A9E4 L0A9E4        MOVE.L   A1,-(A7)
                   CLR.W    -(A7)
                   MOVEA.L  A7,A1
                   MOVEQ    #1,D1
                   BSR.S    L0AA3E
                   BRA.S    L0AA08

A9F0 L0A9F0        MOVE.B   #2,D1
                   MOVE.B   D1,(A3)
                   MOVE.B   D1,(A3)
                   MOVE.W   #$1FF,D1
                   MOVEA.L  2(A7),A1
                   JSR      (A0)
                   BRA.S    L0AA08

AA04 L0AA04        ADDQ.L   #2,6(A7)
AA08 L0AA08        MOVEQ    #0,D1
                   MOVEQ    #0,D2
                   MOVE.B   1(A7),D2
                   MOVE.B   (A7)+,D1
                   ADDQ.W   #4,A7
                   RTS

AA16 L0AA16        JSR      L0AA94(PC)
AA1A L0AA1A        RTS

AA1C L0AA1C        MOVE.W   #$261,D1
                   BSR.S    L0AA5A
                   RTS

AA24 L0AA24        ADDQ.L   #2,(A7)
                   RTS

AA28 L0AA28        MOVE.W   #$100,D0
AA2C L0AA2C        MOVE.W   #$F0F,D3
                   MOVEQ    #0,D4
                   MOVEQ    #2,D6
                   LEA      2(A3),A4
                   LEA      3(A3),A2
                   RTS

AA3E L0AA3E        BSR.S    L0AA28
AA40 L0AA40        BTST     D6,(A3)
AA42 L0AA42        DBNE     D0,L0AA40
                   EXG      A2,A4
                   MOVE.B   (A2),D4
                   MOVE.B   D4,(A1)+
                   ADD.W    D4,D3
                   TST.W    D0
                   BLT.S    L0AA92
                   MOVEQ    #$14,D0
                   SUBQ.W   #1,D1
                   BGE.S    L0AA40
                   BRA.S    L0AA76

AA5A L0AA5A        BSR.S    L0AA28
AA5C L0AA5C        BTST     D6,(A3)
AA5E L0AA5E        DBNE     D0,L0AA5C
                   EXG      A2,A4
                   MOVE.B   (A2),D4
                   CMP.B    (A1)+,D4
                   BNE.S    L0AA92
                   ADD.W    D4,D3
                   TST.W    D0
                   BLT.S    L0AA92
                   MOVEQ    #$14,D0
                   SUBQ.W   #1,D1
                   BGE.S    L0AA5C
AA76 L0AA76        BTST     D6,(A3)
                   DBNE     D0,L0AA76
                   EXG      A2,A4
                   MOVE.B   (A2),D4
                   ROR.W    #8,D4
                   TST.W    D0
                   BLT.S    L0AA92
                   MOVEQ    #$14,D0
                   ADDQ.W   #1,D1
                   BEQ.S    L0AA76
                   CMP.W    D4,D3
                   BNE.S    L0AA92
                   ADDQ.L   #2,(A7)
AA92 L0AA92        RTS

AA94 L0AA94        MOVEQ    #0,D1
AA96 L0AA96        SUBQ.W   #1,D1
AA98 L0AA98        BEQ.S    L0AABC
                   BTST     #3,(A3)
                   BEQ.S    L0AA96
                   MOVEQ    #0,D1
AAA2 L0AAA2        SUBQ.W   #1,D1
                   BEQ.S    L0AABC
                   MOVEQ    #$17,D0
AAA8 L0AAA8        BTST     #3,(A3)
                   BNE.S    L0AAA2
                   DBF      D0,L0AAA8
                   MOVE.B   #2,D1
                   MOVE.B   D1,(A3)
                   MOVE.B   D1,(A3)
                   ADDQ.L   #2,(A7)
AABC L0AABC        RTS

2.26.2 Keyboard low level routines.

Ú------------------------------------------------------------------------------¿
³=                                                                             ³
------------------------------------------------------------------------------
³ENTRY:           D2.?                                                         ³
³                                                                              ³
³EXIT:            D1.W     high byte = ASCII code of key press                 ³
³                           low byte = $FF if the ALT key pressed also         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

AABE L0AABE        MOVEQ    #1,D0
                   BTST     #2,D2
                   BEQ.S    L0AACA
                   ADDI.B   #$3D,D1
AACA L0AACA        EXT.W    D1
                   MOVE.B   L0AB47(PC,D1.W),D1
                   CMPI.B   #32,D1
                   BHI.S    L0AAFA
                   BEQ.S    L0AAF6
                   CMPI.B   #31,D1
                   BNE.S    L0AAE6
                   BTST     D0,D2
                   BEQ.S    L0AAE6
                   MOVE.B   #$80,D1
AAE6 L0AAE6        BTST     #0,D2
                   BEQ.S    L0AAF2
                   LSL.W    #8,D1
                   MOVE.B   #$FF,D1
AAF2 L0AAF2        ADDQ.L   #2,(A7)
AAF4 L0AAF4        RTS

AAF6 L0AAF6        BTST     D0,D2
AAF8 L0AAF8        BNE.S    L0AAF4
AAFA L0AAFA        CMPI.B   #$5F,D1
                   BHI.S    L0AB0A
                   BTST     D0,D2
                   BEQ.S    L0AAE6
                   ADDI.B   #$60,D1
                   BRA.S    L0AAE6

AB0A L0AB0A        CMPI.B   #$7F,D1
AB0E L0AB0E        BHI.S    L0AB32
                   BTST     D0,D2
                   BEQ.S    L0AB1A
                   SUBI.B   #$60,D1
                   BRA.S    L0AAE6

AB1A L0AB1A        TST.B    $88(A6)
AB1E L0AB1E        BEQ.S    L0AAE6
                   LEA      L03C96,A3
                   CMP.B    0(A3,D1.W),D0
                   BNE.S    L0AAE6
                   BCLR     #5,D1
                   BRA.S    L0AAE6

AB32 L0AB32        CMPI.B   #$E7,D1
AB36 L0AB36        BHI.S    L0AB3C
                   ADD.B    D2,D1
                   BRA.S    L0AAF2

AB3C L0AB3C        CMPI.B   #$FB,D1
AB40 L0AB40        BHI.S    L0AAE6
                   BTST     D0,D2
                   BEQ.S    L0AAE6
                   ADDQ.B   #1,D1
                   BRA.S    L0AAE6

AB4C L0AB4C        DC.B     '/','n',',','8','2','6','q','e'
                   DC.B     '0','t','u','9','w','i',$09,'r'
                   DC.B     '-','y','o','l','3','h','1','a'
                   DC.B     'p','d','j','[',$E0,'k','s','f'
                   DC.B     '=','g',';',']','z','.','c','b'
                   DC.B     '`','m',''',$0A,$C0,$D0,$1B,$C8
                   DC.B     '\',' ',$D8,$F4,$E8,'5',$EC,$F0
                   DC.B     $F8,'4','7','X','V','?','N','<'

                   DC.B     '*','at','^','Q','E',')','T','U'
                   DC.B     '(','W','I',$FD,'R','_','Y','O'
                   DC.B     'L','#','H','!','A','P','D','J'
                   DC.B     '{',$E0,'K','S','F','+','G',':'
                   DC.B     '}','Z','>','C','B','~','M','"'
                   DC.B     $FE,$C0,$D0,'',$C8,'|',$FC,$D8
                   DC.B     $F6,$EA,'%',$EE,$F2,$FA,'$','&'

2.26.3 Network low level routines.

ABC4 L0ABC4        BTST     #4,$A0(A6)
                   BNE.S    L0ABE6
ABCC L0ABCC        LEA      L18020,A3
                   LEA      -30(A3),A2
                   MOVEQ    #24,D0
                   JSR      L0040E
                   ORI.W    #$0700,SR              ;disable interrupts
                   MOVEQ    #0,D7
                   RTS

ABE6 L0ABE6        ADDQ.W   #4,A7
                   MOVEQ    #-1,D0
                   BRA      L0ACF2

Ú------------------------------------------------------------------------------¿
³=NT_RPCKT        RECEIVE A NETWORK PACKET                                     ³
------------------------------------------------------------------------------
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

ABEE L0ABEE        MOVEM.L  D4-7,-(A7)
                   CLR.W    $1C(A0)
                   BSR.S    L0ABC4
ABF8 L0ABF8        MOVE.W   #$16E2,D4
ABFC L0ABFC        MOVE.W   #$01B5,D0
AC00 L0AC00        BTST     D7,(A3)
                   BEQ.S    L0AC0A
                   DBF      D4,L0ABFC
                   BRA.S    L0AC7C

AC0A L0AC0A        DBF      D0,L0AC00
AC0E L0AC0E        MOVE.W   #$C34,D0
AC12 L0AC12        BTST     D7,(A3)
                   BNE.S    L0AC1C
                   DBF      D0,L0AC12
                   BRA.S    L0AC7C

AC1C L0AC1C        MOVE.W   #$DA,D0
AC20 L0AC20        DBF      D0,L0AC20
AC24 L0AC24        LEA      $20(A0),A1
                   MOVEQ    #8,D1
                   BSR      L0ACFE
                   BLT.S    L0ABF8
                   SUB.B    -(A1),D3
                   CMP.B    (A1),D3
                   BNE.S    L0ABF8
                   SUBQ.W   #7,A1
                   MOVE.W   $18(A0),D3
                   ROR.W    #8,D3
                   TST.B    D3
                   BEQ.S    L0AC4C
                   CMP.B    $19(A0),D3
                   BEQ.S    L0AC4C
                   CMP.W    (A1),D3
                   BRA.S    L0AC4E

AC4C L0AC4C        CMP.B    (A1),D3
AC4E L0AC4E        BNE.S    L0AC7C
AC50 L0AC50        MOVE.W   2(A1),D6
                   SUB.W    $1A(A0),D6
                   BNE.S    L0AC60
                   MOVE.L   4(A1),$1C(A0)
AC60 L0AC60        BSR      L0AD84
                   MOVE.B   $1D(A0),D1
                   BSR      L0ACFE
                   BNE.S    L0AC7C
                   CMP.B    $1E(A0),D3
                   BNE.S    L0AC7C
                   BSR      L0AD84
                   TST.W    D6
                   BEQ.S    L0ACDC
AC7C L0AC7C        CLR.W    $1C(A0)
                   BRA.S    L0ACEA

Ú------------------------------------------------------------------------------¿
³=NT_SPCKT        SEND A NETWORK PACKET                                        ³
------------------------------------------------------------------------------
³ENTRY:                                                                        ³
³                                                                              ³
³EXIT:                                                                         ³
³                                                                              ³
³ERRORS:                                                                       ³
À------------------------------------------------------------------------------Ù

AC82 L0AC82        MOVEM.L  D4-7,-(A7)
                   BSR      L0ABC4
                   MOVE.B   $1D(A0),D1
                   MOVEQ    #0,D3
                   LEA      $20(A0),A1
AC94 L0AC94        ADD.B    (A1)+,D3
                   SUBQ.B   #1,D1
                   BNE.S    L0AC94
                   MOVE.B   D3,$001E(A0)
                   MOVEQ    #7,D1
                   MOVEQ    #0,D3
                   LEA      $18(A0),A1
ACA6 L0ACA6        ADD.B    (A1)+,D3
                   SUBQ.B   #1,D1
                   BNE.S    L0ACA6
                   MOVE.B   D3,(A1)
                   SUBQ.W   #7,A1
                   BSR      L0AD3C
                   BNE.S    L0ACEC
                   MOVEQ    #8,D1
                   MOVEQ    #1,D5
ACBA L0ACBA        BSR      L0AD92
                   MOVEQ    #1,D1
                   LEA      $1F(A0),A1
                   BSR.S    L0ACFE
                   BEQ.S    L0ACD0
                   TST.B    $18(A0)
                   BNE.S    L0ACEA
                   MOVEQ    #1,D3
ACD0 L0ACD0        SUBQ.B   #1,D3
                   BNE.S    L0ACEA
                   MOVE.B   $1D(A0),D1
                   DBF      D5,L0ACBA
ACDC L0ACDC        ADDQ.B   #1,$1A(A0)
                   BCC.S    L0ACE6
                   ADDQ.B   #1,$1B(A0)
ACE6 L0ACE6        MOVEQ    #0,D0
                   BRA.S    L0ACEC

ACEA L0ACEA        MOVEQ    #-1,D0                 ;signal "not complete"
ACEC L0ACEC        JSR      CLRTMODE
ACF2 L0ACF2        ANDI.W   #$F8FF,SR              ;enable interrupts
ACF6 L0ACF6        MOVEM.L  (A7)+,D4-7
                   TST.L    D0
                   RTS

ACFE L0ACFE        MOVE.W   #$18F,D0
AD02 L0AD02        MOVEQ    #0,D3
AD04 L0AD04        BTST     D7,(A3)
                   BEQ.S    L0AD0A
                   BRA.S    L0AD10

AD0A L0AD0A        DBF      D0,L0AD04
AD0E L0AD0E        BRA.S    L0AD38

AD10 L0AD10        MOVEQ    #$46,D0
AD12 L0AD12        BTST     D7,(A3)
AD14 L0AD14        DBEQ     D4,L0AD12
                   BNE.S    L0AD38
                   MOVEQ    #7,D4
                   MOVEQ    #$13,D0
AD1E L0AD1E        ROR.B    D0,D7
                   MOVE.B   (A3),D0
                   ROXR.B   #1,D0
                   ROXR.B   #1,D2
                   MOVEQ    #6,D0
                   DBF      D4,L0AD1E
                   MOVE.B   D2,(A1)+
                   ADD.B    D2,D3
                   SUBQ.B   #1,D1
                   BNE.S    L0AD10
AD34 L0AD34        MOVEQ    #0,D0
                   RTS

AD38 L0AD38        MOVEQ    #ERR.NC,D0             ;signal "not complete"
AD3A L0AD3A        RTS

AD3C L0AD3C        MOVEQ    #$73,D0
AD3E L0AD3E        MULU     $2E(A6),D0
                   MOVE.W   D0,$2E(A6)
                   EXT.W    D0
                   ADDI.W   #$297,D0
AD4C L0AD4C        BTST     D7,(A3)
                   BNE.S    L0AD38
                   DBF      D0,L0AD4C
                   MOVE.B   $19(A0),D4
                   NOT.B    D4
                   MOVE.B   $A0(A6),D2
                   MOVEQ    #9,D1
AD60 L0AD60        LSL.B    #1,D4
                   ROL.B    #1,D2
                   ROXR.B   #1,D2
                   MOVE.B   D2,(A2)
                   BMI.S    L0AD78
                   MOVEQ    #5,D0
AD6C L0AD6C        BTST     D7,(A3)
                   BEQ.S    L0AD72
                   BRA.S    L0AD38

AD72 L0AD72        DBF      D0,L0AD6C
AD76 L0AD76        BRA.S    L0AD7E

AD78 L0AD78        MOVEQ    #$10,D0
AD7A L0AD7A        DBF      D0,L0AD7A
AD7E L0AD7E        DBF      D1,L0AD60
AD82 L0AD82        BRA.S    L0AD34

AD84 L0AD84        TST.B    $18(A0)
AD88 L0AD88        BEQ.S    L0AD34
                   MOVEQ    #1,D1
                   MOVE.W   #$FF01,D4
                   BRA.S    L0AD96

AD92 L0AD92        MOVEQ    #-1,D4
AD94 L0AD94        MOVE.B   (A1)+,D4
AD96 L0AD96        LSL.W    #1,D4
AD98 L0AD98        ROL.W    #2,D4
                   MOVEQ    #12,D3
                   MOVE.B   $A0(A6),D0
ADA0 L0ADA0        ASR.W    #1,D4
                   ROL.B    #1,D0
                   ROXR.B   #1,D0
                   MOVEQ    #0,D7
                   MOVE.B   D0,(A2)
                   SUBQ.W   #1,D3
                   BGE.S    L0ADA0
                   SUBQ.B   #1,D1
                   BNE.S    L0AD94
                   MOVE.B   $A0(A6),(A2)

   AND THE REST ...





A1_ABS       $32D6  ABS_ADDR     $31C6  ACK_INTR     $2BD6  BADPARAM     $04A8 
BADRAM       $015A  BADRAM2      $015C  BAD_DEV      $3600  BAD_HEAD     $29B2 
BAD_MEDI     $29B6  BAUDOK       $0838  BAUDTABL     $0870  BAUD_ERR     $5F52 
BAUD_EXI     $5F50  BEEPTBL      $5F56  BEEP_END     $5F6C  BEEP_EXI     $5F66 
BEEP_INS     $601A  BF_ABS       $7954  BF_ACOS      $78E6  BF_ACOT      $78EC 
BF_ASIN      $78F2  BF_ATAN      $78F8  BF_BEEPI     $7A42  BF_CHR       $7ADA 
BF_CODE      $7B52  BF_COS       $78FE  BF_COT       $7904  BF_DATE      $7BCA 
BF_DATES     $7C22  BF_DAY       $7C28  BF_DEG       $792E  BF_DIMN      $7B7A 
BF_EOF       $7A4E  BF_EXP       $790A  BF_FILL      $7AEC  BF_INKEY     $7A84 
BF_INT       $79E0  BF_KEYRW     $7BDC  BF_LEN       $7B3C  BF_LN        $7910 
BF_LOG10     $7916  BF_PEEK      $79F8  BF_PEEKL     $7A0A  BF_PEEKW     $7A00 
BF_PI        $79D2  BF_RAD       $7934  BF_RESPR     $7A2C  BF_RND       $797C 
BF_SIN       $791C  BF_SQRT      $7922  BF_TAN       $7928  BF_VER       $7A74 
BLOCKINF     $024E  BP.INIT      $0110  BP.LET       $0120  BP_ADATE     $61E2 
BP_ARC       $66C8  BP_ARC_R     $66CC  BP_AT        $612E  BP_AUTO      $73E8 
BP_BAUD      $5F3C  BP_BEEP      $5F78  BP_BLOCK     $781E  BP_BORDE     $7836 
BP_CALL      $6024  BP_CLEAR     $7666  BP_CLOSE     $656C  BP_CLS       $6F3E 
BP_CONTI     $771E  BP_COPY      $64D4  BP_COPYN     $64D8  BP_CSIZE     $60FC 
BP_CURSO     $6120  BP_DIR       $6430  BP_DLETE     $642A  BP_DLINE     $6DB2 
BP_EDIT      $73E4  BP_ELLIP     $6678  BP_ELPSR     $667C  BP_END       $63DA 
BP_EXEC      $62E6  BP_EXECW     $62EA  BP_EXIT      $63DC  BP_FILL      $65CE 
BP_FLASH     $65F2  BP_FORMT     $64BA  BP_INIT      $67EC  BP_INK       $6F18 
BP_INPUT     $6FF4  BP_LBYTE     $6358  BP_LET       $6C12  BP_LINE      $6660 
BP_LINER     $6664  BP_LIST      $6DD0  BP_LOAD      $76C2  BP_LRUN      $76C8 
BP_MERGE     $7698  BP_MODE      $6EE0  BP_MOVE      $7776  BP_MRUN      $76A2 
BP_NET       $6EFC  BP_NEW       $76D4  BP_OPEN      $658E  BP_OPENI     $6592 
BP_OPENN     $6596  BP_OVER      $6608  BP_PAN       $6F42  BP_PAPER     $6F20 
BP_PAUSE     $6F96  BP_PENDO     $7768  BP_PENUP     $7764  BP_POINT     $664E 
BP_POKE      $6FBA  BP_POKEL     $6FC8  BP_POKEW     $6FC2  BP_PRINT     $6FF6 
BP_READ      $62B8  BP_RECOL     $73BA  BP_RENUM     $7412  BP_RETRY     $7714 
BP_RJOB      $634C  BP_RNDMZ     $72E0  BP_RPOIN     $6652  BP_RUN       $7672 
BP_SAVE      $65B4  BP_SBYTE     $6392  BP_SCALE     $663C  BP_SCROL     $6F46 
BP_SDATE     $61F6  BP_SEXEC     $638E  BP_STOP      $76D8  BP_STRIP     $6F1C 
BP_TURN      $772A  BP_TURNT     $7722  BP_UNDER     $65EC  BP_WIDTH     $77FA 
BP_WINDO     $7810  BRK_KEY      $2DD8  BUF_DOWN     $0FE8  BUF_END      $0E48 
BUF_UP       $0F12  BV.CHRIX     $011A  BV_CHRIX     $4F48  BYTE_IO      $32C2 
CA.GTFP      $0114  CA.GTINT     $0112  CA.GTLIN     $0118  CA.GTSTR     $0116 
CANCEL       $1BF4  CA_ALBFP     $4F64  CA_ALBTP     $4F4C  CA_ALCHB     $4F74 
CA_ALFFP     $4F7C  CA_ALLNP     $4F78  CA_ALNLP     $4F6C  CA_ALNTP     $4F58 
CA_ALRTP     $4F5E  CA_ALSBS     $4F8A  CA_ALSBT     $4F7E  CA_ALTGP     $4F52 
CA_ALTKP     $4F68  CA_ALVVP     $4F70  CA_GTFP      $5C48  CA_GTINT     $5C44 
CA_GTLIN     $5C4C  CA_GTSTR     $5C40  CA_RECHP     $5094  CA_RENLP     $5088 
CA_RENTP     $508C  CA_REPFP     $5084  CA_RERIS     $4F46  CA_RERTP     $5098 
CA_RESBT     $509A  CA_REVVP     $5090  CHAR_OK1     $0B78  CHAR_OK2     $0BE8 
CHKBLOCK     $060E  CHKCHID      $3356  CHKCURNT     $0650  CHKENTRY     $0664 
CHKJBID      $03AA  CHKJBNO      $03D2  CHKJOB       $03C6  CHKJOBS      $05C2 
CHKPARIT     $0BEA  CHKPARNT     $067A  CHKPOLLM     $08D4  CHKPROMS     $4AF8 
CHKRAM1      $0170  CHKRAM2      $0182  CHKRAMEX     $013A  CHKSBIT      $0394 
CHKTRP1      $044E  CHKTRP2      $31B4  CHKTRP3      $328E  CHKTRP4      $3344 
CHK_ALT      $2E26  CHK_BORD     $1AC6  CHK_CURS     $1B28  CHK_DD       $35DE 
CHK_IPC      $2C3A  CHK_KEY      $2D72  CHK_LF       $0E90  CHK_NAME     $35F0 
CHK_SER1     $2C64  CHK_SER2     $2C78  CHK_SIZE     $1AC8  CLEANUP      $0392 
CLEARTAB     $0284  CLKMASK      $18D4  CLK_END      $6268  CLK_EXIT     $18E8 
CLRHEADR     $052C  CLRTMODE     $0440  CLR_SBLK     $2954  CLSCREEN     $0780 
CN.BTOIB     $0104  CN.BTOIL     $0108  CN.BTOIW     $0106  CN.DATE      $00EC 
CN.DAY       $00EE  CN.DTOF      $0100  CN.DTOI      $0102  CN.FTOD      $00F0 
CN.HTOIB     $010A  CN.HTOIL     $010E  CN.HTOIW     $010C  CN.ITOBB     $00F4 
CN.ITOBL     $00F8  CN.ITOBW     $00F6  CN.ITOD      $00F2  CN.ITOHB     $00FA 
CN.ITOHL     $00FE  CN.ITOHW     $00FC  CN_BTOIB     $3EA4  CN_BTOIL     $3EAC 
CN_BTOIW     $3EA8  CN_DATE      $40CE  CN_DAY       $4122  CN_DTOF      $3D84 
CN_DTOI      $3E30  CN_FTOD      $3F66  CN_HTOIB     $3E42  CN_HTOIL     $3E4A 
CN_HTOIW     $3E46  CN_ITOBB     $3F4C  CN_ITOBL     $3F44  CN_ITOBW     $3F48 
CN_ITOD      $3EC4  CN_ITOHB     $3F20  CN_ITOHL     $3F18  CN_ITOHW     $3F1C 
COLRMASK     $2730  CONCLOSE     $0DA4  CONDATA      $0CCA  CONM4_0      $4BFA 
CONM4_1      $4C06  CONM4_2      $4C12  CONM8_0      $4C1E  CONM8_1      $4C2A 
CONM8_2      $4C36  CONNMOK      $0CE6  CONOPEN      $0CBA  CONRECLM     $0DCA 
CON_I0       $4C42  CON_I1       $4C4E  CON_I2       $4C5A  CON_IO       $0DD0 
CON_LB       $0CAA  COPYRIGHT    $4C66  CTABLE_1     $1DA6  CTABLE_2     $1DAA 
CTRL_C       $2E54  CTRL_F5      $2E4E  DD_OK        $3608  DECIDE       $09A6 
DELETE       $0FEC  DISP_CUR     $1B04  DOIOOPEN     $6408  DOTRAP2      $6410 
DOTRAP3      $63E8  DOWAITIO     $338A  DO_CLOSE     $63D4  DO_TABLE     $2058 
DO_TRAP3     $63EA  ENDJCHK      $03C4  END_CLOS     $328A  END_NL       $1B74 
END_OF_ROM   $ADB7  END_OPEN     $325E  ENTER_SM     $0308  ENTRYFRE     $050C 
ERR_EXIT     $3892  ERR_MSGE     $38BE  ERR_OFST     $3894  ERR_OV_1     $4570 
ERR_OV_2     $4784  ERR_OV_3     $484E  ERR_OV_4     $49FA  ERR_OV_5     $4A86 
EXECLIST     $0A38  EXITIMER     $0436  EXITTRAP     $03A4  EXIT_ACT     $0964 
EXIT_BAU     $0830  EXIT_CHK     $2C8C  EXIT_CJB     $057A  EXIT_CLK     $6266 
EXIT_DD      $3624  EXIT_FIN     $069A  EXIT_FLA     $1188  EXIT_HAN     $005C 
EXIT_INT     $038E  EXIT_NL      $1B6C  EXIT_REB     $0758  EXIT_REC     $0700 
EXIT_REL     $0924  EXIT_REM     $065A  EXIT_RER     $073C  EXIT_UNL     $0896 
EXTNLINT     $036E  F1F2_MESS    $4C86  FILE_ABS     $1880  FILE_REL     $1886 
FILTER       $0F34  FINDSUBS     $0660  FIND_Q1      $0DC0  FLASHCUR     $1164 
FONT_1       $A1C2  FONT_2       $A52E  FRAMEINT     $089A  FS_CHECK     $1204 
FS_CHK       $120E  FS_FLUSH     $120A  FS_HEADR     $12B8  FS_HEADS     $12A6 
FS_LOAD      $1280  FS_MDINF     $1256  FS_POSAB     $1244  FS_POSRE     $124A 
FS_SAVE      $1294  GAPINT       $29D6  GETCHID      $6078  GETHEAD      $0688 
GETJBID      $03F6  GETTIME      $18BA  GET_HEAD     $12BC  GET_SIZE     $1D4C 
IGNORE       $005E  INPIPE       $0C90  INSERT       $0F18  INTRFINT     $2BE6 
IO.NAME      $0122  IO.QEOF      $00E4  IO.QIN       $00E0  IO.QOUT      $00E2 
IO.QSET      $00DC  IO.QTEST     $00DE  IO.SERIO     $00EA  IO.SERQ      $00E8 
IOSTRING     $32C0  IO_CALLF     $382C  IO_CLOSE     $3264  IO_DELET     $345C 
IO_EDLIN     $381E  IO_EEXIT     $3836  IO_ERRBO     $3822  IO_ERRNF     $3622 
IO_ERROK     $3826  IO_FBYTE     $3816  IO_FLINE     $37D6  IO_FNXTB     $3806 
IO_FORMT     $35C0  IO_FSTRG     $3808  IO_GEXIT     $3828  IO_HEADR     $384E 
IO_HEADS     $383A  IO_LNXTB     $37DA  IO_LOAD      $3802  IO_NAME      $3636 
IO_OPEN      $31E2  IO_OPEN2     $3464  IO_PEND      $3814  IO_QEOF      $3792 
IO_QIN       $3742  IO_QOUT      $3768  IO_QSET      $36FE  IO_QTEST     $3714 
IO_SBYTE     $3818  IO_SERIO     $3796  IO_SERQ      $36D6  IO_SNXTB     $37F2 
IO_SSTRG     $37EE  IO_TABLE1    $37CA  IO_TABLE2    $37D2  IO_TRAP2     $0312 
IO_TRAP3     $0318  IPC_CLOS     $0AA4  IPC_CMND     $2B8C  IPC_END      $2BBE 
IPC_GETP     $2BD2  IPC_OPEN     $0A94  IPC_PARA     $2BE2  IPC_PUT      $2B9E 
IPC_RETB     $2EAC  IPC_RETN     $2EA8  IPC_SEND     $2E8E  IPC_SET      $2E80 
IVECTORS     $0060  JBMAXOK      $0528  LENGTHOK     $0244  LIST_END     $0A56 
LPA_EVEN     $0BD0  LPA_MARK     $0BC6  LPA_NONE     $0BDA  LPA_ODD      $0BCC 
LPA_SPAC     $0BD2  MARKJOB      $05B0  MATHTBL      $4298  MD.READ      $0124 
MD.SECTR     $012A  MD.VERIN     $0128  MD.WRITE     $0126  MDV_IO       $11CE 
MDV_LB       $118A  MD_BAD       $1276  MD_CLOSE     $1812  MD_DESEL     $2B6A 
MD_END       $179A  MD_ERRBP     $1200  MD_ERREF     $133A  MD_ERREX     $17A2 
MD_ERRFE     $1322  MD_ERRNC     $147A  MD_ERRNF     $179E  MD_ERRRO     $1318 
MD_EXIT1     $2A9C  MD_EXIT2     $2A9E  MD_EXIT3     $2AA2  MD_EXIT4     $2AA6 
MD_FORMT     $A77A  MD_GETBL     $12AA  MD_INUSE     $1274  MD_OPEN      $168A 
MD_READ      $A9D4  MD_SBYTE     $1308  MD_SECTR     $A9B4  MD_SELCT     $2B70 
MD_SENDH     $A920  MD_SLAVE     $2916  MD_SSTRG     $12FA  MD_TBL       $11F6 
MD_VERIN     $A9DA  MD_WRITE     $A92A  MED_OK       $29CC  MEMTEST      $0168 
MLIST_0      $1E9D  MLIST_1      $1DE8  MLIST_3      $1E88  MLIST_4      $1ED6 
MLIST_5      $1F28  MLIST_6      $1F66  MLIST_7      $1F8C  MLIST_8      $1F92 
MLIST_9      $2046  MLIST_A      $204A  MLIST_B      $2142  MLIST_C      $2170 
MM.ALCHP     $00C0  MM.ALLOC     $00D8  MM.LNKFR     $00DA  MM.RECHP     $00C2 
MM_ALBAS     $30CA  MM_ALCHP     $2EC0  MM_ALLOC     $3016  MM_ALTPA     $2F0C 
MM_LNKFR     $3074  MM_REBAS     $30DA  MM_RECHP     $2F70  MM_RETPA     $2F9E 
MM_SRCH      $3046  MONTHTBL     $626C  MTABLE_1     $1E7E  MTABLE_2     $1EC4 
MTABLE_3     $1F54  MT_ACLK      $18CC  MT_ACTIV     $093A  MT_ALBAS     $073E 
MT_ALCHP     $06D4  MT_ALLOC     $06B8  MT_ALRES     $0704  MT_BAUD      $081C 
MT_CJOB      $04E8  MT_CLOCK     $18B4  MT_DMODE     $075C  MT_FREE      $2FF2 
MT_FRJOB     $059C  MT_INF       $04AE  MT_IPCOM     $080C  MT_JINF      $04C0 
MT_LINK      $0880  MT_LNKFR     $06C6  MT_PRIOR     $092A  MT_REBAS     $0744 
MT_RECHP     $06F8  MT_RELJB     $090C  MT_RERES     $0720  MT_RJOB      $0584 
MT_SCLK      $18CE  MT_SUSJB     $08EA  MT_TRAP1     $030C  MT_TRAPV     $06A4 
MT_UNLNK     $088C  NETCLOSE     $10B2  NETDATA      $107C  NETNMOK      $108C 
NETOPEN      $106E  NET_EXIT     $10AE  NET_IO       $10E0  NET_LB       $105E 
NEWCLK       $18DE  NEXTPBIT     $0BEE  NEXTTASK     $0A3A  NEXT_DD      $3206 
NEXT_IO      $11B8  NEXT_Q1      $0DB6  NEXT_Q2      $0DC2  NOLOC        $0622 
NORAMEX      $0054  NOSPACE      $04F0  NOSTART      $0570  NOSUBSID     $0696 
NOTCURNT     $05E6  NOTEMPTY     $073A  NOTOWNED     $0634  NOTWAIT      $060A 
NO_ALT       $2E4A  NO_CHNGE     $1A64  NO_NEWL      $0E6E  NT_ERRBP     $10DC 
NT_FBYTE     $111E  NT_PEND      $10F2  NT_RECLM     $10D8  NT_RPCKT     $ABEE 
NT_SBYTE     $112A  NT_SPCKT     $AC82  NXTLONG      $019A  NXT_DD       $35E6 
PART1        $0000  PART13       $4228  PART14       $4AF8  PART15       $556A 
PART16       $5F3C  PART19       $6DA2  PART3        $089A  PART5        $115C 
PART50       $7C56  PART51       $9694  PART6        $18B4  PART9        $2B8C 
PART99       $A77A  PIPECLOS     $0C7E  PIPEDATA     $0C1A  PIPENMOK     $0C26 
PIPEOPEN     $0C0C  PIPERECL     $0CA6  PIPE_LB      $0BFC  PIPE_OK      $0C72 
PIXL_DIV     $1A04  POLLM_OK     $08A4  POLLTASK     $2C12  POSSACTI     $04CE 
PP_ERRBP     $0C78  PP_EXIT      $0C74  PP_INPUT     $0C46  PRINT_CH     $2798 
PRNT_CUR     $1AFC  PRNT_ERR     $388A  PROCLIST     $6864  PTABLE1      $0B84 
PTABLE2      $0BC0  READ_DM      $07F8  RELEASE      $06E8  REPEATIO     $11B4 
REQ_M4       $07E8  RESETPC      $0004  RESETSSP     $0000  RI.EXEC      $011C 
RI.EXECB     $011E  RI_ABS       $4A8A  RI_ACOS      $437C  RI_ACOT      $43B6 
RI_ADD       $48D2  RI_ASIN      $438A  RI_ATAN      $43BE  RI_COS       $42D0 
RI_COT       $42FC  RI_DIV       $49FE  RI_DUP       $4ACE  RI_EXEC      $423E 
RI_EXECB     $4246  RI_EXIT      $428A  RI_EXP       $4576  RI_GET       $424C 
RI_INT       $4834  RI_JUMP      $4290  RI_LINT      $4852  RI_LIST      $4230 
RI_LN        $44DE  RI_LOAD      $425E  RI_LOG10     $44C4  RI_MOVE      $427C 
RI_MULT      $4966  RI_NEG       $4A90  RI_NINT      $4830  RI_NLINT     $4840 
RI_NORND     $480C  RI_POWFP     $447A  RI_RESET     $4278  RI_SIN       $42C8 
RI_SINGL     $4228  RI_SQRT      $45C2  RI_STORE     $4270  RI_SUB       $48C4 
RI_TAN       $42F4  RI_TEST      $4252  RI_TRIG      $42DA  RI_TRUNC     $47FA 
ROM_END      $01A0  SB.CCBTA     $0138  SB.CMPER     $0134  SB.FPCBL     $0132 
SB.FSTFC     $012E  SB.SNTX      $012C  SB.SPFBL     $0136  SB.SSTFE     $0130 
SB_CCBTA     $6E68  SB_CMPER     $8230  SB_EKEYT     $8B00  SB_ELNOT     $8A24 
SB_EMONT     $8B06  SB_ENAMT     $8A88  SB_ENMTE     $8A7E  SB_EOPST     $8AFA 
SB_ESEPT     $8AF4  SB_ESPCT     $8AE4  SB_ESTRT     $8ACE  SB_ESYMT     $8B24 
SB_ETXTT     $8AD8  SB_FPCBL     $8296  SB_FSTFC     $833C  SB_GQLCI     $888E 
SB_INIT      $67E8  SB_SNTX      $7FB6  SB_SPFBL     $8674  SB_SSTFE     $84D4 
SB_TRAP4     $031E  SCAN_CT      $31F2  SCAN_DD      $3202  SCHDTASK     $115C 
SCHEDULE     $08D0  SCRACTIV     $0DDA  SCRDATA      $0D1C  SCRNMOK      $0D34 
SCROPEN      $0D42  SCR_END      $0DA2  SCR_EXIT     $0D3C  SCR_M4       $0D8A 
SCR_NEWQ     $0D0C  SCR_OK       $0D3A  SC_ECHO      $0EA0  SC_EDLIN     $0EB4 
SC_ERRBP     $0E46  SC_FBYTE     $0E1E  SC_FLINE     $0EAE  SC_FSTRG     $0E24 
SC_GET       $0E26  SC_OPOK      $0E0A  SC_PEND      $0E1A  SC_SBYTE     $0E5A 
SC_SSTRG     $0E38  SC_TBL       $0E12  SD_ARC       $1E9E  SD_BADP1     $1946 
SD_BORDE     $1A56  SD_BORDR     $1A52  SD_CHAR      $19A6  SD_CHENQ     $19E4 
SD_CLEAR     $1C08  SD_CLINE     $1C6C  SD_CLR       $1C0E  SD_COL       $1B86 
SD_CURE      $1AE0  SD_CURS      $1AEE  SD_DONL      $1B4C  SD_DO_OP     $1C3A 
SD_ELIPS     $1F46  SD_ERRBP     $1948  SD_FILL      $1C86  SD_FLOOD     $1E0A 
SD_FOUNT     $1CE6  SD_FTOIW     $1DE2  SD_GCUR      $1DAC  SD_HOME      $1B76 
SD_LINE      $1E70  SD_NCOL      $1BA2  SD_NEWL      $1B52  SD_NL        $1B8C 
SD_NROW      $1BBA  SD_OUTR1     $1ABE  SD_OUTR2     $1B48  SD_OUTR3     $1BFC 
SD_OUTR4     $1CE2  SD_PANW      $1C22  SD_PCOL      $1B98  SD_PIXP      $1BC6 
SD_POINT     $1E62  SD_POS       $1B7C  SD_PROW      $1BB0  SD_PXENQ     $19D2 
SD_RECOL     $1C00  SD_REDEF     $1A6C  SD_REST      $1C54  SD_SCALE     $1DFC 
SD_SCRLL     $1C18  SD_SETCL     $1D04  SD_SETFL     $1D18  SD_SETMD     $1D24 
SD_SETSZ     $1D32  SD_SETUL     $1D2A  SD_SETUP     $1C36  SD_TAB       $1B82 
SD_TBL2      $194C  SD_WDEF      $1A10  SD_WHOLE     $1C7C  SD_XOK1      $1D72 
SD_YOK1      $1DA2  SECTASK      $2C1A  SERCLOSE     $0B28  SERDATA      $0A78 
SERNMOK      $0AC2  SEROPEN      $0A6A  SERPORT1     $0B36  SER_EXIT     $0ABA 
SER_INQ      $0B04  SER_IO       $0B50  SER_IPC      $0B44  SER_LB       $0A5A 
SER_OUTQ     $0AF0  SER_TXRX     $2C8E  SETCLK       $18DC  SETIO        $01CA 
SETPOINT     $072C  SETUPTRA     $0324  SET_ATTR     $1D96  SET_CHAN     $3230 
SE_ERRIU     $0AB8  SE_ERRNF     $0AB4  SE_FBYTE     $0BAA  SE_PEND      $0B62 
SE_SBYTE     $0B6A  SHUTDOWN     $096E  SOUNDOFF     $6002  SOUNDON      $5FE2 
SPA_EVEN     $0BA6  SPA_MARK     $0B8A  SPA_NONE     $0B8E  SPA_ODD      $0B9E 
SPA_SPAC     $0B98  STARTUP      $0A12  STILLACT     $096A  SYSINT       $0340 
SYSVAR       $01FC  TABLE1       $0460  TEHA_TBL     $88D6  TESTED       $01C0 
TESTENTR     $04FA  TESTRAM      $0188  TEST_BIT     $1D2C  TIMER1       $040E 
TIMER2       $0410  TIMER3       $041A  TIMER4       $0420  TOO_BIG      $1ADC 
TRNSMINT     $2BF2  TRY_SCR      $0D12  TVECTORS     $0080  TYPE_OK      $346E 
UT.CON       $00C6  UT.CSTR      $00E6  UT.ERR       $00CC  UT.ERR0      $00CA 
UT.LINK      $00D2  UT.MINT      $00CE  UT.MTEXT     $00D0  UT.SCR       $00C8 
UT.UNLNK     $00D4  UT.WINDW     $00C4  UT_CON       $3A64  UT_CSTR      $3B0A 
UT_ERR       $3872  UT_ERR0      $3868  UT_FILL0     $24A0  UT_FILL1     $2516 
UT_FILL2     $2522  UT_FILL3     $252E  UT_LINK      $3A4A  UT_MINT      $3A00 
UT_MTEXT     $3A22  UT_PAN       $25A0  UT_SCR       $3A6A  UT_SCRLL     $2556 
UT_UNLNK     $3A50  UT_WINDW     $3A60  WIN_CMND     $18EC  WRITE_TY     $0804 
W_CMND       $0E56  XBRANCH      $0028  XHANDLER     $0050  XVECTOR      $0008 



